{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["trimmer","stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#description","title":"Description","text":"<p>LoVis4u is a bioinformatics tool for Loci Visualisation.</p> <p>Supported input: Genbank, gff3 with sequence   Supported output: Static vector graphics (pdf)  Programming language: Python3  OS: MacOS, Linux Python dependencies: biopython, bcbio-gff, scipy, configs, argparse, pandas, distinctipy, matplotlib, seaborn, reportlab Python version: &gt;= 3.9 OS-level dependencies: MMseqs2 (included in the package) License: WTFPL Version: 0.0.2 (April 2024)</p>"},{"location":"#output-example","title":"Output example:","text":""},{"location":"#installation","title":"Installation \ud83d\udee0\ufe0f","text":"<ul> <li>The most stable release of lovis4u can be installed directly from pypi:</li> </ul> <pre><code>python3 -m pip install lovis4u\n</code></pre> <ul> <li>The development version is available at github :</li> </ul> <pre><code>git clone https://github.com/art-egorov/lovis4u.git\ncd lovis4u\npython3 -m pip install --upgrade pip\npython3 -m pip install setuptools wheel\npython3 setup.py sdist\npython3 -m pip install -e .\n</code></pre> <p>! If you're a linux user, run <code>lovis4u --linux</code> post-install command once to update paths in the premade config files that set by default for MacOS users.</p>"},{"location":"#reference","title":"Reference","text":"<p>If you find uorf4u useful, please cite: Artyom. A. Egorov, Gemma C. Atkinson, lovis4u: ---, ---</p>"},{"location":"#contact","title":"Contact","text":"<p>Please contact us by e-mail artemdotegorovATmeddotludotse or use Issues to report any technical problems. You can also use Discussions section for sharing your ideas or feature requests! </p>"},{"location":"#authors","title":"Authors","text":"<p>LoVis4u is developed by Artyom Egorov at the Atkinson Lab, Department of Experimental Medical Science, Lund University, Sweden \ud83c\uddf8\ud83c\uddea. We are open for suggestions to extend and improve LoVis4u functionality. Please don't hesitate to share your ideas or feature requests.</p>"},{"location":"API/package_drawing/","title":"Drawing","text":"<p>This module provides some methods (e.g. colors tranformation, data copying) used by the tool.</p>"},{"location":"API/package_drawing/#lovis4u.Methods.adjust_paths","title":"<code>adjust_paths(to)</code>","text":"<p>Change paths in the internal config files for linux or mac.</p> <p>Parameters:</p> <ul> <li> <code>to</code>             (<code>str</code>)         \u2013          <p>mac | linux</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def adjust_paths(to: str) -&gt; None:\n    \"\"\"Change paths in the internal config files for linux or mac.\n\n    Arguments:\n        to (str): mac | linux\n\n    Returns:\n        None\n\n    \"\"\"\n    internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n    config_files = [\"standard.cfg\"]\n    for config_file in config_files:\n        config_file_path = os.path.join(internal_dir, config_file)\n        with open(config_file_path, \"r+\") as config:\n            if to == \"linux\":\n                if not os.path.exists(os.path.join(internal_dir, \"bin/mmseqs_linux\")):\n                    os.system(f\"unzip -q -d {os.path.join(internal_dir, 'bin/')} \"\n                              f\"{os.path.join(internal_dir, 'bin/mmseqs_linux.zip')}\")\n                config_txt = re.sub(r\"mmseqs_mac/bin/mmseqs\", \"mmseqs_linux/bin/mmseqs\", config.read())\n            else:\n                config_txt = re.sub(r\"mmseqs_linux/bin/mmseqs\", \"mmseqs_mac/bin/mmseqs\", config.read())\n            config.seek(0)\n            config.truncate()\n            config.write(config_txt)\n    print(f\"\u2699\ufe0f  mmseqs path was adjusted to {to}\")\n    return None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.copy_package_data","title":"<code>copy_package_data()</code>","text":"<p>Copy the lovis4u package data folder to your current dir.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def copy_package_data() -&gt; None:\n    \"\"\"Copy the lovis4u package data folder to your current dir.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        users_dir = os.path.join(os.getcwd(), \"lovis4u_data\")\n        internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n        if os.path.exists(users_dir):\n            raise lovis4u.Manager.lovis4uError(\"lovis4u_data folder already exists.\")\n        shutil.copytree(internal_dir, users_dir, ignore=shutil.ignore_patterns(\"help*\", \".*\"))\n        print(\"\ud83d\uddc3\ufe0f lovis4u_data folder was copied to the current working directory\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(f\"Unable to copy lovis4u folder in your working dir.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.feature_nt_to_x_transform","title":"<code>feature_nt_to_x_transform(nt_start, nt_end, feature_strand, locus, layout)</code>","text":"<p>Transform feature coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>feature_strand</code>             (<code>int</code>)         \u2013          <p>1 | -1 corresponding to plus or minus strand, respectively.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def feature_nt_to_x_transform(nt_start: int, nt_end: int, feature_strand: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform feature coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        feature_strand (int): 1 | -1 corresponding to plus or minus strand, respectively.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    left_out, right_out = False, False\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] or coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if nt_start &lt; coordinate[\"start\"]:\n                if coordinate[\"strand\"] == 1:\n                    left_out = True\n                else:\n                    right_out = True\n                nt_start = coordinate[\"start\"]\n            if nt_end &gt; coordinate[\"end\"]:\n                if coordinate[\"strand\"] == 1:\n                    right_out = True\n                else:\n                    left_out = True\n                nt_end = coordinate[\"end\"]\n            x_coordinates = region_nt_to_x_transform(nt_start, nt_end, locus, layout)\n            x_coordinates[\"center\"] = (x_coordinates[\"start\"] + x_coordinates[\"end\"]) / 2\n            x_coordinates[\"orient\"] = feature_strand * coordinate[\"strand\"]\n            x_coordinates[\"lout\"] = left_out\n            x_coordinates[\"rout\"] = right_out\n            break\n    return x_coordinates\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.get_color","title":"<code>get_color(name, parameters)</code>","text":"<p>Get HEX color by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a color.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>HEX color.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_color(name: str, parameters: dict) -&gt; str:\n    \"\"\"Get HEX color by its name\n\n    Arguments:\n        name (str): name of a color.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        str: HEX color.\n\n    \"\"\"\n    hex_c = parameters.args[\"palette\"][parameters.args[name]]\n    return hex_c\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.get_color_rgba","title":"<code>get_color_rgba(name, parameters)</code>","text":"<p>Get rgba color by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a color.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (            <code>tuple</code> )        \u2013          <p>RGBA color</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_color_rgba(name: str, parameters: dict) -&gt; tuple:\n    \"\"\"Get rgba color by its name\n\n    Arguments:\n        name (str): name of a color.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        tuple: RGBA color\n\n    \"\"\"\n    return *matplotlib.colors.hex2color(get_color(name, parameters)), parameters.args[f\"{name}_alpha\"]\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.nt_to_x_transform","title":"<code>nt_to_x_transform(nt, locus, layout, mode)</code>","text":"<p>Transform nucleotide coordinate to x page coordinate.</p> <p>Parameters:</p> <ul> <li> <code>nt</code>             (<code>int</code>)         \u2013          <p>Nucleotide coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> <li> <code>mode</code>             (<code>str</code>)         \u2013          <p>Mode whether coordinate should be centered to the nt or on the side.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>Corresponding page coordinate.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def nt_to_x_transform(nt: int, locus, layout: dict, mode: str) -&gt; float:\n    \"\"\"Transform nucleotide coordinate to x page coordinate.\n\n    Arguments:\n        nt (int): Nucleotide coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n        mode (str): Mode whether coordinate should be centered to the nt or on the side.\n\n    Returns:\n        float: Corresponding page coordinate.\n\n    \"\"\"\n    passed_x = layout[\"loci_tracks_left_border\"]\n    for c_i in range(len(locus.coordinates)):\n        coordinate = locus.coordinates[c_i]\n        coordinate_region_width = (coordinate[\"end\"] - coordinate[\"start\"] + 1) * layout[\"width_per_nt\"]\n        if coordinate[\"start\"] &lt;= nt &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == 1:\n                relative_nt = nt - coordinate[\"start\"]\n            else:\n                relative_nt = coordinate[\"end\"] - nt\n            if mode == \"start\":\n                pass\n            elif mode == \"center\":\n                relative_nt += 0.5\n            elif mode == \"end\":\n                relative_nt += 1\n            relative_x = relative_nt * layout[\"width_per_nt\"]\n            global_x = passed_x + relative_x\n            break\n        passed_x += coordinate_region_width + layout[\"x_gap_between_regions\"]\n        if c_i &lt; len(locus.coordinates) - 1:\n            if locus.circular:\n                if coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == 1:\n                    if coordinate[\"end\"] == locus.length and locus.coordinates[c_i + 1][\"start\"] == 1:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n                elif coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == -1:\n                    if coordinate[\"start\"] == 1 and locus.coordinates[c_i + 1][\"end\"] == locus.length:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n    return global_x\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.region_nt_to_x_transform","title":"<code>region_nt_to_x_transform(nt_start, nt_end, locus, layout)</code>","text":"<p>Transform region coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def region_nt_to_x_transform(nt_start: int, nt_end: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform region coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] and coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == -1:\n                nt_start, nt_end = nt_end, nt_start\n            x_start = nt_to_x_transform(nt_start, locus, layout, \"start\")\n            x_end = nt_to_x_transform(nt_end, locus, layout, \"end\")\n            break\n    return dict(start=x_start, end=x_end)\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.scale_lightness","title":"<code>scale_lightness(hex_c, scale_l)</code>","text":"<p>Helper function to get darker version of input color</p> <p>Parameters:</p> <ul> <li> <code>hex_c</code>             (<code>str</code>)         \u2013          <p>input HEX color</p> </li> <li> <code>scale_l</code>             (<code>float</code>)         \u2013          <p>scale of lightness</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>new HEX color</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def scale_lightness(hex_c: str, scale_l: float) -&gt; str:\n    \"\"\"Helper function to get darker version of input color\n\n    Arguments:\n        hex_c (str): input HEX color\n        scale_l (float): scale of lightness\n\n    Returns:\n        str: new HEX color\n\n    \"\"\"\n    rgb = matplotlib.colors.hex2color(hex_c)\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n    hex_c = matplotlib.colors.rgb2hex(colorsys.hls_to_rgb(h, min(1, l * scale_l), s=s))\n    return hex_c\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.str_height_to_size","title":"<code>str_height_to_size(height, font_type)</code>","text":"<p>Transform string height to the font size.</p> <p>Parameters:</p> <ul> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>available height of the string.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>font size defined by height.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def str_height_to_size(height: float, font_type: str) -&gt; float:\n    \"\"\"Transform string height to the font size.\n\n    Arguments:\n        height (float): available height of the string.\n        font_type (str): font type (see config file; at this moment only regular is available).\n\n    Returns:\n        float: font size defined by height.\n\n    \"\"\"\n\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    font_size = (1000 * 1.38 * height) / (face.ascent - face.descent)\n    return font_size\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Methods.update_path_extension","title":"<code>update_path_extension(path, new_extension)</code>","text":"<p>Get path basename and replace its extension</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>path to a file</p> </li> <li> <code>new_extension</code>             (<code>str</code>)         \u2013          <p>new extension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>basename of a file with new extension.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def update_path_extension(path: str, new_extension: str) -&gt; str:\n    \"\"\"Get path basename and replace its extension\n\n    Arguments:\n        path (str): path to a file\n        new_extension (str): new extension\n\n    Returns:\n        str: basename of a file with new extension.\n\n    \"\"\"\n    updated_filename = f\"{os.path.splitext(os.path.basename(path))[0]}.{new_extension}\"\n    return updated_filename\n</code></pre>"},{"location":"API/usage_examples/","title":"Short example-drived guide to LoVis4u API.","text":"<p>LoVis4u has a simple API allowing it programmatic usage from within a python program. Below we descrive several Python snippets that mimic results of command-line calls.</p> <p>--- <pre><code>import lovis4u\n</code></pre></p> <p>Will be updated with more examples...</p>"},{"location":"ExampleDrivenGuide/cmd_guide/","title":"Example-driven guide","text":"<p>Here we show several usage examples of the uorf4u command-line interface for two well-known uORFs: ermCL (bacteria) and ATF4 (eukaryotes). (See review articles about uORFs in prokaryotes and eukaryotes: Ito et.al. 2013 and Dever et.al. 2020.</p> <p>Before start: The necessary sample data as well as adjustable tool' configuration files are provided by uorf4u at the post-install step:   <code>uorf4u --data</code> If you work on a Linux machine after installation you should run: <code>uorf4u --linux</code> This command replaces the tools paths (maft) in the pre-made config files from the MacOS' version (default) to the Linux'. </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#output-folder-structure","title":"Output folder structure","text":""},{"location":"ExampleDrivenGuide/cmd_guide/#bacteria-ermcl","title":"Bacteria: ermCL","text":"<p>Expression of 23S rRNA methyltransferase ermC is regulated by translational attenuation: ribosome stalling on the ermC uORF (named ermCL) is inducible by erythromycin. The arresst alters the regional mRNA structure, exposing the ermC SD sequence and allowing translation of the ermC ORF. </p> <p></p> <p>Using a single RefSeq protein accession number as input </p> <p>To test whether uORF4u will find the ermCL we can use only the RefSeq accession number of ermC protein as input which is WP_001003263.1. <code>uorf4u -an WP_001003263.1 -ul 400 -o ErmC -c bacteria</code>, All arguments, except <code>-an</code>, were optional. <code>-ul</code> was used to overrides the upstream region length to retrieve (default: 500). Output folder name can be set with <code>-o</code> parameter (default: uorf4u_{current_date}). We also used bacteria mode by specifying the premade configuration file with <code>-c</code> parameter.  </p> <p>uORF4u finds the expected ermCL and returns one set of conserved uORFs. Output contains MSA plot, annotation plot, and sequence logo: </p> <p>Using a list of homologues as input</p> <p>Alternatively, a list of homologues can be used as input. This is important for allowing a user to decide the breadth and depth of the search. In addition, it can be useful for creating compact output figures that can be used in articles. For such demonstration, we have chosen several ermC proteins from the previous run and used them as input: <pre><code>uorf4u -hl WP_202338192.1 WP_102227852.1 WP_034984371.1 WP_159316313.1 WP_095341278.1 WP_150861853.1 WP_011382144.1 WP_081624258.1 -c bacteria -annot -ul 400\n</code></pre> where <code>-annot</code> parameter was used to show on annotation plot known ORFs annotated in the NCBI (shown with blue outlines).  Note: List of homologues can be also written in a txt file (one accession per line) and used as input with <code>-hlf</code> parameter.</p> <p>Results with annotation plot, MSA visualisation and sequence logos:  </p> <p></p>"},{"location":"ExampleDrivenGuide/cmd_guide/#eukaryotes-atf4","title":"Eukaryotes: ATF4","text":"<p>The expression of ATF4 (activating transcription factor) is regulated by two uORFs. After translation of the first uORF1, ribosomes are normally able to reinitiate translation at a downstream uORF2 after rebinding the initiating ternary complex (eIF2-GTP-Met-tRNA). Reduced levels of the ternary complex during stress conditions leads to the ribosome scanning through the uORF2 start codon and instead reinitiating at the ATF4 uORF.</p> <p></p> <p>uORF4u has two modes: bacteria (set as default) and eukaryotes that defined by pre-made configuration files. Archaea mode (no SD sequence annotation + retrieving DNA sequences as well due the absence of mRNAs data) will be presented soon or can be set manually within config files.   The main differences between two modes: 1. For eukaryotes there is no SD sequence annotation step and corresponding uORF filtering. 2. While sequences retrieving for found homologues we take only mRNAs (the tool uses regex to perform that which is set by refseq_sequences_regex in the config files. For eukaryotes it's set as '^[NX]M_.*' that means that only sequences with ids that start with NM_ or XM_ (mRNAs) will be taken in the analysis).</p> <p>Using a single RefSeq protein accession number as input </p> <p>Similarly to the bacteria' example, firstly we can use a single protein accession number as input: <code>uorf4u -an NP_877962.1 -c eukaryotes -o ATF4</code> We used eukaryotes mode by specifying the premade configuration file with <code>-c</code> parameter.  </p> <p>uORF4u finds both uORFs and returns (as always) MSA plots (uORF1 nt, uORF2 nt), annotation plots (uORF1, uORF2) and sequence logos. A nucleotide sequence logo for uORF1: </p> <p>Using a list of homologues as input</p> <p>Let's use again a subset of the found homologues to get a compact output.  <pre><code>uorf4u -hl NP_001666.2 XP_036720744.1 XP_024434925.1 XP_034632036.1 XP_008703764.1 XP_034983127.1 XP_019400505.1 XP_003989324.2 XP_003419800.1 XP_019302483.1 XP_047407736.1 XP_032062344.1 -c eukaryotes\n</code></pre></p> <p></p> <p>Note: unfortunately, animal's emojis were added manually. </p> <p>Using a fasta file with sequences as input</p> <p>You can use a fasta file with sequences as input as well. Command example with a fasta file obtained from previous run as input: <code>uorf4u -fa ATF4/upstream_sequences.fa -c eukaryotes</code> </p> <p>It is useful to note that when using nucleotide sequences as input, uORF4u can be used as a general conserved ORF search tool, that is, not necessarily upstream of any particular mORF. But be carefull with this mode, recommended range of sequences' length ~100-1000nt and number of sequences: 10-1000. uORF4u was not designed to perform conservation analysis on chromosome' size set of sequences.</p>"},{"location":"Parameters/cmd_parameters/","title":"\u0421ommand-line parameters","text":"<p>POST-INSTALL DATA AND CONFIGURATION</p> <ul> <li> <p><code>--data</code> Creates the uorf4u_data folder in the current working directory. The folder will contain the adjustable configuration file templates, palettes, tables as well as the necessary sample.</p> </li> <li> <p><code>--linux</code> All Linux user should run it only once after installation. Replaces the tools paths in the premade config files from the MacOS' version [default] to the Linux'.</p> </li> <li> <p><code>--blastp_path</code> Update the blastp path in the pre-made config files. Required for using local blastp databases with <code>-lbdb</code> parameter. </p> </li> </ul> <p>MANDATORY ARGUMENTS</p> <ul> <li> <p><code>-an</code> accession_number Protein's RefSeq accession number.</p> <p>OR</p> </li> <li> <p><code>-hl</code> accession_number1 [accession_number2, ...] Space separated list of proteins accession numbers which will be used as list of homologous.</p> <p>OR</p> </li> <li> <p><code>-hlf</code> file.txt Path to a file with list of accession numbers. File format: one accession number per line, no header.</p> <p>OR</p> </li> <li> <p><code>-fa</code> file.fa     Path to a fasta file with upstream sequences.</p> </li> <li> <p><code>-c</code> bacteria|eukaryotes|file.cfg Path to a configuration file [default: internal].</p> </li> </ul> <p>OPTIONAL ARGUMENTS</p> <ul> <li> <p><code>-bdb</code> &lt;efseq_select|refseq_protein Online blastp database to perform blastp searching for homologues. [default: from config; refseq_select for bacteria, refseq_protein for eukaryotes]</p> </li> <li> <p><code>-lbdb</code> path to a database Local blastp database to perform blastp searching for homologues. Note: You have to specify path to a blastp with --blastp_path command before using this argument.</p> </li> <li> <p><code>-bh</code> number_of_hits Max number of blastp hits in homologous searching.</p> </li> <li> <p><code>-bid</code> identity_cutoff [0-1] BlastP searching cutoff for hit's identity to your query protein.</p> </li> <li> <p><code>-mna</code> number_f_assemblies Max number of assemblies to take into analysis for each protein. If there are more sequences in the identical protein database then random sampling will be used.</p> </li> <li> <p><code>-al</code> path_to/assemblies_list.tsv Path to an assemblies list file. During each run of uorf4u, a tsv table with information about assemblies (from identical protein database, ncbi) for each protein is saved to your output folder (output_dir_name/assemblies_list.tsv). There are cases with multiple assemblies for one protein accession numbers (up to thousands). In case to control assemblies included in the analysis this table can be filtered (simply by removing rows) and then used with this parameter as part of input to the next run. In addition, config file (see config parameters section) has max_number_of_assemblies parameter. It can be used to limit max number of assemblies included in the analysis. In case number of assemblies is more than the cutoff, random sampling will be used to take only subset of them.</p> </li> <li> <p><code>-annot</code> Retrieve sequences annotation (to be sure that annotated uORFs is not overlapped with a known CDS. </p> </li> <li> <p><code>-ul</code> length  Length of upstream sequences to retrieve.</p> </li> <li> <p><code>-dl</code> length  Length of downstream sequences to retrieve.</p> </li> <li> <p><code>-asc</code>  Include alternative start codons in uORF annotation step. List of alternative start codons are taken from the ncbi genetic code.</p> </li> <li> <p><code>-nsd</code> Deactivate filtering ORFs by SD sequence presence. [default: True for 'prokaryotes' config and False for 'eukaryotes' config].</p> </li> <li> <p><code>-at</code> aa|nt Alignment type used by uorf4u for conserved ORFs searching [default: aa]. </p> </li> <li> <p><code>-pc</code> cutoff [0-1] A cutoff of presence (number of ORFs in a list/number of sequences) for an ORFs set to be called conserved and returned [default: 0.4, set in the config].</p> </li> <li> <p><code>-fast</code> Fast searching mode with less accuracy (&gt;~300 sequences or &gt;~2000 ORFs).</p> </li> <li> <p><code>-o</code> dirname Output dirname. It will be created if it's not exist. All output dirs will be then created in this folder [default: uorf4u_{current_date}; e.g. uorf4u_2022_07_25-20_41].</p> </li> </ul> <p>MISCELLANEOUS ARGUMENTS</p> <ul> <li> <p><code>-h</code>, <code>--help</code> Show help message and exit.</p> </li> <li> <p><code>-v</code>, <code>--version</code> Show program version.</p> </li> <li> <p><code>--debug</code> Provide detailed stack trace for debugging purposes.</p> </li> <li> <p><code>--quiet</code> Don't show progress messages.</p> </li> </ul>"},{"location":"Parameters/config_parameters/","title":"Configuration file parameters","text":"<p>uorf4u configuration file allows detailed customization of the tool's parameters.</p> <p>Note:  uorf4u has two pre-made configuration files: uorf4u_eukaryotes.cfg and uorf4u_bacteria located in: ./uorftu/uorf4u_data/ folder (internal). By default, 'bacteria' config file is used if no path or name of premade file is specified by a cmd parameter: <code>-c  bacteria|eukaryotes|&lt;file.cfg&gt;</code>.  </p> <p>You can copy the uorf4u_data folder that contains the config files to your wiking directory with <code>uorf4u --data</code> command and safely edit and use them without affecting 'internal' set of configs. If you want to use a copied config file, use <code>-c path_to_config</code>.</p> <p>;[General] ncbi_genetic_code_name = Bacterial; the ncbi genetic code name ('Standard' for eukaryotes' config) ncbi_entrez_email = uorf4u@gmail.com; e-mail for the NCBI API. upstream_region_length = 500; [int or 'all'] Length of upstream region to retrieve. 'all' value is set for eukaryotes config file since by default it uses only mRNAs sequences. (can be overriden by <code>-ul</code> cmd parameter). minimal_upstream_region_length = 300; [int] minimal upstream region length for sequences to retrieve. If available sequence length to retrieve is shorter then this record won't be taken in the analysis.   downstream_region_length = 100; [int] downstream region (overlapped with CDS) length to retrieve. (can be overriden by <code>-dl</code> cmd parameter). filter_refseq_sequences_by_regex = True; [bool] use or not regex parameter (below) for filtering the NCBI RefSeq sequences to retrieve. refseq_sequences_regex = ^N_.; [regex] that will be used to filter the NCBI RefSeq sequnces. For eukaryotes set as '^[NX]M_.' that means that only sequences that start with NM_ or XM_ (mRNAs) will be taken in the analysis. max_number_of_assemblies = 1; [int] max number of assemblies to take into analysis for each protein. If there are more sequences in the identical protein database then random sampling will be used. (can be overriden by <code>-mna</code> cmd parameter).</p> <p>;[blastp homologous searching] blastp_database = refseq_select; [refseq_select or refseq_protein] Online blastp database to perform blastp searching for homologues. (can be overriden by <code>-bdb</code> cmd parameter). blastp_evalue_cutoff = 1e-5; [float] blastp e-value cutoff during the searching for homologs against the RefSeq database. blastp_hit_list_size = 200; [int] max number of blastp hits to take in the analysis. blastp_max_number_of_alignments = 1000; [int] max number of alignments during the searching (there could be several alignments for 1 hit, see blastp documentation) blastp_pident_to_query_length_cutoff = 0.5; [float: 0-1] cutoff for hit's identity to your query protein. </p> <p>;[ORF annotation] alternative_start_codons = False; [bool] use or not set of alternative start codons. main_start_codon = ATG;  [str] min_orf_length = 9; [int] cutoff for ORFs length during annotation filter_by_sd = True; [bool] filter annotated ORFs by Shine-Dalgarno sequence prersence. Filtering based on calculation of binding energy between aSD sequence (UCCUCC) and putative SD sequence in an upstream to uAUG window. Energy calculation performed as described here: Yang et.al, 2016 sd_energy_cutoff = -3; [float] cutoff for aSD-SD binding energy. sd_window_length = 20; [int] length of a region for SD sequence search. check_assembly_annotation = False; [bool] retrieve or not the NCBI sequences annotation to be sure that annotated uORFs are not overlapped with known CDSs (can be overriden by <code>-annot</code> cmd parameter).</p> <p>;[conserved ORFs searching] fast_searching = auto; [bool(true or false) or 'auto'] use or not fast searching mode with less accuracy (needed for &gt;~200 sequences or &gt;~2000 ORFs). Can be also set as auto [default]. (can be overriden by <code>-fast</code> cmd parameter). fast_searching_fraction_of_initial_genomes = 0.3; [bool] fraction of input sequences that will be used as initial step in algorithm searching. Applied only if the fast_searching parameter is True. orf_length_group_range = 0.25; [float or int] orf's lengths window within conserved uORFs set can be annotated. If it's a float value [0-1] then the radius of window is a set percentage of the claster's length, while if it's int then the window radius is fixed. orfs_presence_cutoff = 0.5; [float] a set of ORFs will be returned only if they were found in a fraction of input sequences larger than this cutoff. paths_identity_cutoff = 0.5; [float] if two sets of found ORFs are ovelapped more than this cutoff, then only a set with a higher. score will be returned. (Helps to remove duplicates). max_num_of_initial_genome_iteration = 100; [int] similar to the fast_searching_fraction_of_initial_genomes parametr, but used with a normal mode for optimisation. </p> <p>;[Pairwise alignment] alignment_type = aa; [nt or aa] alignment type of uORFs during conservation analysis.  ; Below listed global alignments parametersduring conservation analysis. uorf4u uses Bio.Align. package to perfome pairwise alignment of uORFs. global_match_score = 1; [float] global_mismatch_score = -1; [float] global_open_gap_score = -1; [float] global_extend_gap_score = -1; [float] global_target_end_gap_score = -1; [float] global_query_end_gap_score = -1; [float] alignment_score_cutoff = 0; [float] if a pairwise alignment score is larger than this cutoff then two uORFs are considered as aligned. </p> <p>;[Multiple Sequence Alignment] consensus_threshold = 0.7;  [float] treshold for MSA position to consider a nucleotide/amino acid as conserved in consensus sequence building. </p> <p>;[Paths]  ;Pathes to scripts and files used by the tool. {internal} means a folder uorf4u/uorf4u_data in the tool location. ref_energies = {config_path}/energyRef-CCTCCT.json; aSD-SD energy table downloaded from: Yang et.al, 2016 maft_binary = {config_path}/bin/mafft-mac/mafft.bat palette = {config_path}/palette.txt colors_nt = {config_path}/colors_nt.txt colors_aa = {config_path}/colors_aa.txt </p> <p>;[Output] sequences_to_write = nt, aa, sd; [list] type of sequences results for that (logos, MSAs, fasta files) will writetn. nt - nucleotide seqs of uORFs, aa - amino acid seqs, sd - SD seqs (sd is not available for 'eukaryotes' mode) logo_type = both; [probability, information or both] type of logo, see logomaker package documentation. output_dir = uorf4u_{current_date}; [str] default name of the output dir. default: uorf4u_{current_date}; e.g. uorf4u_2022_07_25-20_41. (can be overriden by <code>-o</code> cmd parameter). </p> <p>;------------------------ ;Annotation visualisation ;------------------------ ;[General figure parameters] margin = 0.1 gap = 0.03 label_gap = 0.07 orf_height = 0.15 annotation_width = auto mm_per_nt = 0.04 font_regular = {config_path}/fonts/Lato-Regular.ttf font_bold = {config_path}/fonts/Lato-Bold.ttf font_mono = {config_path}/fonts/RobotoMono-Regular.ttf  </p> <p>;[Sequence labels] label_color = #3D3D3D label_color_alpha = 1 label_height_to_orf_height = 0.65  </p> <p>;[Axis tics] axis_tics_font_size = auto axis_tics_line_width = 0.3  </p> <p>;[Loci annotations] upstream_seq_line_color = #CECECE upstream_seq_line_color_alpha = 1 upstream_seq_line_width = 0.5 cds_seq_stroke_color = #489143 cds_seq_stroke_color_alpha = 0.8 cds_seq_fill_color = #9ee19b cds_seq_fill_color_alpha = 0.03 orf_line_width = 0.5 conserved_uorfs_stroke_color = #4e4e4e conserved_uorfs_stroke_color_alpha = 1 conserved_uorfs_fill_color = #ee8fb1 conserved_uorfs_fill_color_alpha = 0.6 other_uorfs_stroke_color = #CECECE other_uorfs_stroke_color_alpha = 1 annotated_orf_stroke_color = #3d6f8e annotated_orf_stroke_color_alpha = 1  </p> <p>;------------------------ ;MSA plot ;------------------------ tile_size = 0.1 tile_stroke = 0.05 char_size = 0.7 label_size = 0.6 tile_alpha = 0.8 logo_alpha = 0.8  </p>"},{"location":"VersionLog/versions/","title":"Version log","text":"<ul> <li>Ver 0.9.5 - 4 May 2023<ul> <li>Local blastp searching function now also returns the query accession number.</li> </ul> </li> <li>Ver 0.9.4 - 19 April 2023<ul> <li>A minor bug with <code>-al</code> parameter is fixed.</li> </ul> </li> <li>Ver 0.9.3 - 18 April 2023<ul> <li>New cmd parameter <code>-pdb</code> for choosing an online blastp database.</li> <li>New cmd parameter <code>-lpdb</code> for using local blastp database.</li> </ul> </li> <li>Ver 0.9.2 - 19 February 2023<ul> <li>Blastp searching is now available for protein sequences. </li> </ul> </li> <li>Ver 0.9.1 - 19 February 2023<ul> <li>A major bug of 0.9.0 version in conservation analysis was fixed.</li> </ul> </li> <li>Ver 0.9.0 - 17 February 2023<ul> <li>Conservation analysis algorithm was updated.</li> <li>-c parameter is now always required.</li> <li>Logs messages were updated.</li> </ul> </li> <li>Ver 0.8.7 - 20 January 2023<ul> <li>Logs messages were updated.</li> </ul> </li> <li>Ver 0.8.6 - 18 January 2023<ul> <li>Sequences in MSA plot now are ordered according to their similarity. (--reorder MAFFT parameter)</li> </ul> </li> <li>Ver 0.8.5 - 17 January 2023<ul> <li>Update for web version</li> </ul> </li> <li>Ver 0.8.4 - 30 November 2022<ul> <li>Report files were updated.</li> </ul> </li> <li>Ver 0.8.3 - 30 November 2022<ul> <li>Minor bugs were fixed.</li> <li>Warning messages were updated.</li> <li>NCBI database parsing was optimised.</li> </ul> </li> <li>Ver 0.8.2 - 7 November 2022<ul> <li>xml files and assemblies annotation bugs were fixed.</li> <li>Annotation parsing was optimised.</li> </ul> </li> <li>Ver 0.8.1 - 4 November 2022<ul> <li>Large assemblies annotation bug was fixed.</li> </ul> </li> <li>Ver 0.8.0 - 2 November 2022<ul> <li>New exceptions control.</li> <li>New cmd parameter (-pc).</li> </ul> </li> <li>Ver 0.7.0 - 1 November 2022<ul> <li>NCBI database parsing was optimised and became ~10 times faster.</li> </ul> </li> <li>Ver 0.6.4 - 31 October 2022<ul> <li>MAFFT version 7.505 was replaced with v. 7.490 since it's more stable. </li> </ul> </li> <li>Ver 0.6.3 - 29 October 2022<ul> <li>Entrez.email for the NCBI requests was set. </li> </ul> </li> <li>Ver 0.6.2 - 26 October 2022  <ul> <li>A problem with xml file writing was fixed.</li> </ul> </li> <li>Ver 0.6.1 - 25 October 2022<ul> <li>! After the NCBI API update all previous version have a bug with identical protein database parsing. The bug was fixed in this version. </li> </ul> </li> <li>Ver 0.6.0 - 23 October 2022<ul> <li>New implementation of MSA visualisation</li> </ul> </li> <li>Ver 0.5.4 - 13 October 2022<ul> <li>Annotation visualisation' bug was fixed </li> </ul> </li> <li>Ver 0.5.3 - 12 October 2022<ul> <li>Minor bugs with pathes were fixed  </li> </ul> </li> <li>Ver 0.5.2 - 7 October 2022<ul> <li>MSA tool's path bug was fixed.</li> <li>Fast searching now is set as 'auto'.</li> </ul> </li> <li>Ver 0.5.1 - 6 October 2022<ul> <li>Now compatible with python3.7 (previous versions were compatible only with python3.8+).</li> </ul> </li> <li>Ver 0.5.0 - 4 October 2022<ul> <li>'Eukaryotes' and 'Prokaryotes' mode were introduced.</li> <li>MSA now perfomed with MAFT.</li> <li>New cmd and configs parameters were added.</li> <li>Minor bugs were fixed.</li> </ul> </li> <li>Ver 0.4.0 - 30 August 2022<ul> <li>Visualisation of loci annotation was added.</li> <li>Minor bugs were fixed.</li> </ul> </li> <li>Ver 0.3.1 - 17 August 2022<ul> <li>New cmd and configs parameters were added.</li> <li>Annotation of uORFs overlapped with the main CDSs was added.</li> </ul> </li> <li>Ver 0.3.0 - 7 August 2022<ul> <li>Algorithm of conserved ORFs searching was updated.</li> <li>New configs parameteres were added.</li> </ul> </li> <li>Ver 0.2.1 - 5 August 2022<ul> <li>Annotation parsing bug was fixed.</li> </ul> </li> <li>Ver 0.2.0 - 5 August 2022  <ul> <li>New cmd and configs parameters were added.</li> <li>New classes and methods were developed.</li> </ul> </li> <li>Ver 0.1.5 - 31 July 2022<ul> <li>MSA visualisation functions updated.</li> <li>Bugs were fixed. </li> <li>New cmd and configs parameters were added.</li> </ul> </li> <li>Ver 0.1 - 27 July 2022 - Initial release. </li> </ul>"}]}