{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["trimmer","stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#description","title":"Description","text":"<p>LoVis4u is a bioinformatics tool for Locus Visualisation.</p> <p>Supported input: Genbank, gff3 with sequence   Supported output: Static vector graphics (pdf)  Programming language: Python3  OS: MacOS, Linux Python dependencies: biopython, bcbio-gff, scipy, configs, argparse, pandas, distinctipy, matplotlib, seaborn, reportlab Python version: &gt;= 3.9 OS-level dependencies: MMseqs2 (included in the package) License: WTFPL Version: 0.0.9 (September 2024)</p> <p>Pipeline</p> <p> </p> <p>Visualisation example</p> <p> </p> <p>See the gallery page for more examples</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li>LoVis4u can be installed directly from pypi:</li> </ul> <pre><code>python3 -m pip install lovis4u\n</code></pre> <ul> <li>The development version is available at github :</li> </ul> <pre><code>git clone https://github.com/art-egorov/lovis4u.git\ncd lovis4u\npython3 -m pip install --upgrade pip\npython3 -m pip install setuptools wheel\npython3 setup.py sdist\npython3 -m pip install .\n</code></pre> <p>! If you're a linux user, run <code>lovis4u --linux</code> post-install command once to update paths in the premade config files that set by default for MacOS users.</p>"},{"location":"#reference","title":"Reference","text":"<p>If you find LoVis4u useful, please cite: Artyom. A. Egorov, Gemma C. Atkinson, LoVis4u: Locus Visualisation tool for comparative genomics, bioRxiv 2024.09.11.612399; doi: 10.1101/2024.09.11.612399</p>"},{"location":"#contact","title":"Contact","text":"<p>Please contact us by e-mail artemdotegorovATmeddotludotse or use Issues to report any technical problems. You can also use Discussions section for sharing your ideas or feature requests! </p>"},{"location":"#authors","title":"Authors","text":"<p>LoVis4u is developed by Artyom Egorov at the Atkinson Lab, Department of Experimental Medical Science, Lund University, Sweden. We are open for suggestions to extend and improve LoVis4u functionality. Please don't hesitate to share your ideas or feature requests.</p>"},{"location":"pypi/","title":"Pypi","text":""},{"location":"pypi/#description","title":"Description","text":"<p>LoVis4u is a bioinformatics tool for Locus Visualisation.</p> <p>Supported input: Genbank, gff3 with sequence   Supported output: Static vector graphics (pdf)  Programming language: Python3  OS: MacOS, Linux Python dependencies: biopython, bcbio-gff, scipy, configs, argparse, pandas, distinctipy, matplotlib, seaborn, reportlab Python version: &gt;= 3.8 OS-level dependencies: MMseqs2 (included in the package) License: WTFPL Version: 0.0.9 (September 2024)</p> <p>Detailed documentation with user guide is available at LoVis4u Homepage</p>"},{"location":"pypi/#reference","title":"Reference","text":"<p>If you find LoVis4u useful, please cite: Artyom. A. Egorov, Gemma C. Atkinson, LoVis4u: Locus Visualisation tool for comparative genomics, bioRxiv 2024.09.11.612399; doi: 10.1101/2024.09.11.612399</p>"},{"location":"pypi/#contact","title":"Contact","text":"<p>Please contact us by e-mail artemdotegorovATmeddotludotse or use Issues to report any technical problems. You can also use Discussions section for sharing your ideas or feature requests! </p>"},{"location":"pypi/#authors","title":"Authors","text":"<p>LoVis4u is developed by Artyom Egorov at the Atkinson Lab, Department of Experimental Medical Science, Lund University, Sweden. We are open for suggestions to extend and improve LoVis4u functionality. Please don't hesitate to share your ideas or feature requests.</p>"},{"location":"API/package/","title":"Library","text":"<p>This module provides managing classes and methods for the tool.</p> <p>This module provides visualisation of loci annotation.</p> <p>This module provides managing classes and methods for the tool.</p> <p>This module provides some methods (e.g. colors tranformation, data copying) used by the tool.</p>"},{"location":"API/package/#lovis4u.DataProcessing.Feature","title":"<code>Feature</code>","text":"<p>A Feature object represents a locus' feature (currently only CDS) and its properties.</p> <p>Attributes:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>feature_type</code>             (<code>str</code>)         \u2013          <p>Type of element (e.g. CDS or tRNA). Currently only CDS are supported.</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>1-based start genomic coordinate.</p> </li> <li> <code>end</code>             (<code>int</code>)         \u2013          <p>1-based end genomic coordinates</p> </li> <li> <code>strand</code>             (<code>int</code>)         \u2013          <p>Genomic strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the feature which will be used as a label.</p> </li> <li> <code>sequence</code>             (<code>Seq</code>)         \u2013          <p>Feature's sequence.</p> </li> <li> <code>record</code>             (<code>SeqRecord</code>)         \u2013          <p>SeqRecord object of corresponding feature sequence.</p> </li> <li> <code>group</code>             (<code>str</code>)         \u2013          <p>Feature group that defines feature's colour and meant to represent a set of homologous features. Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.</p> </li> <li> <code>group_type</code>             (<code>str</code>)         \u2013          <p>Type of feature group that allow to visualise different set of feature groups differently (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature category which initially is built to handle phrogs category annotation. In visualisation it defines the \"category\" colour annotation under features. Supposed to represent clusters on locus or any second layer of feature properties.</p> </li> <li> <code>vis_prms</code>             (<code>dict</code>)         \u2013          <p>Visualisation parameters that holds colours, label and other info for Drawing methods.</p> </li> <li> <code>overlapping</code>             (<code>bool</code>)         \u2013          <p>Whether feature overlaps with visualised region or not.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Feature:\n    \"\"\"A Feature object represents a locus' feature (currently only CDS) and its properties.\n\n    Attributes:\n        feature_id (str): Feature identifier.\n        feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n        start (int): 1-based start genomic coordinate.\n        end (int): 1-based end genomic coordinates\n        strand (int): Genomic strand (1: plus strand, -1: minus strand).\n        name (str): Name of the feature which will be used as a label.\n        sequence (Bio.Seq.Seq): Feature's sequence.\n        record (Bio.SeqRecord.SeqRecord): SeqRecord object of corresponding feature sequence.\n        group (str): Feature group that defines feature's colour and meant to represent a set of homologous features.\n            Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n        group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n            (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n        category (str): Feature category which initially is built to handle phrogs category annotation.\n            In visualisation it defines the \"category\" colour annotation under features.\n            Supposed to represent clusters on locus or any second layer of feature properties.\n        vis_prms (dict): Visualisation parameters that holds colours, label and other info for Drawing methods.\n        overlapping (bool): Whether feature overlaps with visualised region or not.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, feature_id: str, feature_type: str, start: int, end: int, strand: int, name: str,\n                 sequence: Bio.Seq.Seq, group: str, group_type: str, category: str, vis_prms: dict, overlapping: bool,\n                 parameters: lovis4u.Manager.Parameters):\n        \"\"\"Create a Feature object.\n\n        Arguments:\n            feature_id (str): Feature identifier.\n            feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n            start (int): 1-based start genomic coordinate.\n            end (int): 1-based end genomic coordinates\n            strand (int): Genomic strand (1: plus strand, -1: minus strand).\n            name (str): Name of the feature which will be used as a label.\n            sequence (Bio.Seq.Seq): Feature's sequence.\n            group (str): Feature group that defines feature's colour and meant to represent a set of homologous features.\n                Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n            group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n                (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n            category (str): Feature category which initially is built to handle phrogs category annotation.\n                In visualisation it defines the \"category\" colour annotation under features.\n                Supposed to represent clusters on locus or any second layer of feature properties.\n            vis_prms (dict): Visualisation parameters that holds colours, label and other info for Drawing methods.\n            prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.feature_type = feature_type\n        self.feature_id = feature_id\n        self.start = start\n        self.end = end\n        self.strand = strand\n        self.name = name\n        self.sequence = sequence\n        self.record = Bio.SeqRecord.SeqRecord(seq=self.sequence, id=self.feature_id)\n        self.group = group  # maybe rename later\n        self.group_type = group_type\n        self.category = category\n        self.vis_prms = vis_prms\n        self.vis_prms[\"label\"] = str(name)\n        self.overlapping = overlapping\n        self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Feature.__init__","title":"<code>__init__(feature_id, feature_type, start, end, strand, name, sequence, group, group_type, category, vis_prms, overlapping, parameters)</code>","text":"<p>Create a Feature object.</p> <p>Parameters:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>feature_type</code>             (<code>str</code>)         \u2013          <p>Type of element (e.g. CDS or tRNA). Currently only CDS are supported.</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>1-based start genomic coordinate.</p> </li> <li> <code>end</code>             (<code>int</code>)         \u2013          <p>1-based end genomic coordinates</p> </li> <li> <code>strand</code>             (<code>int</code>)         \u2013          <p>Genomic strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the feature which will be used as a label.</p> </li> <li> <code>sequence</code>             (<code>Seq</code>)         \u2013          <p>Feature's sequence.</p> </li> <li> <code>group</code>             (<code>str</code>)         \u2013          <p>Feature group that defines feature's colour and meant to represent a set of homologous features. Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.</p> </li> <li> <code>group_type</code>             (<code>str</code>)         \u2013          <p>Type of feature group that allow to visualise different set of feature groups differently (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature category which initially is built to handle phrogs category annotation. In visualisation it defines the \"category\" colour annotation under features. Supposed to represent clusters on locus or any second layer of feature properties.</p> </li> <li> <code>vis_prms</code>             (<code>dict</code>)         \u2013          <p>Visualisation parameters that holds colours, label and other info for Drawing methods.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, feature_id: str, feature_type: str, start: int, end: int, strand: int, name: str,\n             sequence: Bio.Seq.Seq, group: str, group_type: str, category: str, vis_prms: dict, overlapping: bool,\n             parameters: lovis4u.Manager.Parameters):\n    \"\"\"Create a Feature object.\n\n    Arguments:\n        feature_id (str): Feature identifier.\n        feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n        start (int): 1-based start genomic coordinate.\n        end (int): 1-based end genomic coordinates\n        strand (int): Genomic strand (1: plus strand, -1: minus strand).\n        name (str): Name of the feature which will be used as a label.\n        sequence (Bio.Seq.Seq): Feature's sequence.\n        group (str): Feature group that defines feature's colour and meant to represent a set of homologous features.\n            Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n        group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n            (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n        category (str): Feature category which initially is built to handle phrogs category annotation.\n            In visualisation it defines the \"category\" colour annotation under features.\n            Supposed to represent clusters on locus or any second layer of feature properties.\n        vis_prms (dict): Visualisation parameters that holds colours, label and other info for Drawing methods.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.feature_type = feature_type\n    self.feature_id = feature_id\n    self.start = start\n    self.end = end\n    self.strand = strand\n    self.name = name\n    self.sequence = sequence\n    self.record = Bio.SeqRecord.SeqRecord(seq=self.sequence, id=self.feature_id)\n    self.group = group  # maybe rename later\n    self.group_type = group_type\n    self.category = category\n    self.vis_prms = vis_prms\n    self.vis_prms[\"label\"] = str(name)\n    self.overlapping = overlapping\n    self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci","title":"<code>Loci</code>","text":"<p>A Loci object holds information about all loci to be plotted and methods for data preparation.</p> <p>Attributes:</p> <ul> <li> <code>loci</code>             (<code>list</code>)         \u2013          <p>List of Locus objects.</p> </li> <li> <code>locus_annotation</code>             (<code>DataFrame</code>)         \u2013          <p>Table with information about each locus that defines visualisation (e.g. coordinates for visualisation, description, etc).</p> </li> <li> <code>feature_annotation</code>             (<code>DataFrame</code>)         \u2013          <p>Table with information about each feature that defines visualisation (e.g. group, name, category, etc).</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Loci:\n    \"\"\"A Loci object holds information about all loci to be plotted and methods for data preparation.\n\n    Attributes:\n        loci (list): List of Locus objects.\n        locus_annotation (pd.DataFrame): Table with information about each locus that defines visualisation\n            (e.g. coordinates for visualisation, description, etc).\n        feature_annotation (pd.DataFrame): Table with information about each feature that defines visualisation\n            (e.g. group, name, category, etc).\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, parameters=lovis4u.Manager.Parameters):\n        \"\"\"Create a Loci object.\n\n        Arguments:\n            parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n        \"\"\"\n        self.loci = []\n        self.locus_annotation = pd.DataFrame(columns=[\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\",\n                                                      \"order\", \"group\"]).set_index(\"sequence_id\")\n        self.feature_annotation = pd.DataFrame(columns=[\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\",\n                                                        \"group\", \"group_type\", \"category\", \"fill_colour\",\n                                                        \"stroke_colour\",\n                                                        \"show_label\"]).set_index(\"feature_id\")\n        self.prms = parameters\n\n    def __load_annotation_file(self, file_path: str, annotation_columns: list, index_column: str) -&gt; pd.DataFrame:\n        \"\"\"Private method to load an annotation file.\n\n        Arguments:\n            file_path (str): File path for an annotation file to be loaded.\n            annotation_columns (list): List of columns that should be considered.\n            index_column (str): Column name to be considered as index.\n\n        Returns:\n              pd.DataFrame: Preprocessed annotation file.\n        \"\"\"\n        annotation_table = pd.read_table(file_path)\n        found_allowed_columns = [i for i in annotation_columns if i in annotation_table.columns]\n        not_found_allowed_columns = [i for i in annotation_columns if i not in annotation_table.columns]\n        annotation_table = annotation_table[found_allowed_columns].set_index(index_column)\n        annotation_table[not_found_allowed_columns] = None\n        return annotation_table\n\n    def load_locus_annotation_file(self, file_path: str) -&gt; None:\n        \"\"\"Load loci annotation file.\n\n        Arguments:\n            file_path (str): File path for a loci annotation file to be loaded.\n\n        Returns:\n            None\n\n        \"\"\"\n        annotation_columns = [\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\", \"order\", \"group\"]\n        self.locus_annotation = self.__load_annotation_file(file_path, annotation_columns, \"sequence_id\")\n        return None\n\n    def load_feature_annotation_file(self, file_path: str) -&gt; None:\n        \"\"\"Load features annotation file.\n\n        Arguments:\n            file_path (str): File path for a features annotation file to be loaded.\n\n        Returns:\n            None\n\n        \"\"\"\n        annotation_columns = [\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\", \"group\", \"group_type\",\n                              \"category\", \"fill_colour\", \"stroke_colour\", \"show_label\"]\n        self.feature_annotation = self.__load_annotation_file(file_path, annotation_columns, \"feature_id\")\n        return None\n\n    def __update_locus_annotation(self, record_id: str, record_description: str, record_length: int) -&gt; None:\n        \"\"\"Private method for updating loci annotation.\n\n        Arguments:\n            record_id (str): Sequence identifier.\n            record_description (str): Sequence description.\n            record_length (int): Sequence length.\n\n        Returns:\n            None\n\n        \"\"\"\n        if record_id not in self.locus_annotation.index:\n            self.locus_annotation.loc[record_id] = {col: None for col in self.locus_annotation.columns}\n\n        default_values = dict(length=record_length, coordinates=f\"1:{record_length}:1\",\n                              description=record_description, circular=1, order=len(self.loci), group=1)\n        self.locus_annotation.loc[record_id] = self.locus_annotation.loc[record_id].fillna(default_values)\n        return None\n\n    def __update_feature_annotation(self, feature_id: str, locus_id: str, coordinates: str, feature_type: str,\n                                    category: str, name: str) -&gt; None:\n        \"\"\"Private method for updating feature annotation.\n\n        Arguments:\n            feature_id (str): Feature identifier.\n            locus_id (str): Sequence description.\n            coordinates (str): Feature coordinates.\n            category (str): Feature type.\n            name (str): Feature name.\n\n\n        Returns:\n            None\n\n        \"\"\"\n        if feature_id not in self.feature_annotation.index:\n            self.feature_annotation.loc[feature_id] = {col: None for col in self.feature_annotation.columns}\n\n        if self.feature_annotation.loc[feature_id][\"group_type\"] in self.prms.args[\"feature_group_types_to_show_label\"] \\\n                or \"all\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n            show_label = 1\n        else:\n            show_label = 0\n        stroke_colour = \"default\"\n        if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                self.feature_annotation.loc[feature_id][\"fill_colour\"] and \\\n                self.feature_annotation.loc[feature_id][\"fill_colour\"] != \"default\":\n            stroke_colour = lovis4u.Methods.scale_lightness(self.feature_annotation.loc[feature_id][\"fill_colour\"],\n                                                            self.prms.args[\"feature_stroke_colour_relative_lightness\"])\n        default_values = dict(locus_id=locus_id, coordinates=coordinates, feature_type=feature_type,\n                              name=name, group=\"\", group_type=\"\", category=category, fill_colour=\"default\",\n                              stroke_colour=stroke_colour,\n                              show_label=show_label)\n        self.feature_annotation.loc[feature_id] = self.feature_annotation.loc[feature_id].fillna(default_values)\n        return None\n\n    def load_loci_from_extended_gff(self, input_f: str, ilund4u_mode: bool = False) -&gt; None:\n        \"\"\"Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide\n            sequence. Such files are produced for example by pharokka annotation tool.\n\n        All files with extension other than .gff (not case-sensitive) will be ignored.\n\n        Arguments:\n            input_folder: folder name with gff files.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        try:\n            if isinstance(input_f, str):\n                input_folder = input_f\n                if not os.path.exists(input_folder):\n                    raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n                gff_files = [os.path.join(input_folder, f) for f in os.listdir(input_folder)]\n            elif isinstance(input_f, list):\n                gff_files = input_f\n            else:\n                raise lovis4u.Manager.lovis4uError(f\"The input for the GFF parsing function must be either a folder or \"\n                                                   f\"a list of files.\")\n            if not gff_files:\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_f} does not contain files.\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u25cb Reading gff file{'s' if len(gff_files) &gt; 1 else ''}...\", file=sys.stdout)\n            for gff_file_path in gff_files:\n                try:\n                    gff_file = gff_file_path\n                    gff_records = list(BCBio.GFF.parse(gff_file_path, limit_info=dict(gff_type=[\"CDS\"])))\n                    if len(gff_records) != 1:\n                        print(f\"\u25cb Warning: gff file {gff_file} contains information for more than 1 \"\n                              f\"sequence. File will be skipped.\")\n                        continue\n                    gff_record = gff_records[0]\n                    try:\n                        record_locus_sequence = gff_record.seq\n                    except Bio.Seq.UndefinedSequenceError:\n                        print(f\"\u25cb Warning: gff file {gff_file} doesn't contain corresponding sequences.\")\n                        continue\n                    if self.prms.args[\"gff_description_source\"] in gff_record.annotations:\n                        record_description = gff_record.annotations[self.prms.args[\"gff_description_source\"]][0]\n                        if isinstance(record_description, tuple):\n                            record_description = \" \".join(record_description)\n                    else:\n                        record_description = \"\"\n                    if self.prms.args[\"use_filename_as_contig_id\"]:\n                        gff_record.id = os.path.splitext(os.path.basename(gff_file))[0]\n                    self.__update_locus_annotation(gff_record.id, record_description, len(record_locus_sequence))\n                    locus_annotation_row = self.locus_annotation.loc[gff_record.id]\n                    coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                                   locus_annotation_row[\"coordinates\"].split(\",\")]\n                    record_locus = Locus(seq_id=gff_record.id, coordinates=coordinates,\n                                         description=locus_annotation_row[\"description\"],\n                                         circular=locus_annotation_row[\"circular\"],\n                                         length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                         order=locus_annotation_row[\"order\"])\n                    features_ids = [i.id for i in gff_record.features]\n                    if len(features_ids) != len(set(features_ids)):\n                        raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} contains duplicated feature ids while\"\n                                                           f\" only unique are allowed.\")\n                    for gff_feature in gff_record.features:\n                        feature_id = gff_feature.id\n                        if ilund4u_mode:\n                            if gff_record.id not in feature_id:\n                                feature_id = f\"{gff_record.id}-{feature_id}\"\n                        transl_table = self.prms.args[\"default_transl_table\"]\n                        if \"transl_table\" in gff_feature.qualifiers.keys():\n                            transl_table = int(gff_feature.qualifiers[\"transl_table\"][0])\n                        name = \"\"\n                        if self.prms.args[\"gff_CDS_name_source\"] in gff_feature.qualifiers:\n                            name = gff_feature.qualifiers[self.prms.args[\"gff_CDS_name_source\"]][0]\n                        category = \"\"\n                        if self.prms.args[\"gff_CDS_category_source\"] in gff_feature.qualifiers:\n                            category = \",\".join(gff_feature.qualifiers[self.prms.args[\"gff_CDS_category_source\"]])\n                        for coordinate in record_locus.coordinates:\n                            overlapping = False\n                            start, end = coordinate[\"start\"], coordinate[\"end\"]\n                            if start &lt;= gff_feature.location.start + 1 &lt;= end or start &lt;= gff_feature.location.end &lt;= end:\n                                overlapping = True\n                                break\n                        if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                            continue\n                        self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                         f\"{int(gff_feature.location.start) + 1}:\"\n                                                         f\"{int(gff_feature.location.end)}:{gff_feature.location.strand}\",\n                                                         \"CDS\", category, name)\n                        feature_annotation_row = self.feature_annotation.loc[feature_id]\n                        feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                          feature_id=feature_id, start=int(gff_feature.location.start) + 1,\n                                          end=int(gff_feature.location.end), strand=gff_feature.location.strand,\n                                          name=feature_annotation_row[\"name\"],\n                                          sequence=gff_feature.translate(record_locus_sequence, table=transl_table,\n                                                                         cds=False)[:-1],\n                                          group=feature_annotation_row[\"group\"],\n                                          group_type=feature_annotation_row[\"group_type\"],\n                                          category=feature_annotation_row[\"category\"],\n                                          vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                        stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                        show_label=feature_annotation_row[\"show_label\"]),\n                                          overlapping=overlapping, parameters=self.prms)\n                        record_locus.features.append(feature)\n                    self.loci.append(record_locus)\n                except:\n                    print(f\"\u25cb Warning: gff file {gff_file} was not read properly and skipped\")\n                    if self.prms.args[\"parsing_debug\"]:\n                        self.prms.args[\"debug\"] = True\n                        raise lovis4u.Manager.lovis4uError()\n            seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n            loci_ids = [l.seq_id for l in self.loci]\n            if len(loci_ids) != len(set(loci_ids)):\n                raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                                   f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                                   f\"as contig id which can help to fix the problem.\")\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                      f\"files folder\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gff folder.\") from error\n\n    def load_loci_from_gb(self, input_folder: str) -&gt; None:\n        \"\"\"Load loci from the folder with genbank files.\n\n        All files with extension other than .gb (not case-sensitive) will be ignored.\n\n        Arguments:\n            input_folder: folder name with gb files.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not os.path.exists(input_folder):\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n        try:\n            gb_files = [f for f in os.listdir(input_folder)]\n            if not gb_files:\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain files.\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u25cb Reading gb file{'s' if len(gb_files) &gt; 1 else ''}...\", file=sys.stdout)\n            for gb_file in gb_files:\n                try:\n                    gb_file_path = os.path.join(input_folder, gb_file)\n                    gb_records = list(Bio.SeqIO.parse(gb_file_path, \"genbank\"))\n                    if len(gb_records) != 1:\n                        print(f\"\u25cb Warning: gb file {gb_file} contains information for more than 1 \"\n                              f\"sequence. File will be skipped.\")\n                        continue\n                    gb_record = gb_records[0]\n                    record_locus_sequence = gb_record.seq\n                    if self.prms.args[\"genbank_description_source\"] == \"description\":\n                        record_description = gb_record.description\n                    elif \"annotations:\" in self.prms.args[\"genbank_description_source\"]:\n                        feature_description_key = self.prms.args[\"genbank_description_source\"].split(\":\")[1]\n                        record_description = gb_record.annotations[feature_description_key]\n                    else:\n                        record_description = \"\"\n                    if self.prms.args[\"use_filename_as_contig_id\"]:\n                        gb_record.id = os.path.splitext(os.path.basename(gb_file))[0]\n                    self.__update_locus_annotation(gb_record.id, record_description, len(record_locus_sequence))\n                    locus_annotation_row = self.locus_annotation.loc[gb_record.id]\n                    coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                                   locus_annotation_row[\"coordinates\"].split(\",\")]\n                    record_locus = Locus(seq_id=gb_record.id, coordinates=coordinates,\n                                         description=locus_annotation_row[\"description\"],\n                                         circular=locus_annotation_row[\"circular\"],\n                                         length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                         order=locus_annotation_row[\"order\"])\n\n                    gb_CDSs = [i for i in gb_record.features if i.type == \"CDS\"]\n                    first_CDS_record = gb_CDSs[0]\n                    id_source = self.prms.args[\"genbank_id_source\"]\n                    if self.prms.args[\"genbank_id_source\"] not in first_CDS_record.qualifiers:\n                        for alternative_id_source in self.prms.args[\"genbank_id_alternative_source\"]:\n                            if alternative_id_source in first_CDS_record.qualifiers:\n                                id_source = alternative_id_source\n                                if self.prms.args[\"verbose\"]:\n                                    print(f\"\u25cb Warning: there is no &lt;{self.prms.args['genbank_id_source']}&gt; attribute \"\n                                          f\"for CDS records in {gb_file}. Alternative &lt;{id_source}&gt; was used instead.\",\n                                          file=sys.stdout)\n                                break\n                        if id_source == self.prms.args[\"genbank_id_source\"]:\n                            print(f\"There is no &lt;{self.prms.args['genbank_id_source']}&gt; \"\n                                  f\"attribute for CDS record found in {gb_file}. We tried to\"\n                                  f\" find any from the alternative list: \"\n                                  f\"{','.join(self.prms.args['genbank_id_alternative_source'])}\"\n                                  f\", but they also weren't found.\")  # add about cmd parameter\n                    features_ids = [i.qualifiers[id_source][0] for i in gb_CDSs]\n                    if len(features_ids) != len(set(features_ids)):\n                        print(f\"GB file {gb_record} contains duplicated feature ids while\"\n                                                           f\" only unique are allowed.\")\n\n                    for gb_feature in gb_CDSs:\n                        feature_id = gb_feature.qualifiers[id_source][0].replace(\"|\", \"_\")\n                        transl_table = self.prms.args[\"default_transl_table\"]\n                        if \"transl_table\" in gb_feature.qualifiers.keys():\n                            transl_table = int(gb_feature.qualifiers[\"transl_table\"][0])\n                        name = \"\"\n                        if self.prms.args[\"genbank_CDS_name_source\"] in gb_feature.qualifiers:\n                            name = gb_feature.qualifiers[self.prms.args[\"genbank_CDS_name_source\"]][0]\n                        category = \"\"\n                        if self.prms.args[\"genbank_CDS_category_source\"] in gb_feature.qualifiers:\n                            category = \",\".join(gb_feature.qualifiers[self.prms.args[\"genbank_CDS_category_source\"]])\n\n                        for coordinate in record_locus.coordinates:\n                            overlapping = False\n                            start, end = coordinate[\"start\"], coordinate[\"end\"]\n                            if start &lt;= gb_feature.location.start + 1 &lt;= end or start &lt;= gb_feature.location.end &lt;= end:\n                                overlapping = True\n                                break\n                        if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                            continue\n                        self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                         f\"{int(gb_feature.location.start) + 1}:\"\n                                                         f\"{int(gb_feature.location.end)}:\"\n                                                         f\"{gb_feature.location.strand}\", \"CDS\", category, name)\n                        feature_annotation_row = self.feature_annotation.loc[feature_id]\n                        feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                          feature_id=feature_id, start=int(gb_feature.location.start) + 1,\n                                          end=int(gb_feature.location.end),\n                                          strand=gb_feature.location.strand,\n                                          name=feature_annotation_row[\"name\"],\n                                          sequence=gb_feature.translate(record_locus_sequence,\n                                                                        table=transl_table,\n                                                                        cds=False)[:-1],\n                                          group=feature_annotation_row[\"group\"],\n                                          group_type=feature_annotation_row[\"group_type\"],\n                                          category=feature_annotation_row[\"category\"],\n                                          vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                        stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                        show_label=feature_annotation_row[\"show_label\"]),\n                                          overlapping = overlapping,\n                                          parameters=self.prms)\n\n                        record_locus.features.append(feature)\n                    self.loci.append(record_locus)\n                except:\n                    print(f\"\u25cb Warning: gb file {gb_file} was not read properly and skipped\")\n                    if self.prms.args[\"parsing_debug\"]:\n                        self.prms.args[\"debug\"] = True\n                        raise lovis4u.Manager.lovis4uError()\n            seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n            loci_ids = [l.seq_id for l in self.loci]\n            if len(loci_ids) != len(set(loci_ids)):\n                raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                                   f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                                   f\"as contig id which can help to fix the problem.\")\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                      f\"files folder\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gb folder.\") from error\n\n    def save_locus_annotation_table(self) -&gt; None:\n        \"\"\"Save loci annotation table to the output folder.\n\n        Output file name is locus_annotation_table.tsv\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"locus_annotation_table.tsv\")\n            self.locus_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"sequence_id\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Loci annotation table was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to save loci annotation table.\") from error\n\n    def save_feature_annotation_table(self) -&gt; None:\n        \"\"\"Save feature annotation table to the output folder.\n\n        Output file name is feature_annotation_table.tsv\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"feature_annotation_table.tsv\")\n            self.feature_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"feature_id\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Feature annotation table was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to save feature annotation table.\") from error\n\n    def mmseqs_cluster(self) -&gt; pd.DataFrame:\n        \"\"\"Cluster all proteins using mmseqs in order to define groups of homologues.\n\n        Returns:\n            pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is\n                defined by representative sequence id within a corresponding cluster.\n\n        \"\"\"\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u25cb Running mmseqs for protein clustering...\", file=sys.stdout)\n        try:\n            feature_records = [feature.record for locus in self.loci for feature in locus.features]\n            temp_input = tempfile.NamedTemporaryFile()\n            Bio.SeqIO.write(feature_records, temp_input.name, \"fasta\")\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            mmseqs_output_folder = os.path.join(self.prms.args[\"output_dir\"], \"mmseqs\")\n            if os.path.exists(mmseqs_output_folder):\n                shutil.rmtree(mmseqs_output_folder)\n            os.mkdir(mmseqs_output_folder)\n            Bio.SeqIO.write(feature_records, os.path.join(mmseqs_output_folder, \"input_proteins.fa\"), \"fasta\")\n            mmseqs_output_folder_db = os.path.join(mmseqs_output_folder, \"DB\")\n            os.mkdir(mmseqs_output_folder_db)\n            mmseqs_stdout = open(os.path.join(mmseqs_output_folder, \"mmseqs_stdout.txt\"), \"w\")\n            mmseqs_stderr = open(os.path.join(mmseqs_output_folder, \"mmseqs_stderr.txt\"), \"w\")\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createdb\", temp_input.name,\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\")], stdout=mmseqs_stdout,\n                           stderr=mmseqs_stderr)\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"cluster\",\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"tmp\"),\n                            \"--cluster-mode\", str(self.prms.args[\"mmseqs_cluster_mode\"]),\n                            \"--cov-mode\", str(self.prms.args[\"mmseqs_cov_mode\"]),\n                            \"--min-seq-id\", str(self.prms.args[\"mmseqs_min_seq_id\"]),\n                            \"-c\", str(self.prms.args[\"mmseqs_c\"]),\n                            \"-s\", str(self.prms.args[\"mmseqs_s\"])], stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createtsv\",\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                            os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\")],\n                           stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n            mmseqs_clustering_results = pd.read_table(os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\"),\n                                                      sep=\"\\t\", header=None, names=[\"cluster\", \"protein_id\"])\n            mmseqs_clustering_results = mmseqs_clustering_results.set_index(\"protein_id\")\n\n            num_of_unique_clusters = len(set(mmseqs_clustering_results[\"cluster\"].to_list()))\n            num_of_proteins = len(mmseqs_clustering_results.index)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {num_of_unique_clusters} clusters for {num_of_proteins} proteins were found with mmseqs\\n\"\n                      f\"    mmseqs clustering results were saved to \"\n                      f\"{os.path.join(mmseqs_output_folder, 'mmseqs_clustering.tsv')}\", file=sys.stdout)\n            return mmseqs_clustering_results\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to run mmseqs clustering.\") from error\n\n    def define_feature_groups(self, dataframe: pd.DataFrame, group_column_name: str = \"cluster\") -&gt; None:\n        \"\"\"Set features attribute \"group\" based on input dataframe.\n\n        By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed\n            feature groups you can set them with feature table.\n\n        Arguments:\n            dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n            group_column_name (str): column name of the dataframe that represent corresponding group to each feature.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n\n            for locus in self.loci:\n                for feature in locus.features:\n                    if feature.group and self.prms.args[\"keep_predefined_groups\"]:\n                        continue\n                    feature.group = dataframe.loc[feature.feature_id, group_column_name]\n                    self.feature_annotation.loc[feature.feature_id, \"group\"] = feature.group\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define protein features groups.\") from error\n\n    def remove_non_overlapping_features(self) -&gt; None:\n        \"\"\"Removes features that are not overlapping with visualisation window.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            ids_of_non_overlapping_objects = []\n            for locus in self.loci:\n                ids_of_non_overlapping_objects += [obj.feature_id for obj in locus.features if not obj.overlapping]\n                filtered_objects = [obj for obj in locus.features if obj.overlapping]\n                locus.features = filtered_objects\n            self.feature_annotation = self.feature_annotation.drop(ids_of_non_overlapping_objects)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to clean non overlapping features.\") from error\n\n    def define_labels_to_be_shown(self):\n        \"\"\"Set feature visaulisation attribute \"show_label\" based on feature groups.\n\n        controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and\n            feature_group_types_to_show_label_on_first_occurrence parameters.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            added_first_occurrence_labels = []\n            for locus in self.loci:\n                for feature in locus.features:\n                    if self.prms.args[\"show_all_feature_labels\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                        continue\n                    if feature.vis_prms[\"label\"] not in self.prms.args[\"feature_labels_to_ignore\"]:\n                        if \"any\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n                            feature.vis_prms[\"show_label\"] = 1\n                        elif feature.group_type in self.prms.args[\"feature_group_types_to_show_label\"]:\n                            feature.vis_prms[\"show_label\"] = 1\n                        elif feature.group_type in \\\n                                self.prms.args[\"feature_group_types_to_show_label_on_first_occurrence\"]:\n                            if feature.group not in added_first_occurrence_labels:\n                                feature.vis_prms[\"show_label\"] = 1\n                                added_first_occurrence_labels.append(feature.group)\n                    else:\n                        feature.vis_prms[\"show_label\"] = 0\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable define feature labels to be shown.\") from error\n\n    def cluster_sequences(self, dataframe: pd.DataFrame, one_cluster: bool) -&gt; None:\n        \"\"\"Define loci order and clusters with proteome similarity based hierarchical clustering.\n            This function changes the order of loci that are plotted and also updates corresponding to each loci group\n            attribute which defines homologues groups of proteomes.\n\n        It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n            groups by other method you can also build pandas dataframe based on that with index corresponding to\n            feature id and column \"cluster\" corresponding to the group.\n\n        Arguments:\n              dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n                one_cluster (bool): consider all sequences to be members of one cluster, but still define the\n                optimal order.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            proteins_loci_dict = collections.defaultdict(collections.deque)\n            loci_clusters_dict = dict()\n            number_of_loci = len(self.loci)\n            if number_of_loci &lt; 2:\n                return None\n            proteome_sizes = pd.Series(np.zeros(number_of_loci, dtype=int))\n            for locus_index in range(number_of_loci):\n                locus = self.loci[locus_index]\n                loci_clusters = [dataframe.loc[feature.feature_id, \"cluster\"] for feature in locus.features]\n                loci_clusters_dict[locus_index] = list(set(loci_clusters))\n                proteome_sizes.iloc[locus_index] = len(set(loci_clusters))\n                for l_cl in loci_clusters:\n                    proteins_loci_dict[l_cl].append(locus_index)\n\n            loci_ids = [locus.seq_id for locus in self.loci]\n            similarity_matrix = pd.DataFrame(0.0, index=loci_ids, columns=loci_ids)\n            for locus_index in range(number_of_loci):\n                counts = pd.Series(np.zeros(number_of_loci, dtype=int))\n                for cluster in loci_clusters_dict[locus_index]:\n                    js = proteins_loci_dict[cluster]\n                    counts.iloc[js] += 1\n                locus_size = proteome_sizes[locus_index]\n                norm_factors = pd.Series(0.5 * (locus_size + proteome_sizes) / (locus_size * proteome_sizes),\n                                         index=counts.index)\n                weights = counts.mul(norm_factors)\n                similarity_matrix.iloc[locus_index] = weights\n            symmetric_distance_matrix = 1 - similarity_matrix\n            np.fill_diagonal(symmetric_distance_matrix.values, 0)\n            linkage_matrix = scipy.cluster.hierarchy.linkage(\n                scipy.spatial.distance.squareform(symmetric_distance_matrix),\n                method=\"average\")\n            dendrogram = scipy.cluster.hierarchy.dendrogram(linkage_matrix, no_plot=True)\n            if not one_cluster:\n                clusters = pd.Series(scipy.cluster.hierarchy.fcluster(linkage_matrix,\n                                                                      self.prms.args[\"clustering_h_value\"],\n                                                                      criterion=\"distance\"),\n                                     index=loci_ids)\n                for locus in self.loci:\n                    locus.group = clusters[locus.seq_id]\n                    self.locus_annotation.loc[locus.seq_id, \"group\"] = locus.group\n            order = dendrogram[\"leaves\"][::-1]\n            self.locus_annotation[\"initial_order\"] = self.locus_annotation[\"order\"]\n            for locus_index in range(number_of_loci):\n                locus = self.loci[locus_index]\n                self.locus_annotation.loc[locus.seq_id, \"order\"] = order.index(locus_index)\n            self.locus_annotation.sort_values(by=\"order\", inplace=True)\n            seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n\n            reordered_similarity_matrix = similarity_matrix.reindex(index=self.locus_annotation.index,\n                                                                    columns=self.locus_annotation.index)\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"proteome_similarity_matrix.tsv\")\n            reordered_similarity_matrix.to_csv(file_path, sep=\"\\t\")\n            num_of_loci_groups = len(set(self.locus_annotation[\"group\"].to_list()))\n            if self.prms.args[\"verbose\"]:\n                if num_of_loci_groups == 1:\n                    print(f\"\u29bf Loci order and {num_of_loci_groups} cluster was defined with proteome similarity based \"\n                          f\"hierarchical clustering\", file=sys.stdout)\n                elif num_of_loci_groups &gt; 1:\n                    print(f\"\u29bf Loci order and {num_of_loci_groups} clusters were defined with proteome similarity based \"\n                          f\"hierarchical clustering\", file=sys.stdout)\n                print(f\"\u29bf Proteome similarity matrix of loci was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to cluster loci sequences.\") from error\n\n    def find_variable_feature_groups(self, mmseqs_results: pd.DataFrame) -&gt; None:\n        \"\"\"Define feature group type attributes (variable or conserved) based on their conservation in corresponding\n            loci group feature.\n\n        It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n            groups by other method you can also build pandas dataframe based on that with index corresponding to\n            feature id and column \"cluster\" corresponding to the group.\n\n        Arguments:\n              mmseqs_results (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_clusters_sizes = self.locus_annotation[\"group\"].value_counts()\n            loci_clusters_cutoff_v = np.round(self.prms.args[\"CDS_is_variable_cutoff\"] * loci_clusters_sizes).astype(\n                int)\n            loci_clusters_cutoff_c = np.round(self.prms.args[\"CDF_is_conserved_cutoff\"] * loci_clusters_sizes).astype(\n                int)\n            loci_clusters_cutoff_v[loci_clusters_cutoff_v == 0] = 1\n            cluster_types = collections.defaultdict(dict)\n            for cluster in set(mmseqs_results[\"cluster\"].to_list()):\n                cluster_proteins = mmseqs_results[mmseqs_results[\"cluster\"] == cluster].index\n                cluster_loci = [locus for locus in self.loci if\n                                any(feature.feature_id in cluster_proteins for feature in locus.features)]\n                cluster_loci_groups = [locus.group for locus in cluster_loci]\n                for cluster_locus_group in cluster_loci_groups:\n                    current_group_cluster_loci = [locus.seq_id for locus in cluster_loci if\n                                                  locus.group == cluster_locus_group]\n                    current_group_cluster_size = len(set(current_group_cluster_loci))\n                    if loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                            current_group_cluster_size &lt;= loci_clusters_cutoff_v[cluster_locus_group]:\n                        cluster_types[cluster_locus_group][cluster] = \"variable\"\n                    elif loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                            (loci_clusters_cutoff_v[cluster_locus_group] &lt; current_group_cluster_size &lt;\n                             loci_clusters_cutoff_c[cluster_locus_group]):\n                        cluster_types[cluster_locus_group][cluster] = \"intermediate\"\n                    else:\n                        cluster_types[cluster_locus_group][cluster] = \"conserved\"\n            for locus in self.loci:\n                locus_group = locus.group\n                for feature in locus.features:\n                    if feature.group_type and self.prms.args[\"keep_predefined_groups\"]:\n                        continue\n                    feature.group_type = cluster_types[locus_group][feature.group]\n                    self.feature_annotation.loc[feature.feature_id, \"group_type\"] = feature.group_type\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n\n    def set_feature_colours_based_on_groups(self) -&gt; None:\n        \"\"\"Define features fill colour based on corresponding feature group and group types.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            feature_groups = set([feature.group for locus in self.loci for feature in locus.features if feature.group])\n            if self.prms.args[\"feature_group_types_to_set_colour\"] and \\\n                    \"all\" not in self.prms.args[\"feature_group_types_to_set_colour\"]:\n                feature_groups = set([feature.group for locus in self.loci for feature in locus.features\n                                      if feature.group and feature.group_type in\n                                      self.prms.args[\"feature_group_types_to_set_colour\"]])\n            number_of_unique_feature_groups = len(feature_groups)\n            if self.prms.args[\"groups_fill_colour_palette_lib\"] == \"seaborn\":\n                colours_rgb = seaborn.color_palette(self.prms.args[\"groups_fill_colour_seaborn_palette\"],\n                                                    number_of_unique_feature_groups,\n                                                    desat=self.prms.args[\"groups_fill_colour_seaborn_desat\"])\n                random.shuffle(colours_rgb)\n            elif self.prms.args[\"groups_fill_colour_palette_lib\"] == \"distinctipy\":\n                colours_rgb = distinctipy.get_colors(number_of_unique_feature_groups,\n                                                     exclude_colours=[(1, 1, 1), (0, 0, 0)],\n                                                     pastel_factor=self.prms.args[\"groups_fill_colours_pastel_factor\"])\n            colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n            colours_dict = {g: c for g, c in zip(list(feature_groups), colours)}\n            for locus in self.loci:\n                for feature in locus.features:\n                    if feature.group in feature_groups:\n                        if self.prms.args[\"keep_predefined_colours\"] and feature.vis_prms[\"fill_colour\"] != \"default\":\n                            continue\n                        feature.vis_prms[\"fill_colour\"] = colours_dict[feature.group]\n                        self.feature_annotation.loc[feature.feature_id, \"fill_colour\"] = feature.vis_prms[\"fill_colour\"]\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to set feature colours based on groups.\") from error\n\n    def set_category_colours(self, use_table: bool = True) -&gt; None:\n        \"\"\"Define colours for each category.\n\n        Arguments:\n            use_table (bool): Bool value whether table with predefined colours should be used or not.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            colours_dict = dict()\n            if use_table:\n                colours_dict.update(\n                    pd.read_table(self.prms.args[\"category_colours\"]).set_index(\"category\")[\"colour\"].to_dict())\n\n            feature_categories = list(set([feature.category for locus in self.loci for feature in locus.features\n                                           if feature.category and feature.category]))\n            if not feature_categories:\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb Warning: there are no feature categories to set colours\", file=sys.stdout)\n            colours_dict = {cat: col for cat, col in colours_dict.items() if cat in feature_categories}\n\n            feature_categories = [ff for ff in feature_categories if ff not in colours_dict.keys()]\n            number_of_unique_feature_functions = len(feature_categories)\n            colours_rgb = seaborn.color_palette(self.prms.args[\"category_colour_seaborn_palette\"],\n                                                number_of_unique_feature_functions,\n                                                desat=self.prms.args[\"category_colour_seaborn_desat\"])\n            random.shuffle(colours_rgb)\n            colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n            colours_dict.update({g: c for g, c in zip(list(feature_categories), colours)})\n            for locus in self.loci:\n                locus.category_colours = colours_dict\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to set category colours.\") from error\n\n    def reorient_loci(self, ilund4u_mode: bool = False) -&gt; None:\n        \"\"\"Auto re-orient loci (reset strands) of loci if they are not matched.\n\n        Function tries to maximise co-orientation of homologous features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            count_of_changed_strands = 0\n            loci = [locus for locus in self.loci]\n            for locus_index in range(1, len(loci)):\n                p_locus = loci[locus_index - 1]\n                c_locus = loci[locus_index]\n                p_locus_strands = list(set([c[\"strand\"] for c in p_locus.coordinates]))\n                c_locus_strands = list(set([c[\"strand\"] for c in c_locus.coordinates]))\n                if len(p_locus_strands) == 1 and len(c_locus_strands) == 1:\n                    if not ilund4u_mode:\n                        pr_locus_features_groups = set([f.group for f in p_locus.features])\n                        c_locus_features_groups = set([f.group for f in c_locus.features])\n                    else:\n                        pr_locus_features_groups = set(\n                            [f.group for f in p_locus.features if f.group_type == \"conserved\"])\n                        c_locus_features_groups = set(\n                            [f.group for f in c_locus.features if f.group_type == \"conserved\"])\n                    overlapped_f_groups = pr_locus_features_groups &amp; c_locus_features_groups\n                    prl_strand, cl_strand = p_locus_strands[0], c_locus_strands[0]\n                    pr_locus_features_strands = {f.group: f.strand * prl_strand for f in p_locus.features if\n                                                 f.group in overlapped_f_groups}\n                    c_locus_features_strands = {f.group: f.strand * cl_strand for f in c_locus.features if\n                                                f.group in overlapped_f_groups}\n                    codirection_score = 0\n\n                    for ovg in overlapped_f_groups:\n                        codirection_score += pr_locus_features_strands[ovg] * c_locus_features_strands[ovg]\n                    if codirection_score &lt; 0:\n                        count_of_changed_strands += 1\n                        annot_coordinates = []\n                        for cc in loci[locus_index].coordinates:\n                            cc[\"strand\"] *= -1\n                            annot_coordinates.append(f\"{cc['start']}:{cc['end']}:{cc['strand']}\")\n                        loci[locus_index].coordinates = loci[locus_index].coordinates[::-1]\n                        annot_coordinates = annot_coordinates[::-1]\n                        self.locus_annotation.loc[c_locus.seq_id, \"coordinates\"] = \",\".join(annot_coordinates)\n                else:\n                    if self.prms.args[\"verbose\"]:\n                        print(\"\u25cb Warning: loci reorientation cannot be applied for loci that have both strands in\"\n                              \" pre-defined coordinates for visualisation\")\n            if self.prms.args[\"verbose\"]:\n                if count_of_changed_strands == 0:\n                    print(f\"\u29bf Orientation was not changed for any locus\", file=sys.stdout)\n                elif count_of_changed_strands == 1:\n                    print(f\"\u29bf Orientation was changed for 1 locus\", file=sys.stdout)\n                elif count_of_changed_strands &gt; 1:\n                    print(f\"\u29bf Orientation was changed for {count_of_changed_strands} loci\", file=sys.stdout)\n\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n\n    def get_loci_lengths_and_n_of_regions(self) -&gt; list[list[int]]:\n        \"\"\"Get loci lengths and number of regions.\n\n        Returns:\n            list: list each element of each contains locus size and number of breaks for visualisation track.\n\n        \"\"\"\n        try:\n            loci_sizes = []\n            for locus in self.loci:\n                number_of_gaps = len(locus.coordinates) - 1\n                if locus.circular:\n                    for i in range(number_of_gaps):\n                        if locus.coordinates[i][\"end\"] == locus.length and locus.coordinates[i + 1][\"start\"] == 1:\n                            number_of_gaps -= 1\n                loci_sizes.append([locus.size, number_of_gaps])\n            return loci_sizes\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to get loci lengths.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.__init__","title":"<code>__init__(parameters=lovis4u.Manager.Parameters)</code>","text":"<p>Create a Loci object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>, default:                 <code>Parameters</code> )         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, parameters=lovis4u.Manager.Parameters):\n    \"\"\"Create a Loci object.\n\n    Arguments:\n        parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n    \"\"\"\n    self.loci = []\n    self.locus_annotation = pd.DataFrame(columns=[\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\",\n                                                  \"order\", \"group\"]).set_index(\"sequence_id\")\n    self.feature_annotation = pd.DataFrame(columns=[\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\",\n                                                    \"group\", \"group_type\", \"category\", \"fill_colour\",\n                                                    \"stroke_colour\",\n                                                    \"show_label\"]).set_index(\"feature_id\")\n    self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.__load_annotation_file","title":"<code>__load_annotation_file(file_path, annotation_columns, index_column)</code>","text":"<p>Private method to load an annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for an annotation file to be loaded.</p> </li> <li> <code>annotation_columns</code>             (<code>list</code>)         \u2013          <p>List of columns that should be considered.</p> </li> <li> <code>index_column</code>             (<code>str</code>)         \u2013          <p>Column name to be considered as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>pd.DataFrame: Preprocessed annotation file.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __load_annotation_file(self, file_path: str, annotation_columns: list, index_column: str) -&gt; pd.DataFrame:\n    \"\"\"Private method to load an annotation file.\n\n    Arguments:\n        file_path (str): File path for an annotation file to be loaded.\n        annotation_columns (list): List of columns that should be considered.\n        index_column (str): Column name to be considered as index.\n\n    Returns:\n          pd.DataFrame: Preprocessed annotation file.\n    \"\"\"\n    annotation_table = pd.read_table(file_path)\n    found_allowed_columns = [i for i in annotation_columns if i in annotation_table.columns]\n    not_found_allowed_columns = [i for i in annotation_columns if i not in annotation_table.columns]\n    annotation_table = annotation_table[found_allowed_columns].set_index(index_column)\n    annotation_table[not_found_allowed_columns] = None\n    return annotation_table\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.__update_feature_annotation","title":"<code>__update_feature_annotation(feature_id, locus_id, coordinates, feature_type, category, name)</code>","text":"<p>Private method for updating feature annotation.</p> <p>Parameters:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>locus_id</code>             (<code>str</code>)         \u2013          <p>Sequence description.</p> </li> <li> <code>coordinates</code>             (<code>str</code>)         \u2013          <p>Feature coordinates.</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature type.</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Feature name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __update_feature_annotation(self, feature_id: str, locus_id: str, coordinates: str, feature_type: str,\n                                category: str, name: str) -&gt; None:\n    \"\"\"Private method for updating feature annotation.\n\n    Arguments:\n        feature_id (str): Feature identifier.\n        locus_id (str): Sequence description.\n        coordinates (str): Feature coordinates.\n        category (str): Feature type.\n        name (str): Feature name.\n\n\n    Returns:\n        None\n\n    \"\"\"\n    if feature_id not in self.feature_annotation.index:\n        self.feature_annotation.loc[feature_id] = {col: None for col in self.feature_annotation.columns}\n\n    if self.feature_annotation.loc[feature_id][\"group_type\"] in self.prms.args[\"feature_group_types_to_show_label\"] \\\n            or \"all\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n        show_label = 1\n    else:\n        show_label = 0\n    stroke_colour = \"default\"\n    if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n            self.feature_annotation.loc[feature_id][\"fill_colour\"] and \\\n            self.feature_annotation.loc[feature_id][\"fill_colour\"] != \"default\":\n        stroke_colour = lovis4u.Methods.scale_lightness(self.feature_annotation.loc[feature_id][\"fill_colour\"],\n                                                        self.prms.args[\"feature_stroke_colour_relative_lightness\"])\n    default_values = dict(locus_id=locus_id, coordinates=coordinates, feature_type=feature_type,\n                          name=name, group=\"\", group_type=\"\", category=category, fill_colour=\"default\",\n                          stroke_colour=stroke_colour,\n                          show_label=show_label)\n    self.feature_annotation.loc[feature_id] = self.feature_annotation.loc[feature_id].fillna(default_values)\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.__update_locus_annotation","title":"<code>__update_locus_annotation(record_id, record_description, record_length)</code>","text":"<p>Private method for updating loci annotation.</p> <p>Parameters:</p> <ul> <li> <code>record_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier.</p> </li> <li> <code>record_description</code>             (<code>str</code>)         \u2013          <p>Sequence description.</p> </li> <li> <code>record_length</code>             (<code>int</code>)         \u2013          <p>Sequence length.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __update_locus_annotation(self, record_id: str, record_description: str, record_length: int) -&gt; None:\n    \"\"\"Private method for updating loci annotation.\n\n    Arguments:\n        record_id (str): Sequence identifier.\n        record_description (str): Sequence description.\n        record_length (int): Sequence length.\n\n    Returns:\n        None\n\n    \"\"\"\n    if record_id not in self.locus_annotation.index:\n        self.locus_annotation.loc[record_id] = {col: None for col in self.locus_annotation.columns}\n\n    default_values = dict(length=record_length, coordinates=f\"1:{record_length}:1\",\n                          description=record_description, circular=1, order=len(self.loci), group=1)\n    self.locus_annotation.loc[record_id] = self.locus_annotation.loc[record_id].fillna(default_values)\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.cluster_sequences","title":"<code>cluster_sequences(dataframe, one_cluster)</code>","text":"<p>Define loci order and clusters with proteome similarity based hierarchical clustering.     This function changes the order of loci that are plotted and also updates corresponding to each loci group     attribute which defines homologues groups of proteomes.</p> <p>It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues     groups by other method you can also build pandas dataframe based on that with index corresponding to     feature id and column \"cluster\" corresponding to the group.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features. one_cluster (bool): consider all sequences to be members of one cluster, but still define the optimal order.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def cluster_sequences(self, dataframe: pd.DataFrame, one_cluster: bool) -&gt; None:\n    \"\"\"Define loci order and clusters with proteome similarity based hierarchical clustering.\n        This function changes the order of loci that are plotted and also updates corresponding to each loci group\n        attribute which defines homologues groups of proteomes.\n\n    It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n        groups by other method you can also build pandas dataframe based on that with index corresponding to\n        feature id and column \"cluster\" corresponding to the group.\n\n    Arguments:\n          dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n            one_cluster (bool): consider all sequences to be members of one cluster, but still define the\n            optimal order.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        proteins_loci_dict = collections.defaultdict(collections.deque)\n        loci_clusters_dict = dict()\n        number_of_loci = len(self.loci)\n        if number_of_loci &lt; 2:\n            return None\n        proteome_sizes = pd.Series(np.zeros(number_of_loci, dtype=int))\n        for locus_index in range(number_of_loci):\n            locus = self.loci[locus_index]\n            loci_clusters = [dataframe.loc[feature.feature_id, \"cluster\"] for feature in locus.features]\n            loci_clusters_dict[locus_index] = list(set(loci_clusters))\n            proteome_sizes.iloc[locus_index] = len(set(loci_clusters))\n            for l_cl in loci_clusters:\n                proteins_loci_dict[l_cl].append(locus_index)\n\n        loci_ids = [locus.seq_id for locus in self.loci]\n        similarity_matrix = pd.DataFrame(0.0, index=loci_ids, columns=loci_ids)\n        for locus_index in range(number_of_loci):\n            counts = pd.Series(np.zeros(number_of_loci, dtype=int))\n            for cluster in loci_clusters_dict[locus_index]:\n                js = proteins_loci_dict[cluster]\n                counts.iloc[js] += 1\n            locus_size = proteome_sizes[locus_index]\n            norm_factors = pd.Series(0.5 * (locus_size + proteome_sizes) / (locus_size * proteome_sizes),\n                                     index=counts.index)\n            weights = counts.mul(norm_factors)\n            similarity_matrix.iloc[locus_index] = weights\n        symmetric_distance_matrix = 1 - similarity_matrix\n        np.fill_diagonal(symmetric_distance_matrix.values, 0)\n        linkage_matrix = scipy.cluster.hierarchy.linkage(\n            scipy.spatial.distance.squareform(symmetric_distance_matrix),\n            method=\"average\")\n        dendrogram = scipy.cluster.hierarchy.dendrogram(linkage_matrix, no_plot=True)\n        if not one_cluster:\n            clusters = pd.Series(scipy.cluster.hierarchy.fcluster(linkage_matrix,\n                                                                  self.prms.args[\"clustering_h_value\"],\n                                                                  criterion=\"distance\"),\n                                 index=loci_ids)\n            for locus in self.loci:\n                locus.group = clusters[locus.seq_id]\n                self.locus_annotation.loc[locus.seq_id, \"group\"] = locus.group\n        order = dendrogram[\"leaves\"][::-1]\n        self.locus_annotation[\"initial_order\"] = self.locus_annotation[\"order\"]\n        for locus_index in range(number_of_loci):\n            locus = self.loci[locus_index]\n            self.locus_annotation.loc[locus.seq_id, \"order\"] = order.index(locus_index)\n        self.locus_annotation.sort_values(by=\"order\", inplace=True)\n        seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n\n        reordered_similarity_matrix = similarity_matrix.reindex(index=self.locus_annotation.index,\n                                                                columns=self.locus_annotation.index)\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"proteome_similarity_matrix.tsv\")\n        reordered_similarity_matrix.to_csv(file_path, sep=\"\\t\")\n        num_of_loci_groups = len(set(self.locus_annotation[\"group\"].to_list()))\n        if self.prms.args[\"verbose\"]:\n            if num_of_loci_groups == 1:\n                print(f\"\u29bf Loci order and {num_of_loci_groups} cluster was defined with proteome similarity based \"\n                      f\"hierarchical clustering\", file=sys.stdout)\n            elif num_of_loci_groups &gt; 1:\n                print(f\"\u29bf Loci order and {num_of_loci_groups} clusters were defined with proteome similarity based \"\n                      f\"hierarchical clustering\", file=sys.stdout)\n            print(f\"\u29bf Proteome similarity matrix of loci was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to cluster loci sequences.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.define_feature_groups","title":"<code>define_feature_groups(dataframe, group_column_name='cluster')</code>","text":"<p>Set features attribute \"group\" based on input dataframe.</p> <p>By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed     feature groups you can set them with feature table.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> <li> <code>group_column_name</code>             (<code>str</code>, default:                 <code>'cluster'</code> )         \u2013          <p>column name of the dataframe that represent corresponding group to each feature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def define_feature_groups(self, dataframe: pd.DataFrame, group_column_name: str = \"cluster\") -&gt; None:\n    \"\"\"Set features attribute \"group\" based on input dataframe.\n\n    By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed\n        feature groups you can set them with feature table.\n\n    Arguments:\n        dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n        group_column_name (str): column name of the dataframe that represent corresponding group to each feature.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n\n        for locus in self.loci:\n            for feature in locus.features:\n                if feature.group and self.prms.args[\"keep_predefined_groups\"]:\n                    continue\n                feature.group = dataframe.loc[feature.feature_id, group_column_name]\n                self.feature_annotation.loc[feature.feature_id, \"group\"] = feature.group\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define protein features groups.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.define_labels_to_be_shown","title":"<code>define_labels_to_be_shown()</code>","text":"<p>Set feature visaulisation attribute \"show_label\" based on feature groups.</p> <p>controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and     feature_group_types_to_show_label_on_first_occurrence parameters.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def define_labels_to_be_shown(self):\n    \"\"\"Set feature visaulisation attribute \"show_label\" based on feature groups.\n\n    controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and\n        feature_group_types_to_show_label_on_first_occurrence parameters.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        added_first_occurrence_labels = []\n        for locus in self.loci:\n            for feature in locus.features:\n                if self.prms.args[\"show_all_feature_labels\"]:\n                    feature.vis_prms[\"show_label\"] = 1\n                    continue\n                if feature.vis_prms[\"label\"] not in self.prms.args[\"feature_labels_to_ignore\"]:\n                    if \"any\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                    elif feature.group_type in self.prms.args[\"feature_group_types_to_show_label\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                    elif feature.group_type in \\\n                            self.prms.args[\"feature_group_types_to_show_label_on_first_occurrence\"]:\n                        if feature.group not in added_first_occurrence_labels:\n                            feature.vis_prms[\"show_label\"] = 1\n                            added_first_occurrence_labels.append(feature.group)\n                else:\n                    feature.vis_prms[\"show_label\"] = 0\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable define feature labels to be shown.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.find_variable_feature_groups","title":"<code>find_variable_feature_groups(mmseqs_results)</code>","text":"<p>Define feature group type attributes (variable or conserved) based on their conservation in corresponding     loci group feature.</p> <p>It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues     groups by other method you can also build pandas dataframe based on that with index corresponding to     feature id and column \"cluster\" corresponding to the group.</p> <p>Parameters:</p> <ul> <li> <code>mmseqs_results</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def find_variable_feature_groups(self, mmseqs_results: pd.DataFrame) -&gt; None:\n    \"\"\"Define feature group type attributes (variable or conserved) based on their conservation in corresponding\n        loci group feature.\n\n    It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n        groups by other method you can also build pandas dataframe based on that with index corresponding to\n        feature id and column \"cluster\" corresponding to the group.\n\n    Arguments:\n          mmseqs_results (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_clusters_sizes = self.locus_annotation[\"group\"].value_counts()\n        loci_clusters_cutoff_v = np.round(self.prms.args[\"CDS_is_variable_cutoff\"] * loci_clusters_sizes).astype(\n            int)\n        loci_clusters_cutoff_c = np.round(self.prms.args[\"CDF_is_conserved_cutoff\"] * loci_clusters_sizes).astype(\n            int)\n        loci_clusters_cutoff_v[loci_clusters_cutoff_v == 0] = 1\n        cluster_types = collections.defaultdict(dict)\n        for cluster in set(mmseqs_results[\"cluster\"].to_list()):\n            cluster_proteins = mmseqs_results[mmseqs_results[\"cluster\"] == cluster].index\n            cluster_loci = [locus for locus in self.loci if\n                            any(feature.feature_id in cluster_proteins for feature in locus.features)]\n            cluster_loci_groups = [locus.group for locus in cluster_loci]\n            for cluster_locus_group in cluster_loci_groups:\n                current_group_cluster_loci = [locus.seq_id for locus in cluster_loci if\n                                              locus.group == cluster_locus_group]\n                current_group_cluster_size = len(set(current_group_cluster_loci))\n                if loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                        current_group_cluster_size &lt;= loci_clusters_cutoff_v[cluster_locus_group]:\n                    cluster_types[cluster_locus_group][cluster] = \"variable\"\n                elif loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                        (loci_clusters_cutoff_v[cluster_locus_group] &lt; current_group_cluster_size &lt;\n                         loci_clusters_cutoff_c[cluster_locus_group]):\n                    cluster_types[cluster_locus_group][cluster] = \"intermediate\"\n                else:\n                    cluster_types[cluster_locus_group][cluster] = \"conserved\"\n        for locus in self.loci:\n            locus_group = locus.group\n            for feature in locus.features:\n                if feature.group_type and self.prms.args[\"keep_predefined_groups\"]:\n                    continue\n                feature.group_type = cluster_types[locus_group][feature.group]\n                self.feature_annotation.loc[feature.feature_id, \"group_type\"] = feature.group_type\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.get_loci_lengths_and_n_of_regions","title":"<code>get_loci_lengths_and_n_of_regions()</code>","text":"<p>Get loci lengths and number of regions.</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list[list[int]]</code> )        \u2013          <p>list each element of each contains locus size and number of breaks for visualisation track.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def get_loci_lengths_and_n_of_regions(self) -&gt; list[list[int]]:\n    \"\"\"Get loci lengths and number of regions.\n\n    Returns:\n        list: list each element of each contains locus size and number of breaks for visualisation track.\n\n    \"\"\"\n    try:\n        loci_sizes = []\n        for locus in self.loci:\n            number_of_gaps = len(locus.coordinates) - 1\n            if locus.circular:\n                for i in range(number_of_gaps):\n                    if locus.coordinates[i][\"end\"] == locus.length and locus.coordinates[i + 1][\"start\"] == 1:\n                        number_of_gaps -= 1\n            loci_sizes.append([locus.size, number_of_gaps])\n        return loci_sizes\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to get loci lengths.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.load_feature_annotation_file","title":"<code>load_feature_annotation_file(file_path)</code>","text":"<p>Load features annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for a features annotation file to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_feature_annotation_file(self, file_path: str) -&gt; None:\n    \"\"\"Load features annotation file.\n\n    Arguments:\n        file_path (str): File path for a features annotation file to be loaded.\n\n    Returns:\n        None\n\n    \"\"\"\n    annotation_columns = [\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\", \"group\", \"group_type\",\n                          \"category\", \"fill_colour\", \"stroke_colour\", \"show_label\"]\n    self.feature_annotation = self.__load_annotation_file(file_path, annotation_columns, \"feature_id\")\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.load_loci_from_extended_gff","title":"<code>load_loci_from_extended_gff(input_f, ilund4u_mode=False)</code>","text":"<p>Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide     sequence. Such files are produced for example by pharokka annotation tool.</p> <p>All files with extension other than .gff (not case-sensitive) will be ignored.</p> <p>Parameters:</p> <ul> <li> <code>input_folder</code>         \u2013          <p>folder name with gff files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_from_extended_gff(self, input_f: str, ilund4u_mode: bool = False) -&gt; None:\n    \"\"\"Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide\n        sequence. Such files are produced for example by pharokka annotation tool.\n\n    All files with extension other than .gff (not case-sensitive) will be ignored.\n\n    Arguments:\n        input_folder: folder name with gff files.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    try:\n        if isinstance(input_f, str):\n            input_folder = input_f\n            if not os.path.exists(input_folder):\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n            gff_files = [os.path.join(input_folder, f) for f in os.listdir(input_folder)]\n        elif isinstance(input_f, list):\n            gff_files = input_f\n        else:\n            raise lovis4u.Manager.lovis4uError(f\"The input for the GFF parsing function must be either a folder or \"\n                                               f\"a list of files.\")\n        if not gff_files:\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_f} does not contain files.\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u25cb Reading gff file{'s' if len(gff_files) &gt; 1 else ''}...\", file=sys.stdout)\n        for gff_file_path in gff_files:\n            try:\n                gff_file = gff_file_path\n                gff_records = list(BCBio.GFF.parse(gff_file_path, limit_info=dict(gff_type=[\"CDS\"])))\n                if len(gff_records) != 1:\n                    print(f\"\u25cb Warning: gff file {gff_file} contains information for more than 1 \"\n                          f\"sequence. File will be skipped.\")\n                    continue\n                gff_record = gff_records[0]\n                try:\n                    record_locus_sequence = gff_record.seq\n                except Bio.Seq.UndefinedSequenceError:\n                    print(f\"\u25cb Warning: gff file {gff_file} doesn't contain corresponding sequences.\")\n                    continue\n                if self.prms.args[\"gff_description_source\"] in gff_record.annotations:\n                    record_description = gff_record.annotations[self.prms.args[\"gff_description_source\"]][0]\n                    if isinstance(record_description, tuple):\n                        record_description = \" \".join(record_description)\n                else:\n                    record_description = \"\"\n                if self.prms.args[\"use_filename_as_contig_id\"]:\n                    gff_record.id = os.path.splitext(os.path.basename(gff_file))[0]\n                self.__update_locus_annotation(gff_record.id, record_description, len(record_locus_sequence))\n                locus_annotation_row = self.locus_annotation.loc[gff_record.id]\n                coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                               locus_annotation_row[\"coordinates\"].split(\",\")]\n                record_locus = Locus(seq_id=gff_record.id, coordinates=coordinates,\n                                     description=locus_annotation_row[\"description\"],\n                                     circular=locus_annotation_row[\"circular\"],\n                                     length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                     order=locus_annotation_row[\"order\"])\n                features_ids = [i.id for i in gff_record.features]\n                if len(features_ids) != len(set(features_ids)):\n                    raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} contains duplicated feature ids while\"\n                                                       f\" only unique are allowed.\")\n                for gff_feature in gff_record.features:\n                    feature_id = gff_feature.id\n                    if ilund4u_mode:\n                        if gff_record.id not in feature_id:\n                            feature_id = f\"{gff_record.id}-{feature_id}\"\n                    transl_table = self.prms.args[\"default_transl_table\"]\n                    if \"transl_table\" in gff_feature.qualifiers.keys():\n                        transl_table = int(gff_feature.qualifiers[\"transl_table\"][0])\n                    name = \"\"\n                    if self.prms.args[\"gff_CDS_name_source\"] in gff_feature.qualifiers:\n                        name = gff_feature.qualifiers[self.prms.args[\"gff_CDS_name_source\"]][0]\n                    category = \"\"\n                    if self.prms.args[\"gff_CDS_category_source\"] in gff_feature.qualifiers:\n                        category = \",\".join(gff_feature.qualifiers[self.prms.args[\"gff_CDS_category_source\"]])\n                    for coordinate in record_locus.coordinates:\n                        overlapping = False\n                        start, end = coordinate[\"start\"], coordinate[\"end\"]\n                        if start &lt;= gff_feature.location.start + 1 &lt;= end or start &lt;= gff_feature.location.end &lt;= end:\n                            overlapping = True\n                            break\n                    if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                        continue\n                    self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                     f\"{int(gff_feature.location.start) + 1}:\"\n                                                     f\"{int(gff_feature.location.end)}:{gff_feature.location.strand}\",\n                                                     \"CDS\", category, name)\n                    feature_annotation_row = self.feature_annotation.loc[feature_id]\n                    feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                      feature_id=feature_id, start=int(gff_feature.location.start) + 1,\n                                      end=int(gff_feature.location.end), strand=gff_feature.location.strand,\n                                      name=feature_annotation_row[\"name\"],\n                                      sequence=gff_feature.translate(record_locus_sequence, table=transl_table,\n                                                                     cds=False)[:-1],\n                                      group=feature_annotation_row[\"group\"],\n                                      group_type=feature_annotation_row[\"group_type\"],\n                                      category=feature_annotation_row[\"category\"],\n                                      vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                    stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                    show_label=feature_annotation_row[\"show_label\"]),\n                                      overlapping=overlapping, parameters=self.prms)\n                    record_locus.features.append(feature)\n                self.loci.append(record_locus)\n            except:\n                print(f\"\u25cb Warning: gff file {gff_file} was not read properly and skipped\")\n                if self.prms.args[\"parsing_debug\"]:\n                    self.prms.args[\"debug\"] = True\n                    raise lovis4u.Manager.lovis4uError()\n        seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n        loci_ids = [l.seq_id for l in self.loci]\n        if len(loci_ids) != len(set(loci_ids)):\n            raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                               f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                               f\"as contig id which can help to fix the problem.\")\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                  f\"files folder\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gff folder.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.load_loci_from_gb","title":"<code>load_loci_from_gb(input_folder)</code>","text":"<p>Load loci from the folder with genbank files.</p> <p>All files with extension other than .gb (not case-sensitive) will be ignored.</p> <p>Parameters:</p> <ul> <li> <code>input_folder</code>             (<code>str</code>)         \u2013          <p>folder name with gb files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_from_gb(self, input_folder: str) -&gt; None:\n    \"\"\"Load loci from the folder with genbank files.\n\n    All files with extension other than .gb (not case-sensitive) will be ignored.\n\n    Arguments:\n        input_folder: folder name with gb files.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not os.path.exists(input_folder):\n        raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n    try:\n        gb_files = [f for f in os.listdir(input_folder)]\n        if not gb_files:\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain files.\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u25cb Reading gb file{'s' if len(gb_files) &gt; 1 else ''}...\", file=sys.stdout)\n        for gb_file in gb_files:\n            try:\n                gb_file_path = os.path.join(input_folder, gb_file)\n                gb_records = list(Bio.SeqIO.parse(gb_file_path, \"genbank\"))\n                if len(gb_records) != 1:\n                    print(f\"\u25cb Warning: gb file {gb_file} contains information for more than 1 \"\n                          f\"sequence. File will be skipped.\")\n                    continue\n                gb_record = gb_records[0]\n                record_locus_sequence = gb_record.seq\n                if self.prms.args[\"genbank_description_source\"] == \"description\":\n                    record_description = gb_record.description\n                elif \"annotations:\" in self.prms.args[\"genbank_description_source\"]:\n                    feature_description_key = self.prms.args[\"genbank_description_source\"].split(\":\")[1]\n                    record_description = gb_record.annotations[feature_description_key]\n                else:\n                    record_description = \"\"\n                if self.prms.args[\"use_filename_as_contig_id\"]:\n                    gb_record.id = os.path.splitext(os.path.basename(gb_file))[0]\n                self.__update_locus_annotation(gb_record.id, record_description, len(record_locus_sequence))\n                locus_annotation_row = self.locus_annotation.loc[gb_record.id]\n                coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                               locus_annotation_row[\"coordinates\"].split(\",\")]\n                record_locus = Locus(seq_id=gb_record.id, coordinates=coordinates,\n                                     description=locus_annotation_row[\"description\"],\n                                     circular=locus_annotation_row[\"circular\"],\n                                     length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                     order=locus_annotation_row[\"order\"])\n\n                gb_CDSs = [i for i in gb_record.features if i.type == \"CDS\"]\n                first_CDS_record = gb_CDSs[0]\n                id_source = self.prms.args[\"genbank_id_source\"]\n                if self.prms.args[\"genbank_id_source\"] not in first_CDS_record.qualifiers:\n                    for alternative_id_source in self.prms.args[\"genbank_id_alternative_source\"]:\n                        if alternative_id_source in first_CDS_record.qualifiers:\n                            id_source = alternative_id_source\n                            if self.prms.args[\"verbose\"]:\n                                print(f\"\u25cb Warning: there is no &lt;{self.prms.args['genbank_id_source']}&gt; attribute \"\n                                      f\"for CDS records in {gb_file}. Alternative &lt;{id_source}&gt; was used instead.\",\n                                      file=sys.stdout)\n                            break\n                    if id_source == self.prms.args[\"genbank_id_source\"]:\n                        print(f\"There is no &lt;{self.prms.args['genbank_id_source']}&gt; \"\n                              f\"attribute for CDS record found in {gb_file}. We tried to\"\n                              f\" find any from the alternative list: \"\n                              f\"{','.join(self.prms.args['genbank_id_alternative_source'])}\"\n                              f\", but they also weren't found.\")  # add about cmd parameter\n                features_ids = [i.qualifiers[id_source][0] for i in gb_CDSs]\n                if len(features_ids) != len(set(features_ids)):\n                    print(f\"GB file {gb_record} contains duplicated feature ids while\"\n                                                       f\" only unique are allowed.\")\n\n                for gb_feature in gb_CDSs:\n                    feature_id = gb_feature.qualifiers[id_source][0].replace(\"|\", \"_\")\n                    transl_table = self.prms.args[\"default_transl_table\"]\n                    if \"transl_table\" in gb_feature.qualifiers.keys():\n                        transl_table = int(gb_feature.qualifiers[\"transl_table\"][0])\n                    name = \"\"\n                    if self.prms.args[\"genbank_CDS_name_source\"] in gb_feature.qualifiers:\n                        name = gb_feature.qualifiers[self.prms.args[\"genbank_CDS_name_source\"]][0]\n                    category = \"\"\n                    if self.prms.args[\"genbank_CDS_category_source\"] in gb_feature.qualifiers:\n                        category = \",\".join(gb_feature.qualifiers[self.prms.args[\"genbank_CDS_category_source\"]])\n\n                    for coordinate in record_locus.coordinates:\n                        overlapping = False\n                        start, end = coordinate[\"start\"], coordinate[\"end\"]\n                        if start &lt;= gb_feature.location.start + 1 &lt;= end or start &lt;= gb_feature.location.end &lt;= end:\n                            overlapping = True\n                            break\n                    if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                        continue\n                    self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                     f\"{int(gb_feature.location.start) + 1}:\"\n                                                     f\"{int(gb_feature.location.end)}:\"\n                                                     f\"{gb_feature.location.strand}\", \"CDS\", category, name)\n                    feature_annotation_row = self.feature_annotation.loc[feature_id]\n                    feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                      feature_id=feature_id, start=int(gb_feature.location.start) + 1,\n                                      end=int(gb_feature.location.end),\n                                      strand=gb_feature.location.strand,\n                                      name=feature_annotation_row[\"name\"],\n                                      sequence=gb_feature.translate(record_locus_sequence,\n                                                                    table=transl_table,\n                                                                    cds=False)[:-1],\n                                      group=feature_annotation_row[\"group\"],\n                                      group_type=feature_annotation_row[\"group_type\"],\n                                      category=feature_annotation_row[\"category\"],\n                                      vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                    stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                    show_label=feature_annotation_row[\"show_label\"]),\n                                      overlapping = overlapping,\n                                      parameters=self.prms)\n\n                    record_locus.features.append(feature)\n                self.loci.append(record_locus)\n            except:\n                print(f\"\u25cb Warning: gb file {gb_file} was not read properly and skipped\")\n                if self.prms.args[\"parsing_debug\"]:\n                    self.prms.args[\"debug\"] = True\n                    raise lovis4u.Manager.lovis4uError()\n        seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n        loci_ids = [l.seq_id for l in self.loci]\n        if len(loci_ids) != len(set(loci_ids)):\n            raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                               f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                               f\"as contig id which can help to fix the problem.\")\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                  f\"files folder\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gb folder.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.load_locus_annotation_file","title":"<code>load_locus_annotation_file(file_path)</code>","text":"<p>Load loci annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for a loci annotation file to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_locus_annotation_file(self, file_path: str) -&gt; None:\n    \"\"\"Load loci annotation file.\n\n    Arguments:\n        file_path (str): File path for a loci annotation file to be loaded.\n\n    Returns:\n        None\n\n    \"\"\"\n    annotation_columns = [\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\", \"order\", \"group\"]\n    self.locus_annotation = self.__load_annotation_file(file_path, annotation_columns, \"sequence_id\")\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.mmseqs_cluster","title":"<code>mmseqs_cluster()</code>","text":"<p>Cluster all proteins using mmseqs in order to define groups of homologues.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is defined by representative sequence id within a corresponding cluster.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def mmseqs_cluster(self) -&gt; pd.DataFrame:\n    \"\"\"Cluster all proteins using mmseqs in order to define groups of homologues.\n\n    Returns:\n        pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is\n            defined by representative sequence id within a corresponding cluster.\n\n    \"\"\"\n    if self.prms.args[\"verbose\"]:\n        print(f\"\u25cb Running mmseqs for protein clustering...\", file=sys.stdout)\n    try:\n        feature_records = [feature.record for locus in self.loci for feature in locus.features]\n        temp_input = tempfile.NamedTemporaryFile()\n        Bio.SeqIO.write(feature_records, temp_input.name, \"fasta\")\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        mmseqs_output_folder = os.path.join(self.prms.args[\"output_dir\"], \"mmseqs\")\n        if os.path.exists(mmseqs_output_folder):\n            shutil.rmtree(mmseqs_output_folder)\n        os.mkdir(mmseqs_output_folder)\n        Bio.SeqIO.write(feature_records, os.path.join(mmseqs_output_folder, \"input_proteins.fa\"), \"fasta\")\n        mmseqs_output_folder_db = os.path.join(mmseqs_output_folder, \"DB\")\n        os.mkdir(mmseqs_output_folder_db)\n        mmseqs_stdout = open(os.path.join(mmseqs_output_folder, \"mmseqs_stdout.txt\"), \"w\")\n        mmseqs_stderr = open(os.path.join(mmseqs_output_folder, \"mmseqs_stderr.txt\"), \"w\")\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createdb\", temp_input.name,\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\")], stdout=mmseqs_stdout,\n                       stderr=mmseqs_stderr)\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"cluster\",\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"tmp\"),\n                        \"--cluster-mode\", str(self.prms.args[\"mmseqs_cluster_mode\"]),\n                        \"--cov-mode\", str(self.prms.args[\"mmseqs_cov_mode\"]),\n                        \"--min-seq-id\", str(self.prms.args[\"mmseqs_min_seq_id\"]),\n                        \"-c\", str(self.prms.args[\"mmseqs_c\"]),\n                        \"-s\", str(self.prms.args[\"mmseqs_s\"])], stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createtsv\",\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                        os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\")],\n                       stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n        mmseqs_clustering_results = pd.read_table(os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\"),\n                                                  sep=\"\\t\", header=None, names=[\"cluster\", \"protein_id\"])\n        mmseqs_clustering_results = mmseqs_clustering_results.set_index(\"protein_id\")\n\n        num_of_unique_clusters = len(set(mmseqs_clustering_results[\"cluster\"].to_list()))\n        num_of_proteins = len(mmseqs_clustering_results.index)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {num_of_unique_clusters} clusters for {num_of_proteins} proteins were found with mmseqs\\n\"\n                  f\"    mmseqs clustering results were saved to \"\n                  f\"{os.path.join(mmseqs_output_folder, 'mmseqs_clustering.tsv')}\", file=sys.stdout)\n        return mmseqs_clustering_results\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to run mmseqs clustering.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.remove_non_overlapping_features","title":"<code>remove_non_overlapping_features()</code>","text":"<p>Removes features that are not overlapping with visualisation window.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def remove_non_overlapping_features(self) -&gt; None:\n    \"\"\"Removes features that are not overlapping with visualisation window.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        ids_of_non_overlapping_objects = []\n        for locus in self.loci:\n            ids_of_non_overlapping_objects += [obj.feature_id for obj in locus.features if not obj.overlapping]\n            filtered_objects = [obj for obj in locus.features if obj.overlapping]\n            locus.features = filtered_objects\n        self.feature_annotation = self.feature_annotation.drop(ids_of_non_overlapping_objects)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to clean non overlapping features.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.reorient_loci","title":"<code>reorient_loci(ilund4u_mode=False)</code>","text":"<p>Auto re-orient loci (reset strands) of loci if they are not matched.</p> <p>Function tries to maximise co-orientation of homologous features.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def reorient_loci(self, ilund4u_mode: bool = False) -&gt; None:\n    \"\"\"Auto re-orient loci (reset strands) of loci if they are not matched.\n\n    Function tries to maximise co-orientation of homologous features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        count_of_changed_strands = 0\n        loci = [locus for locus in self.loci]\n        for locus_index in range(1, len(loci)):\n            p_locus = loci[locus_index - 1]\n            c_locus = loci[locus_index]\n            p_locus_strands = list(set([c[\"strand\"] for c in p_locus.coordinates]))\n            c_locus_strands = list(set([c[\"strand\"] for c in c_locus.coordinates]))\n            if len(p_locus_strands) == 1 and len(c_locus_strands) == 1:\n                if not ilund4u_mode:\n                    pr_locus_features_groups = set([f.group for f in p_locus.features])\n                    c_locus_features_groups = set([f.group for f in c_locus.features])\n                else:\n                    pr_locus_features_groups = set(\n                        [f.group for f in p_locus.features if f.group_type == \"conserved\"])\n                    c_locus_features_groups = set(\n                        [f.group for f in c_locus.features if f.group_type == \"conserved\"])\n                overlapped_f_groups = pr_locus_features_groups &amp; c_locus_features_groups\n                prl_strand, cl_strand = p_locus_strands[0], c_locus_strands[0]\n                pr_locus_features_strands = {f.group: f.strand * prl_strand for f in p_locus.features if\n                                             f.group in overlapped_f_groups}\n                c_locus_features_strands = {f.group: f.strand * cl_strand for f in c_locus.features if\n                                            f.group in overlapped_f_groups}\n                codirection_score = 0\n\n                for ovg in overlapped_f_groups:\n                    codirection_score += pr_locus_features_strands[ovg] * c_locus_features_strands[ovg]\n                if codirection_score &lt; 0:\n                    count_of_changed_strands += 1\n                    annot_coordinates = []\n                    for cc in loci[locus_index].coordinates:\n                        cc[\"strand\"] *= -1\n                        annot_coordinates.append(f\"{cc['start']}:{cc['end']}:{cc['strand']}\")\n                    loci[locus_index].coordinates = loci[locus_index].coordinates[::-1]\n                    annot_coordinates = annot_coordinates[::-1]\n                    self.locus_annotation.loc[c_locus.seq_id, \"coordinates\"] = \",\".join(annot_coordinates)\n            else:\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb Warning: loci reorientation cannot be applied for loci that have both strands in\"\n                          \" pre-defined coordinates for visualisation\")\n        if self.prms.args[\"verbose\"]:\n            if count_of_changed_strands == 0:\n                print(f\"\u29bf Orientation was not changed for any locus\", file=sys.stdout)\n            elif count_of_changed_strands == 1:\n                print(f\"\u29bf Orientation was changed for 1 locus\", file=sys.stdout)\n            elif count_of_changed_strands &gt; 1:\n                print(f\"\u29bf Orientation was changed for {count_of_changed_strands} loci\", file=sys.stdout)\n\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.save_feature_annotation_table","title":"<code>save_feature_annotation_table()</code>","text":"<p>Save feature annotation table to the output folder.</p> <p>Output file name is feature_annotation_table.tsv</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def save_feature_annotation_table(self) -&gt; None:\n    \"\"\"Save feature annotation table to the output folder.\n\n    Output file name is feature_annotation_table.tsv\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"feature_annotation_table.tsv\")\n        self.feature_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"feature_id\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Feature annotation table was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to save feature annotation table.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.save_locus_annotation_table","title":"<code>save_locus_annotation_table()</code>","text":"<p>Save loci annotation table to the output folder.</p> <p>Output file name is locus_annotation_table.tsv</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def save_locus_annotation_table(self) -&gt; None:\n    \"\"\"Save loci annotation table to the output folder.\n\n    Output file name is locus_annotation_table.tsv\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"locus_annotation_table.tsv\")\n        self.locus_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"sequence_id\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Loci annotation table was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to save loci annotation table.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.set_category_colours","title":"<code>set_category_colours(use_table=True)</code>","text":"<p>Define colours for each category.</p> <p>Parameters:</p> <ul> <li> <code>use_table</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Bool value whether table with predefined colours should be used or not.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def set_category_colours(self, use_table: bool = True) -&gt; None:\n    \"\"\"Define colours for each category.\n\n    Arguments:\n        use_table (bool): Bool value whether table with predefined colours should be used or not.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        colours_dict = dict()\n        if use_table:\n            colours_dict.update(\n                pd.read_table(self.prms.args[\"category_colours\"]).set_index(\"category\")[\"colour\"].to_dict())\n\n        feature_categories = list(set([feature.category for locus in self.loci for feature in locus.features\n                                       if feature.category and feature.category]))\n        if not feature_categories:\n            if self.prms.args[\"verbose\"]:\n                print(\"\u25cb Warning: there are no feature categories to set colours\", file=sys.stdout)\n        colours_dict = {cat: col for cat, col in colours_dict.items() if cat in feature_categories}\n\n        feature_categories = [ff for ff in feature_categories if ff not in colours_dict.keys()]\n        number_of_unique_feature_functions = len(feature_categories)\n        colours_rgb = seaborn.color_palette(self.prms.args[\"category_colour_seaborn_palette\"],\n                                            number_of_unique_feature_functions,\n                                            desat=self.prms.args[\"category_colour_seaborn_desat\"])\n        random.shuffle(colours_rgb)\n        colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n        colours_dict.update({g: c for g, c in zip(list(feature_categories), colours)})\n        for locus in self.loci:\n            locus.category_colours = colours_dict\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to set category colours.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Loci.set_feature_colours_based_on_groups","title":"<code>set_feature_colours_based_on_groups()</code>","text":"<p>Define features fill colour based on corresponding feature group and group types.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def set_feature_colours_based_on_groups(self) -&gt; None:\n    \"\"\"Define features fill colour based on corresponding feature group and group types.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        feature_groups = set([feature.group for locus in self.loci for feature in locus.features if feature.group])\n        if self.prms.args[\"feature_group_types_to_set_colour\"] and \\\n                \"all\" not in self.prms.args[\"feature_group_types_to_set_colour\"]:\n            feature_groups = set([feature.group for locus in self.loci for feature in locus.features\n                                  if feature.group and feature.group_type in\n                                  self.prms.args[\"feature_group_types_to_set_colour\"]])\n        number_of_unique_feature_groups = len(feature_groups)\n        if self.prms.args[\"groups_fill_colour_palette_lib\"] == \"seaborn\":\n            colours_rgb = seaborn.color_palette(self.prms.args[\"groups_fill_colour_seaborn_palette\"],\n                                                number_of_unique_feature_groups,\n                                                desat=self.prms.args[\"groups_fill_colour_seaborn_desat\"])\n            random.shuffle(colours_rgb)\n        elif self.prms.args[\"groups_fill_colour_palette_lib\"] == \"distinctipy\":\n            colours_rgb = distinctipy.get_colors(number_of_unique_feature_groups,\n                                                 exclude_colours=[(1, 1, 1), (0, 0, 0)],\n                                                 pastel_factor=self.prms.args[\"groups_fill_colours_pastel_factor\"])\n        colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n        colours_dict = {g: c for g, c in zip(list(feature_groups), colours)}\n        for locus in self.loci:\n            for feature in locus.features:\n                if feature.group in feature_groups:\n                    if self.prms.args[\"keep_predefined_colours\"] and feature.vis_prms[\"fill_colour\"] != \"default\":\n                        continue\n                    feature.vis_prms[\"fill_colour\"] = colours_dict[feature.group]\n                    self.feature_annotation.loc[feature.feature_id, \"fill_colour\"] = feature.vis_prms[\"fill_colour\"]\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to set feature colours based on groups.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Locus","title":"<code>Locus</code>","text":"<p>A Locus object represents a particular locus that will be one of the sequence tracks on final figure.</p> <p>Attributes:</p> <ul> <li> <code>seq_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier. Can be used to label locus.</p> </li> <li> <code>coordinates</code>             (<code>list</code>)         \u2013          <p>List of regions to be shown. Each region format: dict with keys: start, end, strand and corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>size</code>             (<code>int</code>)         \u2013          <p>total length of regions to be plotted.</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>Sequence description that can be used to label locus.</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>full length of the locus independent on region that should be plotted.</p> </li> <li> <code>circular</code>             (<code>bool</code>)         \u2013          <p>Bool value whether locus is circular or not. It defines whether you have gap or not passing 1 value on the final figure.</p> </li> <li> <code>features</code>             (<code>list</code>)         \u2013          <p>list of Feature objects that overlapped with coordinates.</p> </li> <li> <code>order</code>             (<code>int</code>)         \u2013          <p>index on ordered list of loci visualisation. Can be pre-defined or found based on loci hierarchical clustering with cluster_sequences category.</p> </li> <li> <code>group</code>             (<code>int | str</code>)         \u2013          <p>locus group that defines set of closely-related loci.</p> </li> <li> <code>category_colours</code>             (<code>dict</code>)         \u2013          <p>colours for locus' features categories.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Locus:\n    \"\"\"A Locus object represents a particular locus that will be one of the sequence tracks on final figure.\n\n    Attributes:\n        seq_id (str): Sequence identifier. Can be used to label locus.\n        coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n            corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n        size (int): total length of regions to be plotted.\n        description (str): Sequence description that can be used to label locus.\n        length (int): full length of the locus independent on region that should be plotted.\n        circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n            1 value on the final figure.\n        features (list): list of Feature objects that overlapped with coordinates.\n        order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n            hierarchical clustering with cluster_sequences category.\n        group (int | str): locus group that defines set of closely-related loci.\n        category_colours (dict): colours for locus' features categories.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, seq_id: str, coordinates: list, description: str, length: int, circular: bool,\n                 features: list, order: int, parameters: lovis4u.Manager.Parameters, group: typing.Union[int, str] = 1):\n        \"\"\"Create a Locus object.\n\n        Arguments:\n            seq_id (str): Sequence identifier. Can be used to label locus.\n            coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n                corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n            description (str): Sequence description that can be used to label locus.\n            length (int): full length of the locus independent on region that should be plotted.\n            circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n                1 value on the final figure.\n            features (list): list of Feature objects that overlapped with coordinates.\n            order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n            hierarchical clustering with cluster_sequences category.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n            group (int | str): locus group that defines set of closely-related loci [1].\n\n        \"\"\"\n        self.seq_id = seq_id\n        self.coordinates = coordinates\n        self.size = 0\n        taken_coordinates = []\n        for coordinate in coordinates:\n            self.size += abs(coordinate[\"end\"] - coordinate[\"start\"] + 1)\n            taken_coordinates += list(range(coordinate[\"start\"], coordinate[\"end\"] + 1))\n        if len(taken_coordinates) != len(set(taken_coordinates)):\n            raise lovis4u.Manager.lovis4uError(f\"Specified coordinates seems to be overlapped\"\n                                               f\" or not in 0-based format.\")\n        for coordinate in coordinates:\n            if coordinate[\"start\"] &lt; 1:\n                raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is in 0-based format\"\n                                                   f\" while input should be in 1-based.\")\n            if coordinate[\"end\"] &gt; length:\n                raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is out of sequence length\"\n                                                   f\" ({length} nt).\")\n\n        self.description = description\n        self.length = length\n        self.circular = circular\n        self.features = features\n        self.order = order\n        self.group = group\n        self.category_colours = dict()\n        self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.DataProcessing.Locus.__init__","title":"<code>__init__(seq_id, coordinates, description, length, circular, features, order, parameters, group=1)</code>","text":"<p>Create a Locus object.</p> <p>Parameters:</p> <ul> <li> <code>seq_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier. Can be used to label locus.</p> </li> <li> <code>coordinates</code>             (<code>list</code>)         \u2013          <p>List of regions to be shown. Each region format: dict with keys: start, end, strand and corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>Sequence description that can be used to label locus.</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>full length of the locus independent on region that should be plotted.</p> </li> <li> <code>circular</code>             (<code>bool</code>)         \u2013          <p>Bool value whether locus is circular or not. It defines whether you have gap or not passing 1 value on the final figure.</p> </li> <li> <code>features</code>             (<code>list</code>)         \u2013          <p>list of Feature objects that overlapped with coordinates.</p> </li> <li> <code>order</code>             (<code>int</code>)         \u2013          <p>index on ordered list of loci visualisation. Can be pre-defined or found based on loci</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> <li> <code>group</code>             (<code>int | str</code>, default:                 <code>1</code> )         \u2013          <p>locus group that defines set of closely-related loci [1].</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, seq_id: str, coordinates: list, description: str, length: int, circular: bool,\n             features: list, order: int, parameters: lovis4u.Manager.Parameters, group: typing.Union[int, str] = 1):\n    \"\"\"Create a Locus object.\n\n    Arguments:\n        seq_id (str): Sequence identifier. Can be used to label locus.\n        coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n            corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n        description (str): Sequence description that can be used to label locus.\n        length (int): full length of the locus independent on region that should be plotted.\n        circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n            1 value on the final figure.\n        features (list): list of Feature objects that overlapped with coordinates.\n        order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n        hierarchical clustering with cluster_sequences category.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n        group (int | str): locus group that defines set of closely-related loci [1].\n\n    \"\"\"\n    self.seq_id = seq_id\n    self.coordinates = coordinates\n    self.size = 0\n    taken_coordinates = []\n    for coordinate in coordinates:\n        self.size += abs(coordinate[\"end\"] - coordinate[\"start\"] + 1)\n        taken_coordinates += list(range(coordinate[\"start\"], coordinate[\"end\"] + 1))\n    if len(taken_coordinates) != len(set(taken_coordinates)):\n        raise lovis4u.Manager.lovis4uError(f\"Specified coordinates seems to be overlapped\"\n                                           f\" or not in 0-based format.\")\n    for coordinate in coordinates:\n        if coordinate[\"start\"] &lt; 1:\n            raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is in 0-based format\"\n                                               f\" while input should be in 1-based.\")\n        if coordinate[\"end\"] &gt; length:\n            raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is out of sequence length\"\n                                               f\" ({length} nt).\")\n\n    self.description = description\n    self.length = length\n    self.circular = circular\n    self.features = features\n    self.order = order\n    self.group = group\n    self.category_colours = dict()\n    self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.ColorLegendVis","title":"<code>ColorLegendVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>ColorLegend track object that handles visualisation of legend to feature's category colours.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class ColorLegendVis(Track):\n    \"\"\"ColorLegend track object that handles visualisation of legend to feature's category colours.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a ColorLegend object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n        self.track_height = None\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a ColorLegend track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_upper = self.layout[\"current_y_coordinate\"]\n            canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n            canvas.setFont(self.prms.args[\"colour_legend_font_face\"],\n                           self.track_data[\"colour_legend_label_size\"])\n            for label_dict in self.track_data[\"labels\"]:\n                yl = y_upper + label_dict[\"relative_y\"]\n                yt = y_upper + label_dict[\"relative_y_text\"]\n                canvas.setFillColorRGB(*matplotlib.colors.hex2color(label_dict[\"colour\"]),\n                                       self.prms.args[\"category_annotation_alpha\"])\n                canvas.rect(label_dict[\"label_x\"], yl, label_dict[\"label_width\"],\n                            self.track_data[\"line_width\"], fill=1, stroke=0)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"colour_legend_label_colour\", self.prms))\n                canvas.drawString(label_dict[\"label_x\"], yt, label_dict[\"label\"])\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a colour legend track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.ColorLegendVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a ColorLegend object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a ColorLegend object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n    self.track_height = None\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.ColorLegendVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a ColorLegend track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a ColorLegend track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_upper = self.layout[\"current_y_coordinate\"]\n        canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n        canvas.setFont(self.prms.args[\"colour_legend_font_face\"],\n                       self.track_data[\"colour_legend_label_size\"])\n        for label_dict in self.track_data[\"labels\"]:\n            yl = y_upper + label_dict[\"relative_y\"]\n            yt = y_upper + label_dict[\"relative_y_text\"]\n            canvas.setFillColorRGB(*matplotlib.colors.hex2color(label_dict[\"colour\"]),\n                                   self.prms.args[\"category_annotation_alpha\"])\n            canvas.rect(label_dict[\"label_x\"], yl, label_dict[\"label_width\"],\n                        self.track_data[\"line_width\"], fill=1, stroke=0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"colour_legend_label_colour\", self.prms))\n            canvas.drawString(label_dict[\"label_x\"], yt, label_dict[\"label\"])\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a colour legend track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.CrossTrack","title":"<code>CrossTrack</code>","text":"<p>Parent class for Cross-Tracks visualisation.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class CrossTrack:\n    \"\"\"Parent class for Cross-Tracks visualisation.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout, tracks, parameters):\n        \"\"\"Parent's constructor for creating a CrossTrack object.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            tracks (dict): List with track objects participated in CrossTrack.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.layout = layout\n        self.tracks = tracks\n        self.prms = parameters\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas):\n        \"\"\"Empy parent's method for cross track drawing.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.CrossTrack.__init__","title":"<code>__init__(layout, tracks, parameters)</code>","text":"<p>Parent's constructor for creating a CrossTrack object.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout, tracks, parameters):\n    \"\"\"Parent's constructor for creating a CrossTrack object.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.layout = layout\n    self.tracks = tracks\n    self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.CrossTrack.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for cross track drawing.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas):\n    \"\"\"Empy parent's method for cross track drawing.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.HomologyTrack","title":"<code>HomologyTrack</code>","text":"<p>             Bases: <code>CrossTrack</code></p> <p>Track that handle visualisation of homology lines between homologous features on neighbours' loci.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class HomologyTrack(CrossTrack):\n    \"\"\"Track that handle visualisation of homology lines between homologous features on neighbours' loci.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout, tracks, parameters):\n        \"\"\"Create a HomologyTrack.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            tracks (dict): List with track objects participated in CrossTrack.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(layout, tracks, parameters)\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw HomologyTrack on canvas.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for track in self.tracks:\n                track.track_data[\"y_top\"] = self.layout[\"figure_height\"] - track.layout[\"inverse_y_coordinate\"]\n                track.track_data[\"feature_upper\"] = track.track_data[\"y_top\"] - \\\n                                                    (track.track_data[\"n_label_rows\"] * track.track_data[\n                                                        \"f_label_height\"] *\n                                                     (1 + track.prms.args[\"feature_label_gap\"]))\n            num_of_loci_tracks = len(self.tracks)\n            for ti in range(num_of_loci_tracks - 1):\n                current_track = self.tracks[ti]\n                current_track_features = current_track.track_data[\"features\"]\n                next_track = self.tracks[ti + 1]\n                next_track_features = next_track.track_data[\"features\"]\n                for ctf in current_track_features:\n                    ctf_group = ctf[\"group\"]\n                    next_track_same_group_features = [i for i in next_track_features if i[\"group\"] == ctf_group]\n                    for ntf in next_track_same_group_features:\n                        cty_u = current_track.track_data[\"feature_upper\"]\n                        cty_c = current_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                        cty_b = current_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                        nty_u = next_track.track_data[\"feature_upper\"]\n                        nty_c = next_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                        nty_b = next_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                        ct_arrow_len = min(\n                            self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                            (ctf[\"coordinates\"][\"end\"] - ctf[\"coordinates\"][\"start\"]))\n                        nt_arrow_len = min(\n                            self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                            (ntf[\"coordinates\"][\"end\"] - ntf[\"coordinates\"][\"start\"]))\n                        canvas.setLineCap(0)\n                        canvas.setLineJoin(1)\n                        canvas.setLineWidth(self.prms.args[\"homology_line_width\"])\n                        canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_stroke_colour\", self.prms))\n                        canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_fill_colour\", self.prms))\n                        p = canvas.beginPath()\n\n                        if ctf[\"coordinates\"][\"orient\"] == 1:\n                            cts, cte = ctf[\"coordinates\"][\"start\"], ctf[\"coordinates\"][\"end\"]\n                            p.moveTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                            if not ctf[\"coordinates\"][\"rout\"]:\n                                p.lineTo(ctf[\"coordinates\"][\"end\"] - ct_arrow_len, cty_b)\n                                p.lineTo(ctf[\"coordinates\"][\"end\"], cty_c)\n                            else:\n                                p.lineTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                        elif ctf[\"coordinates\"][\"orient\"] == -1:\n                            cts, cte = ctf[\"coordinates\"][\"end\"], ctf[\"coordinates\"][\"start\"]\n                            p.moveTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                            if not ctf[\"coordinates\"][\"lout\"]:\n                                p.lineTo(ctf[\"coordinates\"][\"start\"] + ct_arrow_len, cty_b)\n                                p.lineTo(ctf[\"coordinates\"][\"start\"], cty_c)\n                            else:\n                                p.lineTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                        if ntf[\"coordinates\"][\"orient\"] == 1:\n                            nts, nte = ntf[\"coordinates\"][\"end\"], ntf[\"coordinates\"][\"start\"]\n                            if not ntf[\"coordinates\"][\"rout\"]:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                                p.lineTo(ntf[\"coordinates\"][\"end\"] - nt_arrow_len, nty_u)\n                            else:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                            if nte &gt;= cts:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                        elif ntf[\"coordinates\"][\"orient\"] == -1:\n                            nts, nte = ntf[\"coordinates\"][\"start\"], ntf[\"coordinates\"][\"end\"]\n                            if not ntf[\"coordinates\"][\"lout\"]:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                                p.lineTo(ntf[\"coordinates\"][\"start\"] + nt_arrow_len, nty_u)\n                            else:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                            if nte &lt;= cts:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                        if (nte &lt;= cts and ctf[\"coordinates\"][\"orient\"] == 1) or (\n                                nte &gt;= cts and ctf[\"coordinates\"][\"orient\"] == -1):\n                            p.lineTo(cts, cty_c)\n                        p.lineTo(cts, cty_b)\n                        canvas.drawPath(p, stroke=1, fill=1)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw homology line track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.HomologyTrack.__init__","title":"<code>__init__(layout, tracks, parameters)</code>","text":"<p>Create a HomologyTrack.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout, tracks, parameters):\n    \"\"\"Create a HomologyTrack.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(layout, tracks, parameters)\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.HomologyTrack.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw HomologyTrack on canvas.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw HomologyTrack on canvas.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for track in self.tracks:\n            track.track_data[\"y_top\"] = self.layout[\"figure_height\"] - track.layout[\"inverse_y_coordinate\"]\n            track.track_data[\"feature_upper\"] = track.track_data[\"y_top\"] - \\\n                                                (track.track_data[\"n_label_rows\"] * track.track_data[\n                                                    \"f_label_height\"] *\n                                                 (1 + track.prms.args[\"feature_label_gap\"]))\n        num_of_loci_tracks = len(self.tracks)\n        for ti in range(num_of_loci_tracks - 1):\n            current_track = self.tracks[ti]\n            current_track_features = current_track.track_data[\"features\"]\n            next_track = self.tracks[ti + 1]\n            next_track_features = next_track.track_data[\"features\"]\n            for ctf in current_track_features:\n                ctf_group = ctf[\"group\"]\n                next_track_same_group_features = [i for i in next_track_features if i[\"group\"] == ctf_group]\n                for ntf in next_track_same_group_features:\n                    cty_u = current_track.track_data[\"feature_upper\"]\n                    cty_c = current_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                    cty_b = current_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                    nty_u = next_track.track_data[\"feature_upper\"]\n                    nty_c = next_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                    nty_b = next_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                    ct_arrow_len = min(\n                        self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                        (ctf[\"coordinates\"][\"end\"] - ctf[\"coordinates\"][\"start\"]))\n                    nt_arrow_len = min(\n                        self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                        (ntf[\"coordinates\"][\"end\"] - ntf[\"coordinates\"][\"start\"]))\n                    canvas.setLineCap(0)\n                    canvas.setLineJoin(1)\n                    canvas.setLineWidth(self.prms.args[\"homology_line_width\"])\n                    canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_stroke_colour\", self.prms))\n                    canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_fill_colour\", self.prms))\n                    p = canvas.beginPath()\n\n                    if ctf[\"coordinates\"][\"orient\"] == 1:\n                        cts, cte = ctf[\"coordinates\"][\"start\"], ctf[\"coordinates\"][\"end\"]\n                        p.moveTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                        if not ctf[\"coordinates\"][\"rout\"]:\n                            p.lineTo(ctf[\"coordinates\"][\"end\"] - ct_arrow_len, cty_b)\n                            p.lineTo(ctf[\"coordinates\"][\"end\"], cty_c)\n                        else:\n                            p.lineTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                    elif ctf[\"coordinates\"][\"orient\"] == -1:\n                        cts, cte = ctf[\"coordinates\"][\"end\"], ctf[\"coordinates\"][\"start\"]\n                        p.moveTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                        if not ctf[\"coordinates\"][\"lout\"]:\n                            p.lineTo(ctf[\"coordinates\"][\"start\"] + ct_arrow_len, cty_b)\n                            p.lineTo(ctf[\"coordinates\"][\"start\"], cty_c)\n                        else:\n                            p.lineTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                    if ntf[\"coordinates\"][\"orient\"] == 1:\n                        nts, nte = ntf[\"coordinates\"][\"end\"], ntf[\"coordinates\"][\"start\"]\n                        if not ntf[\"coordinates\"][\"rout\"]:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                            p.lineTo(ntf[\"coordinates\"][\"end\"] - nt_arrow_len, nty_u)\n                        else:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                        p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                        if nte &gt;= cts:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                    elif ntf[\"coordinates\"][\"orient\"] == -1:\n                        nts, nte = ntf[\"coordinates\"][\"start\"], ntf[\"coordinates\"][\"end\"]\n                        if not ntf[\"coordinates\"][\"lout\"]:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                            p.lineTo(ntf[\"coordinates\"][\"start\"] + nt_arrow_len, nty_u)\n                        else:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                        p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                        if nte &lt;= cts:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                    if (nte &lt;= cts and ctf[\"coordinates\"][\"orient\"] == 1) or (\n                            nte &gt;= cts and ctf[\"coordinates\"][\"orient\"] == -1):\n                        p.lineTo(cts, cty_c)\n                    p.lineTo(cts, cty_b)\n                    canvas.drawPath(p, stroke=1, fill=1)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw homology line track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.LocusVis","title":"<code>LocusVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>LocusVis track object that handles each locus visualisation.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class LocusVis(Track):\n    \"\"\"LocusVis track object that handles each locus visualisation.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a LocusVis object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a LocusVis track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_track_bottom = self.layout[\"current_y_coordinate\"]  - self.track_data[\"track_height\"]\n            feature_height = self.prms.args[\"feature_height\"] * mm\n            y_feature_upper = self.layout[\"current_y_coordinate\"] - (self.track_data[\"n_label_rows\"] *\n                                                                     self.track_data[\"f_label_height\"] *\n                                                                     (1 + self.prms.args[\"feature_label_gap\"]))\n            y_feature_bottom = y_feature_upper - feature_height\n            y_feature_center = y_feature_upper - feature_height * 0.5\n\n            # Sequence label\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"locus_label_colour\", self.prms))\n            canvas.setFont(self.prms.args[\"locus_label_description_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                    label_bottom = y_feature_upper - self.prms.args[\"locus_label_height\"]\n                    canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                           self.track_data[\"locus_description\"])\n                    label_bottom = y_feature_bottom\n                else:\n                    label_bottom = y_feature_bottom + (feature_height - self.prms.args[\"locus_label_height\"]) * 0.5\n                    label = self.track_data[\"locus_description\"]\n                if self.prms.args[\"locus_label_style\"] != \"description\":\n                    label = self.track_data[\"locus_id\"]\n                    canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n                canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom, label)\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                label_bottom = y_track_bottom\n                current_left = self.layout[\"locus_label_left_border\"]\n                if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                    canvas.drawString(current_left, label_bottom, self.track_data[\"locus_description\"])\n                    current_left += self.track_data[\"locus_description_width\"] + self.track_data[\"two_space_width\"]\n                canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n                canvas.drawString(current_left, label_bottom, self.track_data[\"locus_id\"])\n                current_left += self.track_data[\"locus_id_width\"] + self.track_data[\"two_space_width\"]\n                canvas.drawString(current_left, label_bottom, self.track_data[\"text_coordinates\"])\n\n            # Middle line\n            if self.prms.args[\"draw_middle_line\"]:\n                canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n                canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                canvas.setLineCap(0)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                p = canvas.beginPath()\n                for md_line_coordinates in self.track_data[\"middle_line_coordinates\"]:\n                    p.moveTo(md_line_coordinates[\"start\"], y_feature_center)\n                    p.lineTo(md_line_coordinates[\"end\"], y_feature_center)\n                canvas.drawPath(p, stroke=1, fill=0)\n\n            # Category annotation\n            if self.track_data[\"functions_coordinates\"]:\n                for feature_function, ff_region in self.track_data[\"functions_coordinates\"].items():\n                    feature_colour = self.track_data[\"category_colours\"][feature_function]\n                    canvas.setFillColorRGB(*matplotlib.colors.hex2color(feature_colour),\n                                           self.prms.args[\"category_annotation_alpha\"])\n                    canvas.setLineJoin(1)\n                    y_upper_sausage = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n                    y_bottom_sausage = y_upper_sausage - self.prms.args[\"category_annotation_line_width\"] * mm\n                    for ffr in ff_region:\n                        p = canvas.beginPath()\n                        p.moveTo(ffr[0], y_bottom_sausage)\n                        p.lineTo(ffr[0], y_upper_sausage)\n                        p.lineTo(ffr[1], y_upper_sausage)\n                        p.lineTo(ffr[1], y_bottom_sausage)\n                        p.lineTo(ffr[0], y_bottom_sausage)\n                        p.close()\n                        canvas.drawPath(p, stroke=0, fill=1)\n            # Features\n            canvas.setLineCap(0)\n            canvas.setLineJoin(1)\n            canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n            if self.track_data[\"clean_features_coordinates\"]:\n                for f_data in self.track_data[\"features\"]:\n                    f_data_copy = copy.deepcopy(f_data)\n                    f_data_copy[\"stroke_colour\"] = None\n                    f_data_copy[\"fill_colour\"] = (*matplotlib.colors.hex2color(self.prms.args[\"palette\"][\"white\"]), 1)\n                    self.__plot_cds_feature(canvas, f_data_copy, y_center=y_feature_center, height=feature_height)\n            for f_data in self.track_data[\"features\"]:\n                f_data[\"stroke_colour\"] = *matplotlib.colors.hex2color(f_data[\"stroke_colour\"]), self.prms.args[\n                    \"feature_stroke_colour_alpha\"]\n                f_data[\"fill_colour\"] = *matplotlib.colors.hex2color(f_data[\"fill_colour\"]), self.prms.args[\n                    \"feature_fill_colour_alpha\"]\n                self.__plot_cds_feature(canvas, f_data, y_center=y_feature_center, height=feature_height)\n                if f_data[\"label_width\"]:\n                    canvas.setFillColorRGB(*f_data[\"stroke_colour\"])\n                    canvas.setFont(self.prms.args[\"feature_label_font_face\"],\n                                   self.track_data[\"f_label_font_size\"])\n                    fx_center = f_data[\"coordinates\"][\"center\"]\n                    canvas.drawString(f_data[\"label_position\"][0], f_data[\"label_y_bottom\"] + y_feature_upper,\n                                      f_data[\"label\"])\n                    canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n                    underline_colour = f_data[\"stroke_colour\"]\n                    canvas.setStrokeColorRGB(*underline_colour)\n                    canvas.setLineCap(1)\n                    if f_data[\"label_row\"] &gt; 0:\n                        p = canvas.beginPath()\n                        for ls, le in f_data[\"label_line_coordinates\"]:\n                            p.moveTo(fx_center, ls + y_feature_upper)\n                            p.lineTo(fx_center, le + y_feature_upper)\n                        canvas.drawPath(p, stroke=1, fill=0)\n                        l_start = f_data[\"coordinates\"][\"start\"]\n                        l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                        l_end = f_data[\"coordinates\"][\"end\"]\n                        ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                        canvas.line(l_start, ly, l_end, ly)\n                    else:\n                        overlapping = min(f_data[\"coordinates\"][\"end\"], f_data[\"label_position\"][1]) - (\n                            max(f_data[\"coordinates\"][\"start\"], f_data[\"label_position\"][0]))\n                        if overlapping / (f_data[\"label_position\"][1] - f_data[\"label_position\"][0]) &lt; 1:\n                            l_start = max(f_data[\"coordinates\"][\"start\"], fx_center -\n                                          self.track_data[\"feature_label_gap\"])\n                            l_start = f_data[\"coordinates\"][\"start\"]\n                            l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                            l_end = f_data[\"coordinates\"][\"end\"]\n                            ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                            canvas.line(l_start, ly, l_end, ly)\n            # Axis ticks\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n                canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                canvas.setLineCap(1)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                canvas.setFont(self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                               self.track_data[\"x_axis_annotation\"][\"label_size\"])\n                axis_line_y_coordinate = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n                axis_tick_height = self.prms.args[\"x_axis_ticks_height\"] * mm\n                axis_tick_label_y_coordinate = axis_line_y_coordinate - self.prms.args[\"x_axis_ticks_height\"] * \\\n                                               1.3 * mm - self.prms.args[\"x_axis_ticks_labels_height\"] * mm\n                for ati in range(len(self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"])):\n                    tick_coordinate = self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"][ati]\n                    tick_label_position = self.track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"][ati]\n                    tick_label = self.track_data[\"x_axis_annotation\"][\"axis_tics_labels\"][ati]\n                    canvas.drawCentredString(tick_label_position, axis_tick_label_y_coordinate, tick_label)\n                    canvas.line(tick_coordinate, axis_line_y_coordinate, tick_coordinate,\n                                axis_line_y_coordinate - axis_tick_height)\n                for region in self.track_data[\"x_axis_annotation\"][\"axis_regions\"]:\n                    canvas.setLineCap(0)\n                    canvas.line(region[\"start\"], axis_line_y_coordinate, region[\"end\"], axis_line_y_coordinate)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a Locus track.\") from error\n\n    def __plot_cds_feature(self, canvas: reportlab.pdfgen.canvas.Canvas, feature_data: dict, y_center: float,\n                           height: float) -&gt; None:\n        \"\"\"Helper method to plot feature polygone\n\n        Returns:\n            None\n\n        \"\"\"\n        x_start = feature_data[\"coordinates\"][\"start\"]\n        x_end = feature_data[\"coordinates\"][\"end\"]\n        orientation = feature_data[\"coordinates\"][\"orient\"]\n        left_out = feature_data[\"coordinates\"][\"lout\"]\n        right_out = feature_data[\"coordinates\"][\"rout\"]\n        fill_colour = feature_data[\"fill_colour\"]\n        stroke_colour = feature_data[\"stroke_colour\"]\n        y_center = y_center\n        height = height\n\n        canvas.setLineCap(0)\n        canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n        arrow_length = min(height * self.prms.args[\"feature_arrow_length\"], (x_end - x_start))\n        p = canvas.beginPath()\n        if orientation == 1:\n            if right_out:\n                p.moveTo(x_end, y_center - height / 2)\n                p.lineTo(x_start, y_center - height / 2)\n                p.lineTo(x_start, y_center + height / 2)\n                p.lineTo(x_end, y_center + height / 2)\n            else:\n                p.moveTo(x_start, y_center + height / 2)\n                p.lineTo(x_end - arrow_length, y_center + height / 2)\n                p.lineTo(x_end, y_center)\n                p.lineTo(x_end - arrow_length, y_center - height / 2)\n                p.lineTo(x_start, y_center - height / 2)\n                if not left_out:\n                    p.lineTo(x_start, y_center + height / 2)\n        elif orientation == -1:\n            if left_out:\n                p.moveTo(x_start, y_center - height / 2)\n                p.lineTo(x_end, y_center - height / 2)\n                p.lineTo(x_end, y_center + height / 2)\n                p.lineTo(x_start, y_center + height / 2)\n            else:\n                p.moveTo(x_end, y_center + height / 2)\n                p.lineTo(x_start + arrow_length, y_center + height / 2)\n                p.lineTo(x_start, y_center)\n                p.lineTo(x_start + arrow_length, y_center - height / 2)\n                p.lineTo(x_end, y_center - height / 2)\n                if not right_out:\n                    p.lineTo(x_end, y_center + height / 2)\n        if left_out and right_out:\n            p.moveTo(x_start, y_center + height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n            p.moveTo(x_start, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n        if not left_out and not right_out:\n            p.close()\n        stroke, fill = 0, 0\n        if stroke_colour:\n            canvas.setStrokeColorRGB(*stroke_colour)\n            stroke = 1\n        if fill_colour:\n            canvas.setFillColorRGB(*fill_colour)\n            fill = 1\n        canvas.drawPath(p, stroke=stroke, fill=fill)\n        return None\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.LocusVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a LocusVis object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a LocusVis object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.LocusVis.__plot_cds_feature","title":"<code>__plot_cds_feature(canvas, feature_data, y_center, height)</code>","text":"<p>Helper method to plot feature polygone</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __plot_cds_feature(self, canvas: reportlab.pdfgen.canvas.Canvas, feature_data: dict, y_center: float,\n                       height: float) -&gt; None:\n    \"\"\"Helper method to plot feature polygone\n\n    Returns:\n        None\n\n    \"\"\"\n    x_start = feature_data[\"coordinates\"][\"start\"]\n    x_end = feature_data[\"coordinates\"][\"end\"]\n    orientation = feature_data[\"coordinates\"][\"orient\"]\n    left_out = feature_data[\"coordinates\"][\"lout\"]\n    right_out = feature_data[\"coordinates\"][\"rout\"]\n    fill_colour = feature_data[\"fill_colour\"]\n    stroke_colour = feature_data[\"stroke_colour\"]\n    y_center = y_center\n    height = height\n\n    canvas.setLineCap(0)\n    canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n    arrow_length = min(height * self.prms.args[\"feature_arrow_length\"], (x_end - x_start))\n    p = canvas.beginPath()\n    if orientation == 1:\n        if right_out:\n            p.moveTo(x_end, y_center - height / 2)\n            p.lineTo(x_start, y_center - height / 2)\n            p.lineTo(x_start, y_center + height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n        else:\n            p.moveTo(x_start, y_center + height / 2)\n            p.lineTo(x_end - arrow_length, y_center + height / 2)\n            p.lineTo(x_end, y_center)\n            p.lineTo(x_end - arrow_length, y_center - height / 2)\n            p.lineTo(x_start, y_center - height / 2)\n            if not left_out:\n                p.lineTo(x_start, y_center + height / 2)\n    elif orientation == -1:\n        if left_out:\n            p.moveTo(x_start, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n            p.lineTo(x_start, y_center + height / 2)\n        else:\n            p.moveTo(x_end, y_center + height / 2)\n            p.lineTo(x_start + arrow_length, y_center + height / 2)\n            p.lineTo(x_start, y_center)\n            p.lineTo(x_start + arrow_length, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n            if not right_out:\n                p.lineTo(x_end, y_center + height / 2)\n    if left_out and right_out:\n        p.moveTo(x_start, y_center + height / 2)\n        p.lineTo(x_end, y_center + height / 2)\n        p.moveTo(x_start, y_center - height / 2)\n        p.lineTo(x_end, y_center - height / 2)\n    if not left_out and not right_out:\n        p.close()\n    stroke, fill = 0, 0\n    if stroke_colour:\n        canvas.setStrokeColorRGB(*stroke_colour)\n        stroke = 1\n    if fill_colour:\n        canvas.setFillColorRGB(*fill_colour)\n        fill = 1\n    canvas.drawPath(p, stroke=stroke, fill=fill)\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.LocusVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a LocusVis track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a LocusVis track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_track_bottom = self.layout[\"current_y_coordinate\"]  - self.track_data[\"track_height\"]\n        feature_height = self.prms.args[\"feature_height\"] * mm\n        y_feature_upper = self.layout[\"current_y_coordinate\"] - (self.track_data[\"n_label_rows\"] *\n                                                                 self.track_data[\"f_label_height\"] *\n                                                                 (1 + self.prms.args[\"feature_label_gap\"]))\n        y_feature_bottom = y_feature_upper - feature_height\n        y_feature_center = y_feature_upper - feature_height * 0.5\n\n        # Sequence label\n        canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"locus_label_colour\", self.prms))\n        canvas.setFont(self.prms.args[\"locus_label_description_font_face\"], self.prms.args[\"locus_label_font_size\"])\n        if self.prms.args[\"locus_label_position\"] == \"left\":\n            if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                label_bottom = y_feature_upper - self.prms.args[\"locus_label_height\"]\n                canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                       self.track_data[\"locus_description\"])\n                label_bottom = y_feature_bottom\n            else:\n                label_bottom = y_feature_bottom + (feature_height - self.prms.args[\"locus_label_height\"]) * 0.5\n                label = self.track_data[\"locus_description\"]\n            if self.prms.args[\"locus_label_style\"] != \"description\":\n                label = self.track_data[\"locus_id\"]\n                canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom, label)\n        elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n            label_bottom = y_track_bottom\n            current_left = self.layout[\"locus_label_left_border\"]\n            if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                canvas.drawString(current_left, label_bottom, self.track_data[\"locus_description\"])\n                current_left += self.track_data[\"locus_description_width\"] + self.track_data[\"two_space_width\"]\n            canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            canvas.drawString(current_left, label_bottom, self.track_data[\"locus_id\"])\n            current_left += self.track_data[\"locus_id_width\"] + self.track_data[\"two_space_width\"]\n            canvas.drawString(current_left, label_bottom, self.track_data[\"text_coordinates\"])\n\n        # Middle line\n        if self.prms.args[\"draw_middle_line\"]:\n            canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            canvas.setLineCap(0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            p = canvas.beginPath()\n            for md_line_coordinates in self.track_data[\"middle_line_coordinates\"]:\n                p.moveTo(md_line_coordinates[\"start\"], y_feature_center)\n                p.lineTo(md_line_coordinates[\"end\"], y_feature_center)\n            canvas.drawPath(p, stroke=1, fill=0)\n\n        # Category annotation\n        if self.track_data[\"functions_coordinates\"]:\n            for feature_function, ff_region in self.track_data[\"functions_coordinates\"].items():\n                feature_colour = self.track_data[\"category_colours\"][feature_function]\n                canvas.setFillColorRGB(*matplotlib.colors.hex2color(feature_colour),\n                                       self.prms.args[\"category_annotation_alpha\"])\n                canvas.setLineJoin(1)\n                y_upper_sausage = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n                y_bottom_sausage = y_upper_sausage - self.prms.args[\"category_annotation_line_width\"] * mm\n                for ffr in ff_region:\n                    p = canvas.beginPath()\n                    p.moveTo(ffr[0], y_bottom_sausage)\n                    p.lineTo(ffr[0], y_upper_sausage)\n                    p.lineTo(ffr[1], y_upper_sausage)\n                    p.lineTo(ffr[1], y_bottom_sausage)\n                    p.lineTo(ffr[0], y_bottom_sausage)\n                    p.close()\n                    canvas.drawPath(p, stroke=0, fill=1)\n        # Features\n        canvas.setLineCap(0)\n        canvas.setLineJoin(1)\n        canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n        if self.track_data[\"clean_features_coordinates\"]:\n            for f_data in self.track_data[\"features\"]:\n                f_data_copy = copy.deepcopy(f_data)\n                f_data_copy[\"stroke_colour\"] = None\n                f_data_copy[\"fill_colour\"] = (*matplotlib.colors.hex2color(self.prms.args[\"palette\"][\"white\"]), 1)\n                self.__plot_cds_feature(canvas, f_data_copy, y_center=y_feature_center, height=feature_height)\n        for f_data in self.track_data[\"features\"]:\n            f_data[\"stroke_colour\"] = *matplotlib.colors.hex2color(f_data[\"stroke_colour\"]), self.prms.args[\n                \"feature_stroke_colour_alpha\"]\n            f_data[\"fill_colour\"] = *matplotlib.colors.hex2color(f_data[\"fill_colour\"]), self.prms.args[\n                \"feature_fill_colour_alpha\"]\n            self.__plot_cds_feature(canvas, f_data, y_center=y_feature_center, height=feature_height)\n            if f_data[\"label_width\"]:\n                canvas.setFillColorRGB(*f_data[\"stroke_colour\"])\n                canvas.setFont(self.prms.args[\"feature_label_font_face\"],\n                               self.track_data[\"f_label_font_size\"])\n                fx_center = f_data[\"coordinates\"][\"center\"]\n                canvas.drawString(f_data[\"label_position\"][0], f_data[\"label_y_bottom\"] + y_feature_upper,\n                                  f_data[\"label\"])\n                canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n                underline_colour = f_data[\"stroke_colour\"]\n                canvas.setStrokeColorRGB(*underline_colour)\n                canvas.setLineCap(1)\n                if f_data[\"label_row\"] &gt; 0:\n                    p = canvas.beginPath()\n                    for ls, le in f_data[\"label_line_coordinates\"]:\n                        p.moveTo(fx_center, ls + y_feature_upper)\n                        p.lineTo(fx_center, le + y_feature_upper)\n                    canvas.drawPath(p, stroke=1, fill=0)\n                    l_start = f_data[\"coordinates\"][\"start\"]\n                    l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                    l_end = f_data[\"coordinates\"][\"end\"]\n                    ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                    canvas.line(l_start, ly, l_end, ly)\n                else:\n                    overlapping = min(f_data[\"coordinates\"][\"end\"], f_data[\"label_position\"][1]) - (\n                        max(f_data[\"coordinates\"][\"start\"], f_data[\"label_position\"][0]))\n                    if overlapping / (f_data[\"label_position\"][1] - f_data[\"label_position\"][0]) &lt; 1:\n                        l_start = max(f_data[\"coordinates\"][\"start\"], fx_center -\n                                      self.track_data[\"feature_label_gap\"])\n                        l_start = f_data[\"coordinates\"][\"start\"]\n                        l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                        l_end = f_data[\"coordinates\"][\"end\"]\n                        ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                        canvas.line(l_start, ly, l_end, ly)\n        # Axis ticks\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            canvas.setLineCap(1)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            canvas.setFont(self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                           self.track_data[\"x_axis_annotation\"][\"label_size\"])\n            axis_line_y_coordinate = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n            axis_tick_height = self.prms.args[\"x_axis_ticks_height\"] * mm\n            axis_tick_label_y_coordinate = axis_line_y_coordinate - self.prms.args[\"x_axis_ticks_height\"] * \\\n                                           1.3 * mm - self.prms.args[\"x_axis_ticks_labels_height\"] * mm\n            for ati in range(len(self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"])):\n                tick_coordinate = self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"][ati]\n                tick_label_position = self.track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"][ati]\n                tick_label = self.track_data[\"x_axis_annotation\"][\"axis_tics_labels\"][ati]\n                canvas.drawCentredString(tick_label_position, axis_tick_label_y_coordinate, tick_label)\n                canvas.line(tick_coordinate, axis_line_y_coordinate, tick_coordinate,\n                            axis_line_y_coordinate - axis_tick_height)\n            for region in self.track_data[\"x_axis_annotation\"][\"axis_regions\"]:\n                canvas.setLineCap(0)\n                canvas.line(region[\"start\"], axis_line_y_coordinate, region[\"end\"], axis_line_y_coordinate)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a Locus track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.ScaleVis","title":"<code>ScaleVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>ScaleVis track object that handles visualisation of scale bottom line.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class ScaleVis(Track):\n    \"\"\"ScaleVis track object that handles visualisation of scale bottom line.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a LocusVis object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n        self.track_height = None\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a ScaleVis track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_upper = self.layout[\"current_y_coordinate\"]\n            y_bottom = self.layout[\"current_y_coordinate\"] - self.track_data[\"track_height\"]\n            y_center = self.layout[\"current_y_coordinate\"] - 0.5 * self.track_data[\"track_height\"]\n\n            middle_line_x_position = np.mean(self.track_data[\"coordinates\"])\n\n            canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n            canvas.setLineCap(0)\n            canvas.setLineJoin(1)\n            if self.track_data[\"style\"] == \"fancy\":\n                tick_height = self.track_data[\"scale_line_label_height\"]\n\n                p = canvas.beginPath()\n                p.moveTo(self.track_data[\"coordinates\"][0], y_center - 0.5 * tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][0], y_center + 0.5 * tick_height)\n                p.moveTo(self.track_data[\"coordinates\"][0], y_center)\n                p.lineTo(middle_line_x_position - 0.5 * self.track_data[\"scale_line_label_width\"] -\n                         self.track_data[\"space_width\"], y_center)\n                p.moveTo(self.track_data[\"coordinates\"][1], y_center - 0.5 * tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_center + 0.5 * tick_height)\n                p.moveTo(self.track_data[\"coordinates\"][1], y_center)\n                p.lineTo(middle_line_x_position + 0.5 * self.track_data[\"scale_line_label_width\"] +\n                         self.track_data[\"space_width\"], y_center)\n            else:\n                tick_height = self.prms.args[\"scale_line_tics_height\"] * mm\n\n                p = canvas.beginPath()\n                p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][0], y_upper)\n                p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height * 0.5)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height * 0.5)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height)\n            canvas.drawPath(p, stroke=1, fill=0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n            canvas.setFont(self.prms.args[\"scale_line_label_font_face\"],\n                           self.track_data[\"scale_line_label_font_size\"])\n            canvas.drawCentredString(middle_line_x_position, y_bottom, self.track_data[\"scale_label\"])\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a scale track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.ScaleVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a LocusVis object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a LocusVis object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n    self.track_height = None\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.ScaleVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a ScaleVis track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a ScaleVis track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_upper = self.layout[\"current_y_coordinate\"]\n        y_bottom = self.layout[\"current_y_coordinate\"] - self.track_data[\"track_height\"]\n        y_center = self.layout[\"current_y_coordinate\"] - 0.5 * self.track_data[\"track_height\"]\n\n        middle_line_x_position = np.mean(self.track_data[\"coordinates\"])\n\n        canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n        canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n        canvas.setLineCap(0)\n        canvas.setLineJoin(1)\n        if self.track_data[\"style\"] == \"fancy\":\n            tick_height = self.track_data[\"scale_line_label_height\"]\n\n            p = canvas.beginPath()\n            p.moveTo(self.track_data[\"coordinates\"][0], y_center - 0.5 * tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][0], y_center + 0.5 * tick_height)\n            p.moveTo(self.track_data[\"coordinates\"][0], y_center)\n            p.lineTo(middle_line_x_position - 0.5 * self.track_data[\"scale_line_label_width\"] -\n                     self.track_data[\"space_width\"], y_center)\n            p.moveTo(self.track_data[\"coordinates\"][1], y_center - 0.5 * tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_center + 0.5 * tick_height)\n            p.moveTo(self.track_data[\"coordinates\"][1], y_center)\n            p.lineTo(middle_line_x_position + 0.5 * self.track_data[\"scale_line_label_width\"] +\n                     self.track_data[\"space_width\"], y_center)\n        else:\n            tick_height = self.prms.args[\"scale_line_tics_height\"] * mm\n\n            p = canvas.beginPath()\n            p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][0], y_upper)\n            p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height * 0.5)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height * 0.5)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height)\n        canvas.drawPath(p, stroke=1, fill=0)\n        canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n        canvas.setFont(self.prms.args[\"scale_line_label_font_face\"],\n                       self.track_data[\"scale_line_label_font_size\"])\n        canvas.drawCentredString(middle_line_x_position, y_bottom, self.track_data[\"scale_label\"])\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a scale track.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.Track","title":"<code>Track</code>","text":"<p>Parent class for visualisation Tracks.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class Track:\n    \"\"\"Parent class for visualisation Tracks.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters: lovis4u.Manager.Parameters):\n        \"\"\"Parent's constructor for creating a Track object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.layout = layout\n        self.track_data = track_data\n        self.prms = parameters\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Empy parent's method for track drawing.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.Track.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Parent's constructor for creating a Track object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters: lovis4u.Manager.Parameters):\n    \"\"\"Parent's constructor for creating a Track object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.layout = layout\n    self.track_data = track_data\n    self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.Drawing.Track.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for track drawing.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Empy parent's method for track drawing.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Canvas","title":"<code>Canvas</code>","text":"<p>An Image object holds canvas;.</p> <p>Attributes:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>canvas object of the reportlab library.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Canvas:\n    \"\"\"An Image object holds canvas;.\n\n    Attributes:\n        canvas (reportlab.pdfgen.canvas.Canvas): canvas object of the reportlab library.\n\n    \"\"\"\n\n    def __init__(self, filename: str, width: float, height: float, parameters):\n        \"\"\"Create a Canvas object.\n\n        Arguments:\n            filename (str): path and name of the output pdf.\n            width (float): width of the canvas.\n            height (float): height of the pdf.\n\n        \"\"\"\n        self.prms = parameters\n        self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n        self.canvas.setTitle(\"lovis4u output\")\n        self.canvas.setSubject(\"\ud83c\udfa8\")\n        self.canvas.setCreator(\"lovis4u | The Atkinson Lab 4U\")\n\n    def save(self) -&gt; None:\n        \"\"\"Save canvas as a pdf file.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        self.canvas.save()\n        return None\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Canvas.__init__","title":"<code>__init__(filename, width, height, parameters)</code>","text":"<p>Create a Canvas object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>path and name of the output pdf.</p> </li> <li> <code>width</code>             (<code>float</code>)         \u2013          <p>width of the canvas.</p> </li> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>height of the pdf.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, filename: str, width: float, height: float, parameters):\n    \"\"\"Create a Canvas object.\n\n    Arguments:\n        filename (str): path and name of the output pdf.\n        width (float): width of the canvas.\n        height (float): height of the pdf.\n\n    \"\"\"\n    self.prms = parameters\n    self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n    self.canvas.setTitle(\"lovis4u output\")\n    self.canvas.setSubject(\"\ud83c\udfa8\")\n    self.canvas.setCreator(\"lovis4u | The Atkinson Lab 4U\")\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Canvas.save","title":"<code>save()</code>","text":"<p>Save canvas as a pdf file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save canvas as a pdf file.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not os.path.exists(self.prms.args[\"output_dir\"]):\n        os.mkdir(self.prms.args[\"output_dir\"])\n    self.canvas.save()\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager","title":"<code>CanvasManager</code>","text":"<p>Canvas manager object responsible for preprocessing data for visualisation and interaction between visualisation     and raw data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Defines size and coordinate system of a canvas.</p> </li> <li> <code>tracks</code>             (<code>list</code>)         \u2013          <p>List containing Track objects each of them represents visualisation unit (e.g. particular locus).</p> </li> <li> <code>cross_tracks</code>             (<code>list</code>)         \u2013          <p>List containing CrossTrack objects each of them represents visualisation unit that interacts with multiple regular Track objects.</p> </li> </ul> <pre><code>prms (Parameters): Parameters' class object that holds config and cmd arguments.\n</code></pre> Source code in <code>lovis4u/Manager.py</code> <pre><code>class CanvasManager:\n    \"\"\"Canvas manager object responsible for preprocessing data for visualisation and interaction between visualisation\n        and raw data.\n\n    Attributes:\n         layout (dict): Defines size and coordinate system of a canvas.\n         tracks (list): List containing Track objects each of them represents visualisation unit (e.g. particular locus).\n         cross_tracks (list): List containing CrossTrack objects each of them represents visualisation unit that\n            interacts with multiple regular Track objects.\n        prms (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a CanvasManager object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.layout = dict()\n        self.tracks = []\n        self.cross_tracks = []\n        self.prms = parameters\n\n    def define_layout(self, loci) -&gt; None:\n        \"\"\"Define canvas' layout based on input loci.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            annotated_descriptions = [i.description for i in loci.loci if i.description]\n            if not annotated_descriptions and self.prms.args[\"locus_label_style\"] != \"id\":\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb  Warning message: the annotation lacks description. Locus label style is \"\n                          \"changed to 'id'\")\n                self.prms.args[\"locus_label_style\"] = \"id\"\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                if self.prms.args[\"locus_label_style\"] == \"full\":\n                    label_height = self.prms.args[\"feature_height\"] * mm * 0.4\n                else:\n                    label_height = min(1, self.prms.args[\"locus_label_size\"]) * self.prms.args[\"feature_height\"] * mm\n                label_font_size = lovis4u.Methods.str_height_to_size(label_height,\n                                                                     self.prms.args[\"locus_label_id_font_face\"])\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                label_font_size = self.prms.args[\"bottom_locus_label_font_size\"]\n                label_height = lovis4u.Methods.str_font_size_to_height(label_font_size,\n                                                                       self.prms.args[\"locus_label_id_font_face\"])\n            else:\n                raise lovis4u.Manager.lovis4uError(\"Locus label position parameter should be either 'bottom' \"\n                                                   \"or 'left'.\")\n            self.prms.args[\"locus_label_height\"] = label_height\n            self.prms.args[\"locus_label_font_size\"] = label_font_size\n            max_id_string_width = max([pdfmetrics.stringWidth(i.seq_id, self.prms.args[\"locus_label_id_font_face\"],\n                                                              self.prms.args[\"locus_label_font_size\"]) for i in\n                                       loci.loci])\n            if self.prms.args[\"locus_label_style\"] != \"id\":\n                max_descr_string_width = \\\n                    max([pdfmetrics.stringWidth(i, self.prms.args[\"locus_label_description_font_face\"],\n                                                self.prms.args[\"locus_label_font_size\"])\n                         for i in annotated_descriptions])\n\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                max_label_string_width = max(max_id_string_width, max_descr_string_width)\n            elif self.prms.args[\"locus_label_style\"] == \"id\":\n                max_label_string_width = max_id_string_width\n            elif self.prms.args[\"locus_label_style\"] == \"description\":\n                max_label_string_width = max_descr_string_width\n            loci_lengths = loci.get_loci_lengths_and_n_of_regions()\n            self.layout[\"total_nt_width\"] = max(i[0] for i in loci_lengths)\n            if self.prms.args[\"figure_width\"]:\n                if self.prms.args[\"locus_label_position\"] == \"left\":\n                    figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - max_label_string_width - \\\n                                            2 * self.prms.args[\"margin\"] * mm \\\n                                            - self.prms.args[\"gap_after_locus_label\"] * mm\n                elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                    figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - 2 * self.prms.args[\"margin\"] * mm\n                self.prms.args[\"mm_per_nt\"] = mm * figure_width_for_loci / self.layout[\"total_nt_width\"]\n            else:\n                width_per_nt = self.prms.args[\"mm_per_nt\"] * mm\n                figure_width_for_loci = width_per_nt * self.layout[\"total_nt_width\"]\n                if figure_width_for_loci &lt; 8 * cm:\n                    width_per_nt = 8 * cm / self.layout[\"total_nt_width\"]\n                self.prms.args[\"mm_per_nt\"] = width_per_nt / mm\n            self.layout[\"width_per_nt\"] = self.prms.args[\"mm_per_nt\"] / mm\n            self.layout[\"x_gap_between_regions\"] = self.prms.args[\"gap_between_regions\"] * mm\n            each_loci_region_width = [\n                (i[0] * self.layout[\"width_per_nt\"]) + (i[1] * self.layout[\"x_gap_between_regions\"])\n                for i in loci_lengths]\n            max_loci_region_length = max(each_loci_region_width)\n            self.layout[\"locus_label_left_border\"] = self.prms.args[\"margin\"] * mm\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                self.layout[\"locus_label_right_border\"] = self.layout[\n                                                              \"locus_label_left_border\"] + max_label_string_width\n                self.layout[\"loci_tracks_left_border\"] = self.layout[\"locus_label_right_border\"] + \\\n                                                         self.prms.args[\"gap_after_locus_label\"] * mm\n                self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                          max_loci_region_length\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                self.layout[\"loci_tracks_left_border\"] = self.prms.args[\"margin\"] * mm\n                self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                          max_loci_region_length\n            self.layout[\"figure_width\"] = self.layout[\"loci_tracks_right_border\"] + self.prms.args[\"margin\"] * mm\n            self.layout[\"figure_height\"] = self.prms.args[\"margin\"] * mm\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define layout from loci data.\") from error\n\n    def add_loci_tracks(self, loci) -&gt; None:\n        \"\"\"Add loci tracks to your canvas.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for locus in loci.loci:\n                locus_loader = LocusLoader(self.prms)\n                locus_loader.prepare_track_specific_data(locus, self.layout.copy())\n                locus_track_height = locus_loader.calculate_track_height()\n                self.layout[\"figure_height\"] += locus_track_height + self.prms.args[\"gap\"] * mm\n                locus_track = locus_loader.create_track()\n                self.tracks.append(locus_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {len(loci.loci)} loci tracks were added to the canvas\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add loci tracks to the canvas.\") from error\n\n    def add_categories_colour_legend_track(self, loci) -&gt; None:\n        \"\"\"Add categories colour legend tracks to your canvas.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            colour_legend_loader = CategoriesColorLegendLoader(self.prms)\n            colour_legend_loader.prepare_track_specific_data(self.layout.copy(), loci)\n            colour_legend_track_height = colour_legend_loader.calculate_track_height()\n            if colour_legend_track_height != 0:\n                self.layout[\"figure_height\"] += colour_legend_track_height + self.prms.args[\"gap\"] * mm\n            colour_legend_track = colour_legend_loader.create_track()\n            if isinstance(colour_legend_track, lovis4u.Drawing.ColorLegendVis):\n                self.tracks.append(colour_legend_track)\n                if self.prms.args[\"verbose\"]:\n                    print(f\"\u29bf Categories colour legend track was added to the canvas\", file=sys.stdout)\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add categories colour legend track to the canvas.\") from error\n\n    def add_scale_line_track(self) -&gt; None:\n        \"\"\"Add scale line tracks to your canvas.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            scale_loader = ScaleLoader(self.prms)\n            scale_loader.prepare_track_specific_data(self.layout.copy())\n            scale_track_height = scale_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += scale_track_height + self.prms.args[\"gap\"] * mm\n            scale_track = scale_loader.create_track()\n            self.tracks.append(scale_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Scale line track was added to the canvas\", file=sys.stdout)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n\n    def add_homology_track(self) -&gt; None:\n        \"\"\"Add homology track to your canvas.\n\n        You should add this track after you added loci tracks.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_tracks = [i for i in self.tracks.copy() if isinstance(i, lovis4u.Drawing.LocusVis)]\n            if not loci_tracks:\n                raise lovis4u.Manager.lovis4uError(\"Unable to create homology track if no loci track was added.\")\n            for lt in loci_tracks:\n                lt.track_data[\"clean_features_coordinates\"] = True\n            self.cross_tracks.append(lovis4u.Drawing.HomologyTrack(self.layout, loci_tracks, self.prms))\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Homology track was added to the canvas\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n\n    def plot(self, filename: str) -&gt; None:\n        \"\"\"Plot all added tracks and save the plot as pdf.\n\n        Arguments:\n            filename (str): filename for the output pdf.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            file_path = os.path.join(self.prms.args[\"output_dir\"], filename)\n            self.layout[\"figure_height\"] += (self.prms.args[\"margin\"] - self.prms.args[\"gap\"]) * mm\n            plot = Canvas(file_path, self.layout[\"figure_width\"], self.layout[\"figure_height\"], self.prms)\n\n            for cross_track in self.cross_tracks:\n                cross_track.draw(plot.canvas)\n\n            current_y_coordinate = self.layout[\"figure_height\"] - self.prms.args[\"margin\"] * mm\n            for track in self.tracks:\n                track.layout[\"current_y_coordinate\"] = current_y_coordinate\n                track.layout[\"figure_height\"] = self.layout[\"figure_height\"]\n                track.draw(plot.canvas)\n                current_y_coordinate -= track.track_data[\"track_height\"] + self.prms.args[\"gap\"] * mm\n            plot.save()\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf lovis4u plot was saved as: {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to plot the canvas and save the figure.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a CanvasManager object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a CanvasManager object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.layout = dict()\n    self.tracks = []\n    self.cross_tracks = []\n    self.prms = parameters\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.add_categories_colour_legend_track","title":"<code>add_categories_colour_legend_track(loci)</code>","text":"<p>Add categories colour legend tracks to your canvas.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_categories_colour_legend_track(self, loci) -&gt; None:\n    \"\"\"Add categories colour legend tracks to your canvas.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        colour_legend_loader = CategoriesColorLegendLoader(self.prms)\n        colour_legend_loader.prepare_track_specific_data(self.layout.copy(), loci)\n        colour_legend_track_height = colour_legend_loader.calculate_track_height()\n        if colour_legend_track_height != 0:\n            self.layout[\"figure_height\"] += colour_legend_track_height + self.prms.args[\"gap\"] * mm\n        colour_legend_track = colour_legend_loader.create_track()\n        if isinstance(colour_legend_track, lovis4u.Drawing.ColorLegendVis):\n            self.tracks.append(colour_legend_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Categories colour legend track was added to the canvas\", file=sys.stdout)\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add categories colour legend track to the canvas.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.add_homology_track","title":"<code>add_homology_track()</code>","text":"<p>Add homology track to your canvas.</p> <p>You should add this track after you added loci tracks.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_homology_track(self) -&gt; None:\n    \"\"\"Add homology track to your canvas.\n\n    You should add this track after you added loci tracks.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_tracks = [i for i in self.tracks.copy() if isinstance(i, lovis4u.Drawing.LocusVis)]\n        if not loci_tracks:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create homology track if no loci track was added.\")\n        for lt in loci_tracks:\n            lt.track_data[\"clean_features_coordinates\"] = True\n        self.cross_tracks.append(lovis4u.Drawing.HomologyTrack(self.layout, loci_tracks, self.prms))\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Homology track was added to the canvas\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.add_loci_tracks","title":"<code>add_loci_tracks(loci)</code>","text":"<p>Add loci tracks to your canvas.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_loci_tracks(self, loci) -&gt; None:\n    \"\"\"Add loci tracks to your canvas.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for locus in loci.loci:\n            locus_loader = LocusLoader(self.prms)\n            locus_loader.prepare_track_specific_data(locus, self.layout.copy())\n            locus_track_height = locus_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += locus_track_height + self.prms.args[\"gap\"] * mm\n            locus_track = locus_loader.create_track()\n            self.tracks.append(locus_track)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {len(loci.loci)} loci tracks were added to the canvas\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add loci tracks to the canvas.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.add_scale_line_track","title":"<code>add_scale_line_track()</code>","text":"<p>Add scale line tracks to your canvas.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_scale_line_track(self) -&gt; None:\n    \"\"\"Add scale line tracks to your canvas.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        scale_loader = ScaleLoader(self.prms)\n        scale_loader.prepare_track_specific_data(self.layout.copy())\n        scale_track_height = scale_loader.calculate_track_height()\n        self.layout[\"figure_height\"] += scale_track_height + self.prms.args[\"gap\"] * mm\n        scale_track = scale_loader.create_track()\n        self.tracks.append(scale_track)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Scale line track was added to the canvas\", file=sys.stdout)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.define_layout","title":"<code>define_layout(loci)</code>","text":"<p>Define canvas' layout based on input loci.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def define_layout(self, loci) -&gt; None:\n    \"\"\"Define canvas' layout based on input loci.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        annotated_descriptions = [i.description for i in loci.loci if i.description]\n        if not annotated_descriptions and self.prms.args[\"locus_label_style\"] != \"id\":\n            if self.prms.args[\"verbose\"]:\n                print(\"\u25cb  Warning message: the annotation lacks description. Locus label style is \"\n                      \"changed to 'id'\")\n            self.prms.args[\"locus_label_style\"] = \"id\"\n        if self.prms.args[\"locus_label_position\"] == \"left\":\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                label_height = self.prms.args[\"feature_height\"] * mm * 0.4\n            else:\n                label_height = min(1, self.prms.args[\"locus_label_size\"]) * self.prms.args[\"feature_height\"] * mm\n            label_font_size = lovis4u.Methods.str_height_to_size(label_height,\n                                                                 self.prms.args[\"locus_label_id_font_face\"])\n        elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n            label_font_size = self.prms.args[\"bottom_locus_label_font_size\"]\n            label_height = lovis4u.Methods.str_font_size_to_height(label_font_size,\n                                                                   self.prms.args[\"locus_label_id_font_face\"])\n        else:\n            raise lovis4u.Manager.lovis4uError(\"Locus label position parameter should be either 'bottom' \"\n                                               \"or 'left'.\")\n        self.prms.args[\"locus_label_height\"] = label_height\n        self.prms.args[\"locus_label_font_size\"] = label_font_size\n        max_id_string_width = max([pdfmetrics.stringWidth(i.seq_id, self.prms.args[\"locus_label_id_font_face\"],\n                                                          self.prms.args[\"locus_label_font_size\"]) for i in\n                                   loci.loci])\n        if self.prms.args[\"locus_label_style\"] != \"id\":\n            max_descr_string_width = \\\n                max([pdfmetrics.stringWidth(i, self.prms.args[\"locus_label_description_font_face\"],\n                                            self.prms.args[\"locus_label_font_size\"])\n                     for i in annotated_descriptions])\n\n        if self.prms.args[\"locus_label_style\"] == \"full\":\n            max_label_string_width = max(max_id_string_width, max_descr_string_width)\n        elif self.prms.args[\"locus_label_style\"] == \"id\":\n            max_label_string_width = max_id_string_width\n        elif self.prms.args[\"locus_label_style\"] == \"description\":\n            max_label_string_width = max_descr_string_width\n        loci_lengths = loci.get_loci_lengths_and_n_of_regions()\n        self.layout[\"total_nt_width\"] = max(i[0] for i in loci_lengths)\n        if self.prms.args[\"figure_width\"]:\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - max_label_string_width - \\\n                                        2 * self.prms.args[\"margin\"] * mm \\\n                                        - self.prms.args[\"gap_after_locus_label\"] * mm\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - 2 * self.prms.args[\"margin\"] * mm\n            self.prms.args[\"mm_per_nt\"] = mm * figure_width_for_loci / self.layout[\"total_nt_width\"]\n        else:\n            width_per_nt = self.prms.args[\"mm_per_nt\"] * mm\n            figure_width_for_loci = width_per_nt * self.layout[\"total_nt_width\"]\n            if figure_width_for_loci &lt; 8 * cm:\n                width_per_nt = 8 * cm / self.layout[\"total_nt_width\"]\n            self.prms.args[\"mm_per_nt\"] = width_per_nt / mm\n        self.layout[\"width_per_nt\"] = self.prms.args[\"mm_per_nt\"] / mm\n        self.layout[\"x_gap_between_regions\"] = self.prms.args[\"gap_between_regions\"] * mm\n        each_loci_region_width = [\n            (i[0] * self.layout[\"width_per_nt\"]) + (i[1] * self.layout[\"x_gap_between_regions\"])\n            for i in loci_lengths]\n        max_loci_region_length = max(each_loci_region_width)\n        self.layout[\"locus_label_left_border\"] = self.prms.args[\"margin\"] * mm\n        if self.prms.args[\"locus_label_position\"] == \"left\":\n            self.layout[\"locus_label_right_border\"] = self.layout[\n                                                          \"locus_label_left_border\"] + max_label_string_width\n            self.layout[\"loci_tracks_left_border\"] = self.layout[\"locus_label_right_border\"] + \\\n                                                     self.prms.args[\"gap_after_locus_label\"] * mm\n            self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                      max_loci_region_length\n        elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n            self.layout[\"loci_tracks_left_border\"] = self.prms.args[\"margin\"] * mm\n            self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                      max_loci_region_length\n        self.layout[\"figure_width\"] = self.layout[\"loci_tracks_right_border\"] + self.prms.args[\"margin\"] * mm\n        self.layout[\"figure_height\"] = self.prms.args[\"margin\"] * mm\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define layout from loci data.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CanvasManager.plot","title":"<code>plot(filename)</code>","text":"<p>Plot all added tracks and save the plot as pdf.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>filename for the output pdf.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def plot(self, filename: str) -&gt; None:\n    \"\"\"Plot all added tracks and save the plot as pdf.\n\n    Arguments:\n        filename (str): filename for the output pdf.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        file_path = os.path.join(self.prms.args[\"output_dir\"], filename)\n        self.layout[\"figure_height\"] += (self.prms.args[\"margin\"] - self.prms.args[\"gap\"]) * mm\n        plot = Canvas(file_path, self.layout[\"figure_width\"], self.layout[\"figure_height\"], self.prms)\n\n        for cross_track in self.cross_tracks:\n            cross_track.draw(plot.canvas)\n\n        current_y_coordinate = self.layout[\"figure_height\"] - self.prms.args[\"margin\"] * mm\n        for track in self.tracks:\n            track.layout[\"current_y_coordinate\"] = current_y_coordinate\n            track.layout[\"figure_height\"] = self.layout[\"figure_height\"]\n            track.draw(plot.canvas)\n            current_y_coordinate -= track.track_data[\"track_height\"] + self.prms.args[\"gap\"] * mm\n        plot.save()\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf lovis4u plot was saved as: {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to plot the canvas and save the figure.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CategoriesColorLegendLoader","title":"<code>CategoriesColorLegendLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A CategoriesColorLegendLoader object prepares data for a categories colour legend track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class CategoriesColorLegendLoader(Loader):\n    \"\"\"A CategoriesColorLegendLoader object prepares data for a categories colour legend track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a CategoriesColorLegendLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, layout: dict, loci) -&gt; None:\n        \"\"\"Prepare ScaleLoader specific data.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            self.track_data = dict()\n            label_height = lovis4u.Methods.str_font_size_to_height(\n                self.prms.args[\"colour_legend_label_font_size\"], self.prms.args[\"colour_legend_font_face\"])\n            line_width = self.prms.args[\"colour_legend_line_width\"] * mm\n            line_gap = 0.4 * label_height\n            self.track_data[\"line_width\"] = line_width\n            self.track_data[\"colour_legend_label_size\"] = self.prms.args[\"colour_legend_label_font_size\"]\n            left_border = self.layout[\"loci_tracks_left_border\"]\n            right_border = self.layout[\"loci_tracks_right_border\"]\n            x_gap = pdfmetrics.stringWidth(\" \" * 5, self.prms.args[\"colour_legend_font_face\"],\n                                           self.track_data[\"colour_legend_label_size\"])\n            y_gap = 0.5 * label_height\n            colour_dict = dict()\n            for locus in loci.loci:\n                colour_dict.update(locus.category_colours)\n            self.track_data[\"labels\"] = []\n            current_x = left_border\n            n_of_rows = 0\n            current_y = - (label_height + line_gap + line_width)\n            for label, colour in colour_dict.items():\n                label_dict = dict()\n                label_width = pdfmetrics.stringWidth(label, self.prms.args[\"colour_legend_font_face\"],\n                                                     self.track_data[\"colour_legend_label_size\"])\n                label_end = current_x + label_width\n                if label_end &gt; right_border:\n                    current_x = left_border\n                    current_y -= (label_height + line_gap + line_width + y_gap)\n                    n_of_rows += 1\n                label_dict[\"label_x\"] = current_x\n                label_dict[\"label_width\"] = label_width\n                label_dict[\"relative_y\"] = current_y\n                label_dict[\"relative_y_text\"] = current_y + line_gap + line_width\n                label_dict[\"colour\"] = colour\n                label_dict[\"label\"] = label\n                self.track_data[\"labels\"].append(label_dict)\n                current_x = label_dict[\"label_x\"] + label_width + x_gap\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare categories colour legend track specific data.\") \\\n                from error\n\n    def calculate_track_height(self):\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            if self.track_data[\"labels\"]:\n                min_relative_y = min([i[\"relative_y\"] for i in self.track_data[\"labels\"]])\n                track_height = abs(min_relative_y)\n            else:\n                track_height = 0\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a categories colour legend track height.\") \\\n                from error\n\n    def create_track(self):\n        \"\"\"Initialise a ColorLegendVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis | None: visualisation track.\n\n        \"\"\"\n        try:\n            if self.track_data[\"labels\"]:\n                return lovis4u.Drawing.ColorLegendVis(self.layout, self.track_data, self.prms)\n            else:\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb Warning message: Category colours legend track cannot be created since there is no \"\n                          \"categories.\", file=sys.stdout)\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a categories colour legend track track object.\") \\\n                from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CategoriesColorLegendLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a CategoriesColorLegendLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a CategoriesColorLegendLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CategoriesColorLegendLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code>        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self):\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        if self.track_data[\"labels\"]:\n            min_relative_y = min([i[\"relative_y\"] for i in self.track_data[\"labels\"]])\n            track_height = abs(min_relative_y)\n        else:\n            track_height = 0\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a categories colour legend track height.\") \\\n            from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CategoriesColorLegendLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a ColorLegendVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis | None: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a ColorLegendVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis | None: visualisation track.\n\n    \"\"\"\n    try:\n        if self.track_data[\"labels\"]:\n            return lovis4u.Drawing.ColorLegendVis(self.layout, self.track_data, self.prms)\n        else:\n            if self.prms.args[\"verbose\"]:\n                print(\"\u25cb Warning message: Category colours legend track cannot be created since there is no \"\n                      \"categories.\", file=sys.stdout)\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a categories colour legend track track object.\") \\\n            from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.CategoriesColorLegendLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(layout, loci)</code>","text":"<p>Prepare ScaleLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, layout: dict, loci) -&gt; None:\n    \"\"\"Prepare ScaleLoader specific data.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        self.track_data = dict()\n        label_height = lovis4u.Methods.str_font_size_to_height(\n            self.prms.args[\"colour_legend_label_font_size\"], self.prms.args[\"colour_legend_font_face\"])\n        line_width = self.prms.args[\"colour_legend_line_width\"] * mm\n        line_gap = 0.4 * label_height\n        self.track_data[\"line_width\"] = line_width\n        self.track_data[\"colour_legend_label_size\"] = self.prms.args[\"colour_legend_label_font_size\"]\n        left_border = self.layout[\"loci_tracks_left_border\"]\n        right_border = self.layout[\"loci_tracks_right_border\"]\n        x_gap = pdfmetrics.stringWidth(\" \" * 5, self.prms.args[\"colour_legend_font_face\"],\n                                       self.track_data[\"colour_legend_label_size\"])\n        y_gap = 0.5 * label_height\n        colour_dict = dict()\n        for locus in loci.loci:\n            colour_dict.update(locus.category_colours)\n        self.track_data[\"labels\"] = []\n        current_x = left_border\n        n_of_rows = 0\n        current_y = - (label_height + line_gap + line_width)\n        for label, colour in colour_dict.items():\n            label_dict = dict()\n            label_width = pdfmetrics.stringWidth(label, self.prms.args[\"colour_legend_font_face\"],\n                                                 self.track_data[\"colour_legend_label_size\"])\n            label_end = current_x + label_width\n            if label_end &gt; right_border:\n                current_x = left_border\n                current_y -= (label_height + line_gap + line_width + y_gap)\n                n_of_rows += 1\n            label_dict[\"label_x\"] = current_x\n            label_dict[\"label_width\"] = label_width\n            label_dict[\"relative_y\"] = current_y\n            label_dict[\"relative_y_text\"] = current_y + line_gap + line_width\n            label_dict[\"colour\"] = colour\n            label_dict[\"label\"] = label\n            self.track_data[\"labels\"].append(label_dict)\n            current_x = label_dict[\"label_x\"] + label_width + x_gap\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare categories colour legend track specific data.\") \\\n            from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Loader","title":"<code>Loader</code>","text":"<p>Parent class for tracks loaders.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Loader:\n    \"\"\"Parent class for tracks loaders.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters: Parameters):\n        \"\"\"Parent's constructor for creating a Loader class object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.prms = parameters\n        self.layout = None\n        self.track_data = None\n\n    def prepare_track_specific_data(self) -&gt; None:\n        \"\"\"Empty parent's method for data preparation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def calculate_track_height(self) -&gt; None:\n        \"\"\"Empty parent's method for track height calculation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def create_track(self) -&gt; None:\n        \"\"\"Empty parent's method for track initialisation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Loader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Parent's constructor for creating a Loader class object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters: Parameters):\n    \"\"\"Parent's constructor for creating a Loader class object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.prms = parameters\n    self.layout = None\n    self.track_data = None\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Loader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Empty parent's method for track height calculation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self) -&gt; None:\n    \"\"\"Empty parent's method for track height calculation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Loader.create_track","title":"<code>create_track()</code>","text":"<p>Empty parent's method for track initialisation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self) -&gt; None:\n    \"\"\"Empty parent's method for track initialisation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Loader.prepare_track_specific_data","title":"<code>prepare_track_specific_data()</code>","text":"<p>Empty parent's method for data preparation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self) -&gt; None:\n    \"\"\"Empty parent's method for data preparation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.LocusLoader","title":"<code>LocusLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A LocusLoader object prepares data for a Locus track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class LocusLoader(Loader):\n    \"\"\"A LocusLoader object prepares data for a Locus track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a LocusLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, locus, layout: dict) -&gt; None:\n        \"\"\"Prepare LocusLoader specific data.\n\n        Attributes:\n            locus (lovis4u.DataProcessing.Locus): corresponding locus object.\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            layout[\"inverse_y_coordinate\"] = layout[\"figure_height\"]\n            track_data = dict()\n            self.track_data = track_data\n            track_data[\"locus_id_width\"] = pdfmetrics.stringWidth(locus.seq_id,\n                                                                  self.prms.args[\"locus_label_id_font_face\"],\n                                                                  self.prms.args[\"locus_label_font_size\"])\n            two_space_width = pdfmetrics.stringWidth(\"  \", self.prms.args[\"locus_label_id_font_face\"],\n                                                     self.prms.args[\"locus_label_font_size\"])\n            track_data[\"two_space_width\"] = two_space_width\n            track_data[\"locus_id\"] = locus.seq_id\n            track_data[\"locus_description\"] = locus.description\n            if locus.description:\n                track_data[\"locus_description_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                               self.prms.args[\"locus_label_description\"\n                                                                                              \"_font_face\"],\n                                                                               self.prms.args[\"locus_label_font_size\"])\n            if self.prms.args[\"locus_label_position\"] == \"bottom\":\n                txt_coordinates = []\n                for i in range(len(locus.coordinates)):\n                    cc = locus.coordinates[i].copy()\n                    cc_txt = f\"{cc['start']}:{cc['end']}{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                    if i &gt; 0 and locus.circular:\n                        if cc[\"start\"] == 1 and locus.coordinates[i - 1][\"end\"] == locus.length:\n                            txt_coordinates[-1] = f\"{locus.coordinates[i - 1]['start']}:{cc['end']}\" \\\n                                                  f\"{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                            continue\n                    txt_coordinates.append(cc_txt)\n                track_data[\"text_coordinates\"] = \", \".join(txt_coordinates)\n                track_data[\"text_coordinates_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                              self.prms.args[\n                                                                                  \"locus_label_id_font_face\"],\n                                                                              self.prms.args[\"locus_label_font_size\"])\n\n            track_data[\"f_label_font_size\"] = self.prms.args[\"feature_label_font_size\"]\n            track_data[\"f_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n                track_data[\"f_label_font_size\"], self.prms.args[\"feature_label_font_face\"])\n            track_data[\"feature_label_gap\"] = self.prms.args[\"feature_label_gap\"] * track_data[\"f_label_height\"]\n\n            # Managing features positions and parameters\n            track_data[\"clean_features_coordinates\"] = False\n            track_data[\"features\"] = []\n            features_taken_nt_coordinates = []\n            for feature in locus.features:\n                features_taken_nt_coordinates.append([feature.start, feature.end])\n                if feature.vis_prms[\"fill_colour\"] == \"default\":\n                    feature.vis_prms[\"fill_colour\"] = lovis4u.Methods.get_colour(\"feature_default_fill_colour\",\n                                                                                 self.prms)\n                if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                        feature.vis_prms[\"stroke_colour\"] == \"default\":\n                    scale_l = self.prms.args[\"feature_stroke_colour_relative_lightness\"]\n                    feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.scale_lightness(feature.vis_prms[\"fill_colour\"],\n                                                                                        scale_l)\n                elif not self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                        feature.vis_prms[\"stroke_colour\"] == \"default\":\n                    feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.get_colour(\"feature_default_stroke_colour\",\n                                                                                   self.prms)\n                f_label_width = 0\n                if feature.vis_prms[\"show_label\"] and feature.vis_prms[\"label\"]:\n                    f_label_width = pdfmetrics.stringWidth(feature.vis_prms[\"label\"],\n                                                           self.prms.args[\"feature_label_font_face\"],\n                                                           track_data[\"f_label_font_size\"])\n                feature_vis_data = feature.vis_prms\n                feature_vis_data[\"coordinates\"] = lovis4u.Methods.feature_nt_to_x_transform(feature.start, feature.end,\n                                                                                            feature.strand, locus,\n                                                                                            layout)\n                feature_vis_data[\"label_width\"] = f_label_width\n                feature_vis_data[\"feature_width\"] = feature_vis_data[\"coordinates\"][\"end\"] - \\\n                                                    feature_vis_data[\"coordinates\"][\"start\"]\n                feature_vis_data[\"group\"] = feature.group\n                track_data[\"features\"].append(feature_vis_data)\n            # Managing category visualisation\n            feature_cateregories = set([feature.category for feature in locus.features if feature.category])\n            track_data[\"functions_coordinates\"] = None\n            if feature_cateregories and locus.category_colours:\n                track_data[\"category_colours\"] = locus.category_colours\n                track_data[\"functions_coordinates\"] = dict()\n                for ff in feature_cateregories:\n                    ff_features = [feature for feature in locus.features if feature.category == ff]\n                    ff_coordinates = [[f.vis_prms[\"coordinates\"][\"start\"], f.vis_prms[\"coordinates\"][\"end\"]] for f in\n                                      ff_features]\n                    track_data[\"functions_coordinates\"][ff] = ff_coordinates\n            # Managing feature labels' positions:\n            taken_label_coordinates = collections.defaultdict(list)\n            if sum([fvd[\"show_label\"] for fvd in track_data[\"features\"]]) &gt; 0:\n                space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"feature_label_font_face\"],\n                                                     track_data[\"f_label_font_size\"])\n                sorted_features = sorted(track_data[\"features\"], key=lambda x: x[\"feature_width\"] - x[\"label_width\"],\n                                         reverse=True)\n                for fvd in [fvd for fvd in sorted_features if fvd[\"label_width\"]]:\n                    feature_center = fvd[\"coordinates\"][\"center\"]\n                    width_diff = fvd[\"label_width\"] - fvd[\"feature_width\"]\n                    left_position = [fvd[\"coordinates\"][\"start\"] - width_diff, fvd[\"coordinates\"][\"end\"]]\n                    centered_position = [feature_center - fvd[\"label_width\"] / 2,\n                                         feature_center + fvd[\"label_width\"] / 2]\n                    right_position = [fvd[\"coordinates\"][\"start\"], fvd[\"coordinates\"][\"end\"] + width_diff]\n                    for pos in [left_position, centered_position, right_position]:\n                        overlap = 0\n                        if pos[0] &lt; layout[\"loci_tracks_left_border\"]:\n                            overlap = layout[\"loci_tracks_left_border\"] - pos[0]\n                        if pos[1] &gt; layout[\"loci_tracks_right_border\"]:\n                            overlap = layout[\"loci_tracks_right_border\"] - pos[1]\n                        if overlap:\n                            pos[0] += overlap\n                            pos[1] += overlap\n                    label_position = centered_position\n                    if width_diff &gt; 0:\n                        left_pos_overlap = [of for of in track_data[\"features\"] if\n                                            (of != fvd and left_position[0] &lt; of[\"coordinates\"][\"end\"] &lt;\n                                             fvd[\"coordinates\"][\"end\"] and of[\"show_label\"])]\n                        right_pos_overlap = [of for of in track_data[\"features\"] if\n                                             (of != fvd and right_position[1] &gt; of[\"coordinates\"][\"start\"] &gt;\n                                              fvd[\"coordinates\"][\"start\"] and of[\"show_label\"])]\n                        if left_pos_overlap and not right_pos_overlap:\n                            min_n_distance = min([fvd[\"coordinates\"][\"start\"] - nf[\"coordinates\"][\"end\"]\n                                                  for nf in left_pos_overlap])\n                            if min_n_distance &lt; space_width:\n                                right_position[0] += space_width + min(0, min_n_distance)\n                                right_position[1] += space_width + min(0, min_n_distance)\n                            label_position = right_position\n                        elif not left_pos_overlap and right_pos_overlap:\n                            min_n_distance = min([nf[\"coordinates\"][\"start\"] - fvd[\"coordinates\"][\"end\"]\n                                                  for nf in right_pos_overlap])\n                            label_position = left_position\n                            if min_n_distance &lt; space_width and left_position[0] != layout[\"loci_tracks_left_border\"]:\n                                left_position[0] -= space_width\n                                left_position[1] -= space_width\n                            else:\n                                label_position = centered_position\n                        else:\n                            label_position = centered_position\n                    fvd[\"label_position\"] = label_position\n                    for label_row in range(0, len(track_data[\"features\"])):\n                        overlapped = False\n                        for taken_coordinate in taken_label_coordinates[label_row]:\n                            if taken_coordinate[0] &lt;= label_position[0] &lt;= taken_coordinate[1] or \\\n                                    taken_coordinate[0] &lt;= label_position[1] &lt;= taken_coordinate[1] or \\\n                                    label_position[0] &lt;= taken_coordinate[0] &lt;= label_position[1] or \\\n                                    label_position[0] &lt;= taken_coordinate[1] &lt;= label_position[1]:\n                                overlapped = True\n                        if not overlapped:\n                            fvd[\"label_row\"] = label_row\n                            taken_label_coordinates[label_row].append(label_position)\n                            break\n                    fvd[\"label_y_bottom\"] = track_data[\"feature_label_gap\"] + \\\n                                            (fvd[\"label_row\"] * track_data[\"f_label_height\"]) + \\\n                                            (fvd[\"label_row\"] * track_data[\"feature_label_gap\"])\n                for fvd in track_data[\"features\"]:\n                    if fvd[\"label_width\"]:\n                        if fvd[\"label_row\"] &gt; 0:\n                            taken_middle_rows = [i for i in range(fvd[\"label_row\"] - 1, -1, -1) if\n                                                 any(taken_coordinate[0] &lt;= fvd[\"coordinates\"][\"center\"] &lt;=\n                                                     taken_coordinate[1]\n                                                     for taken_coordinate in taken_label_coordinates[i])]\n                            label_line_upper = fvd[\"label_y_bottom\"] - track_data[\"feature_label_gap\"] / 2\n                            label_line_bottom = track_data[\"feature_label_gap\"] / 2\n                            label_line_coordinates = []\n                            ll_start = label_line_bottom\n                            for tmr in sorted(taken_middle_rows):\n                                tmr_start = 0.5 * track_data[\"feature_label_gap\"] + \\\n                                            (tmr * track_data[\"f_label_height\"]) + \\\n                                            (tmr * track_data[\"feature_label_gap\"])\n                                tmr_end = tmr_start + track_data[\"f_label_height\"] + \\\n                                          0.5 * track_data[\"feature_label_gap\"]\n                                label_line_coordinates.append([ll_start, tmr_start])\n                                ll_start = tmr_end\n                            label_line_coordinates.append([ll_start, label_line_upper])\n                            fvd[\"label_line_coordinates\"] = label_line_coordinates\n            track_data[\"n_label_rows\"] = sum([1 for k, v in taken_label_coordinates.items() if v])\n            # Managing middle line indicating locus borders\n            if self.prms.args[\"draw_middle_line\"]:\n                regions_for_middle_line = [[c[\"start\"], c[\"end\"]] for c in locus.coordinates]\n                for ftc in features_taken_nt_coordinates:\n                    ftcs, ftse = ftc\n                    for added_region in regions_for_middle_line:\n                        new_regions = []\n                        to_remove = False\n                        if added_region[0] &lt;= ftcs &lt;= added_region[1]:\n                            to_remove = True\n                            if ftcs &gt; added_region[0]:\n                                new_regions.append([added_region[0], ftcs - 1])\n                        if added_region[0] &lt;= ftse &lt;= added_region[1]:\n                            to_remove = True\n                            if ftse &lt; added_region[1]:\n                                new_regions.append([ftse + 1, added_region[1]])\n                        if to_remove:\n                            regions_for_middle_line.remove(added_region)\n                        regions_for_middle_line += new_regions\n                middle_line_coordinates = [lovis4u.Methods.region_nt_to_x_transform(rml[0], rml[1], locus, layout)\n                                           for rml in regions_for_middle_line]\n                track_data[\"middle_line_coordinates\"] = middle_line_coordinates\n            track_data[\"proteome_size\"] = len(locus.features)  # to change if we get other features\n            # Managing individual x axis\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                track_data[\"x_axis_annotation\"] = dict()\n                self.prms.args[\"x_axis_ticks_labels_height\"] = lovis4u.Methods.str_font_size_to_height(\n                    self.prms.args[\"x_axis_ticks_labels_font_size\"],\n                    self.prms.args[\"x_axis_ticks_labels_font_face\"]) / mm\n                track_data[\"x_axis_annotation\"][\"label_size\"] = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n                axis_regions = []\n                axis_tics_coordinates = []\n                for coordinate in locus.coordinates:\n                    axis_regions.append(lovis4u.Methods.region_nt_to_x_transform(coordinate[\"start\"], coordinate[\"end\"],\n                                                                                 locus, layout))\n                    current_tics_coordinates = [coordinate[\"start\"], coordinate[\"end\"]]\n                    axis_tics_coordinates += current_tics_coordinates\n                if len(axis_tics_coordinates) == 2:\n                    nt_range = coordinate[\"end\"] - coordinate[\"start\"]\n                    axis_tics_coordinates.append(coordinate[\"start\"] + int(0.25 * nt_range))\n                    axis_tics_coordinates.append(coordinate[\"start\"] + int(0.5 * nt_range))\n                    axis_tics_coordinates.append(coordinate[\"end\"] - int(0.25 * nt_range))\n\n                axis_tics_positions = list(map(lambda x: lovis4u.Methods.nt_to_x_transform(x, locus, layout, \"center\"),\n                                               axis_tics_coordinates))\n                sorted_tics = sorted(zip(axis_tics_positions, axis_tics_coordinates))\n                sorted_positions, sorted_coordinates = zip(*sorted_tics)\n                axis_tics_positions = list(sorted_positions)\n                axis_tics_coordinates = list(sorted_coordinates)\n                axis_tics_labels = list(map(str, axis_tics_coordinates))\n                axis_tics_label_size = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n                axis_tics_label_width = list(map(lambda x: pdfmetrics.stringWidth(x,\n                                                                                  self.prms.args[\n                                                                                      \"x_axis_ticks_labels_font_face\"],\n                                                                                  axis_tics_label_size),\n                                                 axis_tics_labels))\n\n                space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                     axis_tics_label_size)\n                tics_labels_coordinates = axis_tics_positions.copy()\n                # Shitty, refactor later\n                for t_i in range(len(axis_tics_coordinates)):\n                    label_width = axis_tics_label_width[t_i]\n                    tick_position = axis_tics_positions[t_i]\n                    if t_i == 0:\n                        tics_labels_coordinates[t_i] += label_width * 0.5\n                    elif t_i != len(axis_tics_coordinates) - 1:\n                        center_label_coordinates = [tick_position - 0.5 * label_width,\n                                                    tick_position + 0.5 * label_width]\n                        if center_label_coordinates[0] - space_width &lt;= axis_tics_positions[t_i - 1]:\n                            tics_labels_coordinates[t_i] += label_width * 0.5\n                            if axis_tics_positions[t_i] - axis_tics_positions[t_i - 1] &lt; space_width:\n                                tics_labels_coordinates[t_i] += space_width\n                        if center_label_coordinates[1] + space_width &gt;= axis_tics_positions[t_i + 1]:\n                            tics_labels_coordinates[t_i] -= label_width * 0.5\n                            if axis_tics_positions[t_i + 1] - axis_tics_positions[t_i] &lt; space_width:\n                                tics_labels_coordinates[t_i] -= space_width\n                    if tics_labels_coordinates[t_i] + label_width * 0.5 &gt; layout[\"loci_tracks_right_border\"]:\n                        tics_labels_coordinates[t_i] -= ((tics_labels_coordinates[t_i] + label_width * 0.5) -\n                                                         layout[\"loci_tracks_right_border\"])\n                track_data[\"x_axis_annotation\"][\"axis_regions\"] = axis_regions\n                track_data[\"x_axis_annotation\"][\"axis_tics_position\"] = axis_tics_positions\n                track_data[\"x_axis_annotation\"][\"axis_tics_labels\"] = axis_tics_labels\n                track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"] = tics_labels_coordinates\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare Locus specific data.\") from error\n\n    def calculate_track_height(self) -&gt; float:\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            track_height = self.prms.args[\"feature_height\"] * mm + \\\n                           (self.track_data[\"n_label_rows\"] * self.track_data[\"f_label_height\"] * \\\n                            (1 + self.prms.args[\"feature_label_gap\"]))\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                track_height += (self.prms.args[\"feature_bottom_gap\"] + self.prms.args[\"x_axis_ticks_height\"] * 1.3 + \\\n                                 self.prms.args[\"x_axis_ticks_labels_height\"]) * mm\n            elif not self.prms.args[\"draw_individual_x_axis\"] and self.track_data[\"functions_coordinates\"]:\n                track_height += (self.prms.args[\"feature_bottom_gap\"] + \\\n                                 self.prms.args[\"category_annotation_line_width\"]) * mm\n            if self.prms.args[\"locus_label_position\"] == \"bottom\":\n                track_height += self.prms.args[\"locus_label_height\"] + self.prms.args[\"feature_bottom_gap\"] * mm\n\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a locus track height.\") from error\n\n    def create_track(self):\n        \"\"\"Initialise a LocusVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis: visualisation track.\n\n        \"\"\"\n        try:\n            return lovis4u.Drawing.LocusVis(self.layout, self.track_data, self.prms)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a locus track object.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.LocusLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a LocusLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a LocusLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.LocusLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self) -&gt; float:\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        track_height = self.prms.args[\"feature_height\"] * mm + \\\n                       (self.track_data[\"n_label_rows\"] * self.track_data[\"f_label_height\"] * \\\n                        (1 + self.prms.args[\"feature_label_gap\"]))\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            track_height += (self.prms.args[\"feature_bottom_gap\"] + self.prms.args[\"x_axis_ticks_height\"] * 1.3 + \\\n                             self.prms.args[\"x_axis_ticks_labels_height\"]) * mm\n        elif not self.prms.args[\"draw_individual_x_axis\"] and self.track_data[\"functions_coordinates\"]:\n            track_height += (self.prms.args[\"feature_bottom_gap\"] + \\\n                             self.prms.args[\"category_annotation_line_width\"]) * mm\n        if self.prms.args[\"locus_label_position\"] == \"bottom\":\n            track_height += self.prms.args[\"locus_label_height\"] + self.prms.args[\"feature_bottom_gap\"] * mm\n\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a locus track height.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.LocusLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a LocusVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a LocusVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis: visualisation track.\n\n    \"\"\"\n    try:\n        return lovis4u.Drawing.LocusVis(self.layout, self.track_data, self.prms)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a locus track object.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.LocusLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(locus, layout)</code>","text":"<p>Prepare LocusLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, locus, layout: dict) -&gt; None:\n    \"\"\"Prepare LocusLoader specific data.\n\n    Attributes:\n        locus (lovis4u.DataProcessing.Locus): corresponding locus object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        layout[\"inverse_y_coordinate\"] = layout[\"figure_height\"]\n        track_data = dict()\n        self.track_data = track_data\n        track_data[\"locus_id_width\"] = pdfmetrics.stringWidth(locus.seq_id,\n                                                              self.prms.args[\"locus_label_id_font_face\"],\n                                                              self.prms.args[\"locus_label_font_size\"])\n        two_space_width = pdfmetrics.stringWidth(\"  \", self.prms.args[\"locus_label_id_font_face\"],\n                                                 self.prms.args[\"locus_label_font_size\"])\n        track_data[\"two_space_width\"] = two_space_width\n        track_data[\"locus_id\"] = locus.seq_id\n        track_data[\"locus_description\"] = locus.description\n        if locus.description:\n            track_data[\"locus_description_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                           self.prms.args[\"locus_label_description\"\n                                                                                          \"_font_face\"],\n                                                                           self.prms.args[\"locus_label_font_size\"])\n        if self.prms.args[\"locus_label_position\"] == \"bottom\":\n            txt_coordinates = []\n            for i in range(len(locus.coordinates)):\n                cc = locus.coordinates[i].copy()\n                cc_txt = f\"{cc['start']}:{cc['end']}{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                if i &gt; 0 and locus.circular:\n                    if cc[\"start\"] == 1 and locus.coordinates[i - 1][\"end\"] == locus.length:\n                        txt_coordinates[-1] = f\"{locus.coordinates[i - 1]['start']}:{cc['end']}\" \\\n                                              f\"{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                        continue\n                txt_coordinates.append(cc_txt)\n            track_data[\"text_coordinates\"] = \", \".join(txt_coordinates)\n            track_data[\"text_coordinates_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                          self.prms.args[\n                                                                              \"locus_label_id_font_face\"],\n                                                                          self.prms.args[\"locus_label_font_size\"])\n\n        track_data[\"f_label_font_size\"] = self.prms.args[\"feature_label_font_size\"]\n        track_data[\"f_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n            track_data[\"f_label_font_size\"], self.prms.args[\"feature_label_font_face\"])\n        track_data[\"feature_label_gap\"] = self.prms.args[\"feature_label_gap\"] * track_data[\"f_label_height\"]\n\n        # Managing features positions and parameters\n        track_data[\"clean_features_coordinates\"] = False\n        track_data[\"features\"] = []\n        features_taken_nt_coordinates = []\n        for feature in locus.features:\n            features_taken_nt_coordinates.append([feature.start, feature.end])\n            if feature.vis_prms[\"fill_colour\"] == \"default\":\n                feature.vis_prms[\"fill_colour\"] = lovis4u.Methods.get_colour(\"feature_default_fill_colour\",\n                                                                             self.prms)\n            if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                    feature.vis_prms[\"stroke_colour\"] == \"default\":\n                scale_l = self.prms.args[\"feature_stroke_colour_relative_lightness\"]\n                feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.scale_lightness(feature.vis_prms[\"fill_colour\"],\n                                                                                    scale_l)\n            elif not self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                    feature.vis_prms[\"stroke_colour\"] == \"default\":\n                feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.get_colour(\"feature_default_stroke_colour\",\n                                                                               self.prms)\n            f_label_width = 0\n            if feature.vis_prms[\"show_label\"] and feature.vis_prms[\"label\"]:\n                f_label_width = pdfmetrics.stringWidth(feature.vis_prms[\"label\"],\n                                                       self.prms.args[\"feature_label_font_face\"],\n                                                       track_data[\"f_label_font_size\"])\n            feature_vis_data = feature.vis_prms\n            feature_vis_data[\"coordinates\"] = lovis4u.Methods.feature_nt_to_x_transform(feature.start, feature.end,\n                                                                                        feature.strand, locus,\n                                                                                        layout)\n            feature_vis_data[\"label_width\"] = f_label_width\n            feature_vis_data[\"feature_width\"] = feature_vis_data[\"coordinates\"][\"end\"] - \\\n                                                feature_vis_data[\"coordinates\"][\"start\"]\n            feature_vis_data[\"group\"] = feature.group\n            track_data[\"features\"].append(feature_vis_data)\n        # Managing category visualisation\n        feature_cateregories = set([feature.category for feature in locus.features if feature.category])\n        track_data[\"functions_coordinates\"] = None\n        if feature_cateregories and locus.category_colours:\n            track_data[\"category_colours\"] = locus.category_colours\n            track_data[\"functions_coordinates\"] = dict()\n            for ff in feature_cateregories:\n                ff_features = [feature for feature in locus.features if feature.category == ff]\n                ff_coordinates = [[f.vis_prms[\"coordinates\"][\"start\"], f.vis_prms[\"coordinates\"][\"end\"]] for f in\n                                  ff_features]\n                track_data[\"functions_coordinates\"][ff] = ff_coordinates\n        # Managing feature labels' positions:\n        taken_label_coordinates = collections.defaultdict(list)\n        if sum([fvd[\"show_label\"] for fvd in track_data[\"features\"]]) &gt; 0:\n            space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"feature_label_font_face\"],\n                                                 track_data[\"f_label_font_size\"])\n            sorted_features = sorted(track_data[\"features\"], key=lambda x: x[\"feature_width\"] - x[\"label_width\"],\n                                     reverse=True)\n            for fvd in [fvd for fvd in sorted_features if fvd[\"label_width\"]]:\n                feature_center = fvd[\"coordinates\"][\"center\"]\n                width_diff = fvd[\"label_width\"] - fvd[\"feature_width\"]\n                left_position = [fvd[\"coordinates\"][\"start\"] - width_diff, fvd[\"coordinates\"][\"end\"]]\n                centered_position = [feature_center - fvd[\"label_width\"] / 2,\n                                     feature_center + fvd[\"label_width\"] / 2]\n                right_position = [fvd[\"coordinates\"][\"start\"], fvd[\"coordinates\"][\"end\"] + width_diff]\n                for pos in [left_position, centered_position, right_position]:\n                    overlap = 0\n                    if pos[0] &lt; layout[\"loci_tracks_left_border\"]:\n                        overlap = layout[\"loci_tracks_left_border\"] - pos[0]\n                    if pos[1] &gt; layout[\"loci_tracks_right_border\"]:\n                        overlap = layout[\"loci_tracks_right_border\"] - pos[1]\n                    if overlap:\n                        pos[0] += overlap\n                        pos[1] += overlap\n                label_position = centered_position\n                if width_diff &gt; 0:\n                    left_pos_overlap = [of for of in track_data[\"features\"] if\n                                        (of != fvd and left_position[0] &lt; of[\"coordinates\"][\"end\"] &lt;\n                                         fvd[\"coordinates\"][\"end\"] and of[\"show_label\"])]\n                    right_pos_overlap = [of for of in track_data[\"features\"] if\n                                         (of != fvd and right_position[1] &gt; of[\"coordinates\"][\"start\"] &gt;\n                                          fvd[\"coordinates\"][\"start\"] and of[\"show_label\"])]\n                    if left_pos_overlap and not right_pos_overlap:\n                        min_n_distance = min([fvd[\"coordinates\"][\"start\"] - nf[\"coordinates\"][\"end\"]\n                                              for nf in left_pos_overlap])\n                        if min_n_distance &lt; space_width:\n                            right_position[0] += space_width + min(0, min_n_distance)\n                            right_position[1] += space_width + min(0, min_n_distance)\n                        label_position = right_position\n                    elif not left_pos_overlap and right_pos_overlap:\n                        min_n_distance = min([nf[\"coordinates\"][\"start\"] - fvd[\"coordinates\"][\"end\"]\n                                              for nf in right_pos_overlap])\n                        label_position = left_position\n                        if min_n_distance &lt; space_width and left_position[0] != layout[\"loci_tracks_left_border\"]:\n                            left_position[0] -= space_width\n                            left_position[1] -= space_width\n                        else:\n                            label_position = centered_position\n                    else:\n                        label_position = centered_position\n                fvd[\"label_position\"] = label_position\n                for label_row in range(0, len(track_data[\"features\"])):\n                    overlapped = False\n                    for taken_coordinate in taken_label_coordinates[label_row]:\n                        if taken_coordinate[0] &lt;= label_position[0] &lt;= taken_coordinate[1] or \\\n                                taken_coordinate[0] &lt;= label_position[1] &lt;= taken_coordinate[1] or \\\n                                label_position[0] &lt;= taken_coordinate[0] &lt;= label_position[1] or \\\n                                label_position[0] &lt;= taken_coordinate[1] &lt;= label_position[1]:\n                            overlapped = True\n                    if not overlapped:\n                        fvd[\"label_row\"] = label_row\n                        taken_label_coordinates[label_row].append(label_position)\n                        break\n                fvd[\"label_y_bottom\"] = track_data[\"feature_label_gap\"] + \\\n                                        (fvd[\"label_row\"] * track_data[\"f_label_height\"]) + \\\n                                        (fvd[\"label_row\"] * track_data[\"feature_label_gap\"])\n            for fvd in track_data[\"features\"]:\n                if fvd[\"label_width\"]:\n                    if fvd[\"label_row\"] &gt; 0:\n                        taken_middle_rows = [i for i in range(fvd[\"label_row\"] - 1, -1, -1) if\n                                             any(taken_coordinate[0] &lt;= fvd[\"coordinates\"][\"center\"] &lt;=\n                                                 taken_coordinate[1]\n                                                 for taken_coordinate in taken_label_coordinates[i])]\n                        label_line_upper = fvd[\"label_y_bottom\"] - track_data[\"feature_label_gap\"] / 2\n                        label_line_bottom = track_data[\"feature_label_gap\"] / 2\n                        label_line_coordinates = []\n                        ll_start = label_line_bottom\n                        for tmr in sorted(taken_middle_rows):\n                            tmr_start = 0.5 * track_data[\"feature_label_gap\"] + \\\n                                        (tmr * track_data[\"f_label_height\"]) + \\\n                                        (tmr * track_data[\"feature_label_gap\"])\n                            tmr_end = tmr_start + track_data[\"f_label_height\"] + \\\n                                      0.5 * track_data[\"feature_label_gap\"]\n                            label_line_coordinates.append([ll_start, tmr_start])\n                            ll_start = tmr_end\n                        label_line_coordinates.append([ll_start, label_line_upper])\n                        fvd[\"label_line_coordinates\"] = label_line_coordinates\n        track_data[\"n_label_rows\"] = sum([1 for k, v in taken_label_coordinates.items() if v])\n        # Managing middle line indicating locus borders\n        if self.prms.args[\"draw_middle_line\"]:\n            regions_for_middle_line = [[c[\"start\"], c[\"end\"]] for c in locus.coordinates]\n            for ftc in features_taken_nt_coordinates:\n                ftcs, ftse = ftc\n                for added_region in regions_for_middle_line:\n                    new_regions = []\n                    to_remove = False\n                    if added_region[0] &lt;= ftcs &lt;= added_region[1]:\n                        to_remove = True\n                        if ftcs &gt; added_region[0]:\n                            new_regions.append([added_region[0], ftcs - 1])\n                    if added_region[0] &lt;= ftse &lt;= added_region[1]:\n                        to_remove = True\n                        if ftse &lt; added_region[1]:\n                            new_regions.append([ftse + 1, added_region[1]])\n                    if to_remove:\n                        regions_for_middle_line.remove(added_region)\n                    regions_for_middle_line += new_regions\n            middle_line_coordinates = [lovis4u.Methods.region_nt_to_x_transform(rml[0], rml[1], locus, layout)\n                                       for rml in regions_for_middle_line]\n            track_data[\"middle_line_coordinates\"] = middle_line_coordinates\n        track_data[\"proteome_size\"] = len(locus.features)  # to change if we get other features\n        # Managing individual x axis\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            track_data[\"x_axis_annotation\"] = dict()\n            self.prms.args[\"x_axis_ticks_labels_height\"] = lovis4u.Methods.str_font_size_to_height(\n                self.prms.args[\"x_axis_ticks_labels_font_size\"],\n                self.prms.args[\"x_axis_ticks_labels_font_face\"]) / mm\n            track_data[\"x_axis_annotation\"][\"label_size\"] = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n            axis_regions = []\n            axis_tics_coordinates = []\n            for coordinate in locus.coordinates:\n                axis_regions.append(lovis4u.Methods.region_nt_to_x_transform(coordinate[\"start\"], coordinate[\"end\"],\n                                                                             locus, layout))\n                current_tics_coordinates = [coordinate[\"start\"], coordinate[\"end\"]]\n                axis_tics_coordinates += current_tics_coordinates\n            if len(axis_tics_coordinates) == 2:\n                nt_range = coordinate[\"end\"] - coordinate[\"start\"]\n                axis_tics_coordinates.append(coordinate[\"start\"] + int(0.25 * nt_range))\n                axis_tics_coordinates.append(coordinate[\"start\"] + int(0.5 * nt_range))\n                axis_tics_coordinates.append(coordinate[\"end\"] - int(0.25 * nt_range))\n\n            axis_tics_positions = list(map(lambda x: lovis4u.Methods.nt_to_x_transform(x, locus, layout, \"center\"),\n                                           axis_tics_coordinates))\n            sorted_tics = sorted(zip(axis_tics_positions, axis_tics_coordinates))\n            sorted_positions, sorted_coordinates = zip(*sorted_tics)\n            axis_tics_positions = list(sorted_positions)\n            axis_tics_coordinates = list(sorted_coordinates)\n            axis_tics_labels = list(map(str, axis_tics_coordinates))\n            axis_tics_label_size = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n            axis_tics_label_width = list(map(lambda x: pdfmetrics.stringWidth(x,\n                                                                              self.prms.args[\n                                                                                  \"x_axis_ticks_labels_font_face\"],\n                                                                              axis_tics_label_size),\n                                             axis_tics_labels))\n\n            space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                 axis_tics_label_size)\n            tics_labels_coordinates = axis_tics_positions.copy()\n            # Shitty, refactor later\n            for t_i in range(len(axis_tics_coordinates)):\n                label_width = axis_tics_label_width[t_i]\n                tick_position = axis_tics_positions[t_i]\n                if t_i == 0:\n                    tics_labels_coordinates[t_i] += label_width * 0.5\n                elif t_i != len(axis_tics_coordinates) - 1:\n                    center_label_coordinates = [tick_position - 0.5 * label_width,\n                                                tick_position + 0.5 * label_width]\n                    if center_label_coordinates[0] - space_width &lt;= axis_tics_positions[t_i - 1]:\n                        tics_labels_coordinates[t_i] += label_width * 0.5\n                        if axis_tics_positions[t_i] - axis_tics_positions[t_i - 1] &lt; space_width:\n                            tics_labels_coordinates[t_i] += space_width\n                    if center_label_coordinates[1] + space_width &gt;= axis_tics_positions[t_i + 1]:\n                        tics_labels_coordinates[t_i] -= label_width * 0.5\n                        if axis_tics_positions[t_i + 1] - axis_tics_positions[t_i] &lt; space_width:\n                            tics_labels_coordinates[t_i] -= space_width\n                if tics_labels_coordinates[t_i] + label_width * 0.5 &gt; layout[\"loci_tracks_right_border\"]:\n                    tics_labels_coordinates[t_i] -= ((tics_labels_coordinates[t_i] + label_width * 0.5) -\n                                                     layout[\"loci_tracks_right_border\"])\n            track_data[\"x_axis_annotation\"][\"axis_regions\"] = axis_regions\n            track_data[\"x_axis_annotation\"][\"axis_tics_position\"] = axis_tics_positions\n            track_data[\"x_axis_annotation\"][\"axis_tics_labels\"] = axis_tics_labels\n            track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"] = tics_labels_coordinates\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare Locus specific data.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Parameters","title":"<code>Parameters</code>","text":"<p>A Parameters object holds and parse command line's and config's arguments.</p> <p>A Parameters object have to be created in each script since it's used almost by each     class of the tool as a mandatory argument.</p> <p>Attributes:</p> <ul> <li> <code>args</code>             (<code>dict</code>)         \u2013          <p>dictionary that holds all arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Parameters:\n    \"\"\"A Parameters object holds and parse command line's and config's arguments.\n\n    A Parameters object have to be created in each script since it's used almost by each\n        class of the tool as a mandatory argument.\n\n    Attributes:\n        args (dict): dictionary that holds all arguments.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Create a Parameters object.\n\n        \"\"\"\n        self.args = dict(debug=False, verbose=False)\n        self.cmd_arguments = dict()\n\n    def parse_cmd_arguments(self) -&gt; None:\n        \"\"\"Parse command-line args\n\n        Returns:\n            None\n\n        \"\"\"\n        parser = argparse.ArgumentParser(prog=\"lovis4u\", add_help=False,\n                                         usage=\"lovis4u [-gff gff_folder | -gb gb_folder] [optional args]\")\n        parser.add_argument(\"-data\", \"--data\", dest=\"lovis4u_data\", action=\"store_true\")\n        parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n        parser.add_argument(\"-mac\", \"--mac\", dest=\"mac\", action=\"store_true\", default=None)\n        mutually_exclusive_group = parser.add_mutually_exclusive_group()\n        mutually_exclusive_group.add_argument(\"-gff\", \"--gff\", dest=\"gff\", type=str, default=None)\n        mutually_exclusive_group.add_argument(\"-gb\", \"--gb\", dest=\"gb\", type=str, default=None)\n        parser.add_argument(\"-ufid\", \"--use-filename-as-id\", dest=\"use_filename_as_contig_id\", action=\"store_true\",\n                            default=None)\n        parser.add_argument(\"-laf\", \"--locus-annotation-file\", dest=\"locus-annotation\", type=str, default=None)\n        parser.add_argument(\"-faf\", \"--feature-annotation-file\", dest=\"feature-annotation\", type=str, default=None)\n        parser.add_argument(\"-mmseqs-off\", \"--mmseqs-off\", dest=\"mmseqs\", action=\"store_false\")\n        parser.add_argument(\"-cl-owp\", \"--cluster-only-window-proteins\", dest=\"cluster_all_proteins\",\n                            action=\"store_false\", default=None)\n        parser.add_argument(\"-fv-off\", \"--find-variable-off\", dest=\"find-variable\", action=\"store_false\")\n        parser.add_argument(\"-cl-off\", \"--clust_loci-off\", dest=\"clust_loci\", action=\"store_false\")\n        parser.add_argument(\"-oc\", \"--one-cluster\", dest=\"one_cluster\", action=\"store_true\", default=None)\n        parser.add_argument(\"-reorient_loci\", \"--reorient_loci\", dest=\"reorient_loci\", action=\"store_true\")\n        parser.add_argument(\"-lls\", \"--locus-label-style\", dest=\"locus_label_style\",\n                            choices=[\"id\", \"description\", \"full\"], default=None)\n        parser.add_argument(\"-llp\", \"--locus-label-position\", dest=\"locus_label_position\",\n                            choices=[\"left\", \"bottom\"], default=None)\n        parser.add_argument(\"-sgc-off\", \"--set-group-colour-off\", dest=\"set-group-colour\", action=\"store_false\")\n        parser.add_argument(\"-sgcf\", \"--set-group-colour-for\", dest=\"feature_group_types_to_set_colour\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-scc\", \"--set-category-colour\", dest=\"set-category-colour\", action=\"store_true\")\n        parser.add_argument(\"-cct\", \"--category-colour-table\", dest=\"category_colours\", type=str, default=None)\n        parser.add_argument(\"-safl\", \"--show-all-feature-labels\", dest=\"show_all_feature_labels\",\n                            action=\"store_true\")\n        parser.add_argument(\"-sflf\", \"--show-feature-label-for\", dest=\"feature_group_types_to_show_label\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-sfflf\", \"--show-first-feature-label-for\",\n                            dest=\"feature_group_types_to_show_label_on_first_occurrence\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-ifl\", \"--ignored-feature-labels\", dest=\"feature_labels_to_ignore\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-hl\", \"--homology-links\", dest=\"homology-track\", action=\"store_true\")\n        parser.add_argument(\"-slt\", \"--scale-line-track\", dest=\"draw_scale_line_track\", action=\"store_true\",\n                            default=None)\n        parser.add_argument(\"-sxa\", \"--show-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_true\", default=None)\n        parser.add_argument(\"-hix\", \"--hide-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_false\", default=None)\n        parser.add_argument(\"-dml\", \"--draw-middle-line\", dest=\"draw_middle_line\", action=\"store_true\", default=None)\n        parser.add_argument(\"-mm-per-nt\", \"--mm-per-nt\", dest=\"mm_per_nt\", type=float, default=None)\n        parser.add_argument(\"-fw\", \"--figure-width\", dest=\"figure_width\", type=float, default=None)\n        parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n        parser.add_argument(\"--pdf-name\", dest=\"pdf-name\", type=str, default=\"lovis4u.pdf\")\n        parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"standard\")\n        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.0.9\")\n        parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n        parser.add_argument(\"--parsing-debug\", \"-parsing-debug\", dest=\"parsing_debug\", action=\"store_true\")\n        parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n        parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n        args = parser.parse_args()\n        args = vars(args)\n        if len(sys.argv[1:]) == 0:\n            args[\"help\"] = True\n        if args[\"lovis4u_data\"]:\n            lovis4u.Methods.copy_package_data()\n            sys.exit()\n        if args[\"linux\"]:\n            lovis4u.Methods.adjust_paths(\"linux\")\n            sys.exit()\n        if args[\"mac\"]:\n            lovis4u.Methods.adjust_paths(\"mac\")\n            sys.exit()\n        if args[\"help\"]:\n            help_message_path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"help.txt\")\n            with open(help_message_path, \"r\") as help_message:\n                print(help_message.read(), file=sys.stdout)\n                sys.exit()\n        if not args[\"gff\"] and not args[\"gb\"]:\n            raise lovis4u.Manager.lovis4uError(\"-gff or -gb parameter with folder path should be provided\")\n        args_to_keep = [\"locus-annotation\", \"feature-annotation\", \"gb\", \"gff\"]\n        filtered_args = {k: v for k, v in args.items() if v is not None or k in args_to_keep}\n        self.cmd_arguments = filtered_args\n        return None\n\n    def load_config(self, path: str = \"standard\") -&gt; None:\n        \"\"\"Load configuration file.\n\n        Arguments\n            path (str): path to a config file or name (only standard available at this moment).\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if path in [\"standard\", \"A4p1\", \"A4p2\", \"A4L\"]:\n                print(f\"\u25cb Loaded configuration file: '{path}'. List of available: \"\n                      f\"standard (auto-size),\\n\\tA4p1 (A4 page one-column [90mm]), A4p2 (A4 page two-column [190mm]), \"\n                      f\"and A4L (A4 landscape [240mm]).\\n\\tUse -c/--config &lt;name&gt; parameter for choosing.\",\n                      file=sys.stdout)\n                path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", f\"{path}.cfg\")\n            config = configs.load(path).get_config()\n            internal_dir = os.path.dirname(__file__)\n            for key in config[\"root\"].keys():\n                if isinstance(config[\"root\"][key], str):\n                    if config[\"root\"][key] == \"None\":\n                        config[\"root\"][key] = None\n                if isinstance(config[\"root\"][key], str) and \"{internal}\" in config[\"root\"][key]:\n                    config[\"root\"][key] = config[\"root\"][key].replace(\"{internal}\",\n                                                                      os.path.join(internal_dir, \"lovis4u_data\"))\n            config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                                time.strftime(\"%Y_%m_%d-%H_%M\"))\n            keys_to_transform_to_list = [\"feature_group_types_to_set_colour\", \"feature_group_types_to_show_label\",\n                                         \"genbank_id_alternative_source\", \"feature_labels_to_ignore\",\n                                         \"feature_group_types_to_show_label_on_first_occurrence\"]\n            for ktl in keys_to_transform_to_list:\n                if isinstance(config[\"root\"][ktl], str):\n                    if config[\"root\"][ktl] != \"None\":\n                        config[\"root\"][ktl] = [config[\"root\"][ktl]]\n                    else:\n                        config[\"root\"][ktl] = []\n            self.args.update(config[\"root\"])\n            self.load_palette()\n            self.load_fonts()\n            if self.cmd_arguments:\n                self.args.update(self.cmd_arguments)\n\n            if os.path.exists(self.args[\"output_dir\"]):\n                if self.args[\"verbose\"]:\n                    print(\"\u25cb Warning: the output folder already exists. Results will be rewritten (without removal \"\n                          \"other files in this folder)\", file=sys.stdout)\n            self.args[\"locus_label_description_font_face\"] = self.args[f\"locus_label_description_font_face_\" \\\n                                                                       f\"{self.args['locus_label_position']}\"]\n            self.args[\"locus_label_id_font_face\"] = self.args[f\"locus_label_id_font_face_\" \\\n                                                              f\"{self.args['locus_label_position']}\"]\n            # Check conflicts\n            if self.args[\"draw_individual_x_axis\"] and self.args[\"locus_label_position\"] == \"bottom\":\n                raise lovis4uError(\"Individual x-axis cannot be plotted when locus label position\"\n                                   \" set as 'bottom'.\")\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to parse the specified config file. Please check your config file \"\n                               \"or written name.\") from error\n\n    def load_palette(self) -&gt; None:\n        \"\"\"Load palette file.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            palette_path = self.args[f\"palette\"]\n            self.args[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to load palette.\") from error\n\n    def load_fonts(self) -&gt; None:\n        \"\"\"Load fonts.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            font_pattern = re.compile(r\"^font_(.*)$\")\n            font_subdict = {font_pattern.match(key).group(1): value for key, value in self.args.items() if\n                            font_pattern.match(key)}\n            for font_type, font_path in font_subdict.items():\n                pdfmetrics.registerFont(reportlab.pdfbase.ttfonts.TTFont(font_type, font_path))\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to load fonts.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Parameters.__init__","title":"<code>__init__()</code>","text":"<p>Create a Parameters object.</p> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self):\n    \"\"\"Create a Parameters object.\n\n    \"\"\"\n    self.args = dict(debug=False, verbose=False)\n    self.cmd_arguments = dict()\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Parameters.load_config","title":"<code>load_config(path='standard')</code>","text":"<p>Load configuration file.</p> <p>Arguments     path (str): path to a config file or name (only standard available at this moment).</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_config(self, path: str = \"standard\") -&gt; None:\n    \"\"\"Load configuration file.\n\n    Arguments\n        path (str): path to a config file or name (only standard available at this moment).\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if path in [\"standard\", \"A4p1\", \"A4p2\", \"A4L\"]:\n            print(f\"\u25cb Loaded configuration file: '{path}'. List of available: \"\n                  f\"standard (auto-size),\\n\\tA4p1 (A4 page one-column [90mm]), A4p2 (A4 page two-column [190mm]), \"\n                  f\"and A4L (A4 landscape [240mm]).\\n\\tUse -c/--config &lt;name&gt; parameter for choosing.\",\n                  file=sys.stdout)\n            path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", f\"{path}.cfg\")\n        config = configs.load(path).get_config()\n        internal_dir = os.path.dirname(__file__)\n        for key in config[\"root\"].keys():\n            if isinstance(config[\"root\"][key], str):\n                if config[\"root\"][key] == \"None\":\n                    config[\"root\"][key] = None\n            if isinstance(config[\"root\"][key], str) and \"{internal}\" in config[\"root\"][key]:\n                config[\"root\"][key] = config[\"root\"][key].replace(\"{internal}\",\n                                                                  os.path.join(internal_dir, \"lovis4u_data\"))\n        config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                            time.strftime(\"%Y_%m_%d-%H_%M\"))\n        keys_to_transform_to_list = [\"feature_group_types_to_set_colour\", \"feature_group_types_to_show_label\",\n                                     \"genbank_id_alternative_source\", \"feature_labels_to_ignore\",\n                                     \"feature_group_types_to_show_label_on_first_occurrence\"]\n        for ktl in keys_to_transform_to_list:\n            if isinstance(config[\"root\"][ktl], str):\n                if config[\"root\"][ktl] != \"None\":\n                    config[\"root\"][ktl] = [config[\"root\"][ktl]]\n                else:\n                    config[\"root\"][ktl] = []\n        self.args.update(config[\"root\"])\n        self.load_palette()\n        self.load_fonts()\n        if self.cmd_arguments:\n            self.args.update(self.cmd_arguments)\n\n        if os.path.exists(self.args[\"output_dir\"]):\n            if self.args[\"verbose\"]:\n                print(\"\u25cb Warning: the output folder already exists. Results will be rewritten (without removal \"\n                      \"other files in this folder)\", file=sys.stdout)\n        self.args[\"locus_label_description_font_face\"] = self.args[f\"locus_label_description_font_face_\" \\\n                                                                   f\"{self.args['locus_label_position']}\"]\n        self.args[\"locus_label_id_font_face\"] = self.args[f\"locus_label_id_font_face_\" \\\n                                                          f\"{self.args['locus_label_position']}\"]\n        # Check conflicts\n        if self.args[\"draw_individual_x_axis\"] and self.args[\"locus_label_position\"] == \"bottom\":\n            raise lovis4uError(\"Individual x-axis cannot be plotted when locus label position\"\n                               \" set as 'bottom'.\")\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to parse the specified config file. Please check your config file \"\n                           \"or written name.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Parameters.load_fonts","title":"<code>load_fonts()</code>","text":"<p>Load fonts.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_fonts(self) -&gt; None:\n    \"\"\"Load fonts.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        font_pattern = re.compile(r\"^font_(.*)$\")\n        font_subdict = {font_pattern.match(key).group(1): value for key, value in self.args.items() if\n                        font_pattern.match(key)}\n        for font_type, font_path in font_subdict.items():\n            pdfmetrics.registerFont(reportlab.pdfbase.ttfonts.TTFont(font_type, font_path))\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to load fonts.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Parameters.load_palette","title":"<code>load_palette()</code>","text":"<p>Load palette file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_palette(self) -&gt; None:\n    \"\"\"Load palette file.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        palette_path = self.args[f\"palette\"]\n        self.args[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to load palette.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.Parameters.parse_cmd_arguments","title":"<code>parse_cmd_arguments()</code>","text":"<p>Parse command-line args</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def parse_cmd_arguments(self) -&gt; None:\n    \"\"\"Parse command-line args\n\n    Returns:\n        None\n\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"lovis4u\", add_help=False,\n                                     usage=\"lovis4u [-gff gff_folder | -gb gb_folder] [optional args]\")\n    parser.add_argument(\"-data\", \"--data\", dest=\"lovis4u_data\", action=\"store_true\")\n    parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n    parser.add_argument(\"-mac\", \"--mac\", dest=\"mac\", action=\"store_true\", default=None)\n    mutually_exclusive_group = parser.add_mutually_exclusive_group()\n    mutually_exclusive_group.add_argument(\"-gff\", \"--gff\", dest=\"gff\", type=str, default=None)\n    mutually_exclusive_group.add_argument(\"-gb\", \"--gb\", dest=\"gb\", type=str, default=None)\n    parser.add_argument(\"-ufid\", \"--use-filename-as-id\", dest=\"use_filename_as_contig_id\", action=\"store_true\",\n                        default=None)\n    parser.add_argument(\"-laf\", \"--locus-annotation-file\", dest=\"locus-annotation\", type=str, default=None)\n    parser.add_argument(\"-faf\", \"--feature-annotation-file\", dest=\"feature-annotation\", type=str, default=None)\n    parser.add_argument(\"-mmseqs-off\", \"--mmseqs-off\", dest=\"mmseqs\", action=\"store_false\")\n    parser.add_argument(\"-cl-owp\", \"--cluster-only-window-proteins\", dest=\"cluster_all_proteins\",\n                        action=\"store_false\", default=None)\n    parser.add_argument(\"-fv-off\", \"--find-variable-off\", dest=\"find-variable\", action=\"store_false\")\n    parser.add_argument(\"-cl-off\", \"--clust_loci-off\", dest=\"clust_loci\", action=\"store_false\")\n    parser.add_argument(\"-oc\", \"--one-cluster\", dest=\"one_cluster\", action=\"store_true\", default=None)\n    parser.add_argument(\"-reorient_loci\", \"--reorient_loci\", dest=\"reorient_loci\", action=\"store_true\")\n    parser.add_argument(\"-lls\", \"--locus-label-style\", dest=\"locus_label_style\",\n                        choices=[\"id\", \"description\", \"full\"], default=None)\n    parser.add_argument(\"-llp\", \"--locus-label-position\", dest=\"locus_label_position\",\n                        choices=[\"left\", \"bottom\"], default=None)\n    parser.add_argument(\"-sgc-off\", \"--set-group-colour-off\", dest=\"set-group-colour\", action=\"store_false\")\n    parser.add_argument(\"-sgcf\", \"--set-group-colour-for\", dest=\"feature_group_types_to_set_colour\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-scc\", \"--set-category-colour\", dest=\"set-category-colour\", action=\"store_true\")\n    parser.add_argument(\"-cct\", \"--category-colour-table\", dest=\"category_colours\", type=str, default=None)\n    parser.add_argument(\"-safl\", \"--show-all-feature-labels\", dest=\"show_all_feature_labels\",\n                        action=\"store_true\")\n    parser.add_argument(\"-sflf\", \"--show-feature-label-for\", dest=\"feature_group_types_to_show_label\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-sfflf\", \"--show-first-feature-label-for\",\n                        dest=\"feature_group_types_to_show_label_on_first_occurrence\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-ifl\", \"--ignored-feature-labels\", dest=\"feature_labels_to_ignore\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-hl\", \"--homology-links\", dest=\"homology-track\", action=\"store_true\")\n    parser.add_argument(\"-slt\", \"--scale-line-track\", dest=\"draw_scale_line_track\", action=\"store_true\",\n                        default=None)\n    parser.add_argument(\"-sxa\", \"--show-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_true\", default=None)\n    parser.add_argument(\"-hix\", \"--hide-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_false\", default=None)\n    parser.add_argument(\"-dml\", \"--draw-middle-line\", dest=\"draw_middle_line\", action=\"store_true\", default=None)\n    parser.add_argument(\"-mm-per-nt\", \"--mm-per-nt\", dest=\"mm_per_nt\", type=float, default=None)\n    parser.add_argument(\"-fw\", \"--figure-width\", dest=\"figure_width\", type=float, default=None)\n    parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n    parser.add_argument(\"--pdf-name\", dest=\"pdf-name\", type=str, default=\"lovis4u.pdf\")\n    parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"standard\")\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.0.9\")\n    parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n    parser.add_argument(\"--parsing-debug\", \"-parsing-debug\", dest=\"parsing_debug\", action=\"store_true\")\n    parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n    parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n    args = parser.parse_args()\n    args = vars(args)\n    if len(sys.argv[1:]) == 0:\n        args[\"help\"] = True\n    if args[\"lovis4u_data\"]:\n        lovis4u.Methods.copy_package_data()\n        sys.exit()\n    if args[\"linux\"]:\n        lovis4u.Methods.adjust_paths(\"linux\")\n        sys.exit()\n    if args[\"mac\"]:\n        lovis4u.Methods.adjust_paths(\"mac\")\n        sys.exit()\n    if args[\"help\"]:\n        help_message_path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"help.txt\")\n        with open(help_message_path, \"r\") as help_message:\n            print(help_message.read(), file=sys.stdout)\n            sys.exit()\n    if not args[\"gff\"] and not args[\"gb\"]:\n        raise lovis4u.Manager.lovis4uError(\"-gff or -gb parameter with folder path should be provided\")\n    args_to_keep = [\"locus-annotation\", \"feature-annotation\", \"gb\", \"gff\"]\n    filtered_args = {k: v for k, v in args.items() if v is not None or k in args_to_keep}\n    self.cmd_arguments = filtered_args\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.ScaleLoader","title":"<code>ScaleLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A LocusLoader object prepares data for a Scale track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class ScaleLoader(Loader):\n    \"\"\"A LocusLoader object prepares data for a Scale track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a ScaleLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, layout: dict) -&gt; None:\n        \"\"\"Prepare ScaleLoader specific data.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            total_nt_width = self.layout[\"total_nt_width\"]\n            raw_scale_line_nt_width = round(total_nt_width * self.prms.args[\"scale_line_relative_size\"])\n            raw_scale_line_nt_width_pow = int(math.log(raw_scale_line_nt_width, 10))\n            scale_line_nt_width = round(raw_scale_line_nt_width // math.pow(10, raw_scale_line_nt_width_pow) *\n                                        math.pow(10, raw_scale_line_nt_width_pow))\n            track_data = dict()\n            self.track_data = track_data\n            track_data[\"scale_line_nt_width\"] = scale_line_nt_width\n            track_data[\"coordinates\"] = [self.layout[\"loci_tracks_left_border\"],\n                                         self.layout[\"loci_tracks_left_border\"] +\n                                         layout[\"width_per_nt\"] * scale_line_nt_width]\n            track_data[\"scale_line_width\"] = track_data[\"coordinates\"][1] - track_data[\"coordinates\"][0]\n            track_data[\"scale_label\"] = f\"{scale_line_nt_width} nt\"\n            track_data[\"scale_line_label_font_size\"] = self.prms.args[\"scale_line_label_font_size\"]\n            track_data[\"scale_line_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n                track_data[\"scale_line_label_font_size\"], self.prms.args[\"scale_line_label_font_face\"])\n            track_data[\"scale_line_label_width\"] = pdfmetrics.stringWidth(track_data[\"scale_label\"],\n                                                                          self.prms.args[\"scale_line_label_font_face\"],\n                                                                          track_data[\"scale_line_label_font_size\"])\n            if (track_data[\"scale_line_width\"] - track_data[\"scale_line_label_width\"]) / \\\n                    track_data[\"scale_line_width\"] &gt; 0.1:\n                track_data[\"style\"] = \"fancy\"\n                track_data[\"space_width\"] = pdfmetrics.stringWidth(\" \", self.prms.args[\"scale_line_label_font_face\"],\n                                                                   track_data[\"scale_line_label_font_size\"])\n            else:\n                track_data[\"style\"] = \"default\"\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare scale track specific data.\") from error\n\n    def calculate_track_height(self):\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            if self.track_data[\"style\"] == \"fancy\":\n                track_height = self.track_data[\"scale_line_label_height\"]\n            else:\n                track_height = (1.2 * self.prms.args[\"scale_line_tics_height\"] +\n                                self.track_data[\"scale_line_label_height\"])\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a scale track height.\") from error\n\n    def create_track(self):\n        \"\"\"Initialise a ScaleVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis: visualisation track.\n\n        \"\"\"\n        try:\n            return lovis4u.Drawing.ScaleVis(self.layout, self.track_data, self.prms)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a scale track object.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.ScaleLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a ScaleLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a ScaleLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.ScaleLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code>        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self):\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        if self.track_data[\"style\"] == \"fancy\":\n            track_height = self.track_data[\"scale_line_label_height\"]\n        else:\n            track_height = (1.2 * self.prms.args[\"scale_line_tics_height\"] +\n                            self.track_data[\"scale_line_label_height\"])\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a scale track height.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.ScaleLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a ScaleVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a ScaleVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis: visualisation track.\n\n    \"\"\"\n    try:\n        return lovis4u.Drawing.ScaleVis(self.layout, self.track_data, self.prms)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a scale track object.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.ScaleLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(layout)</code>","text":"<p>Prepare ScaleLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, layout: dict) -&gt; None:\n    \"\"\"Prepare ScaleLoader specific data.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        total_nt_width = self.layout[\"total_nt_width\"]\n        raw_scale_line_nt_width = round(total_nt_width * self.prms.args[\"scale_line_relative_size\"])\n        raw_scale_line_nt_width_pow = int(math.log(raw_scale_line_nt_width, 10))\n        scale_line_nt_width = round(raw_scale_line_nt_width // math.pow(10, raw_scale_line_nt_width_pow) *\n                                    math.pow(10, raw_scale_line_nt_width_pow))\n        track_data = dict()\n        self.track_data = track_data\n        track_data[\"scale_line_nt_width\"] = scale_line_nt_width\n        track_data[\"coordinates\"] = [self.layout[\"loci_tracks_left_border\"],\n                                     self.layout[\"loci_tracks_left_border\"] +\n                                     layout[\"width_per_nt\"] * scale_line_nt_width]\n        track_data[\"scale_line_width\"] = track_data[\"coordinates\"][1] - track_data[\"coordinates\"][0]\n        track_data[\"scale_label\"] = f\"{scale_line_nt_width} nt\"\n        track_data[\"scale_line_label_font_size\"] = self.prms.args[\"scale_line_label_font_size\"]\n        track_data[\"scale_line_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n            track_data[\"scale_line_label_font_size\"], self.prms.args[\"scale_line_label_font_face\"])\n        track_data[\"scale_line_label_width\"] = pdfmetrics.stringWidth(track_data[\"scale_label\"],\n                                                                      self.prms.args[\"scale_line_label_font_face\"],\n                                                                      track_data[\"scale_line_label_font_size\"])\n        if (track_data[\"scale_line_width\"] - track_data[\"scale_line_label_width\"]) / \\\n                track_data[\"scale_line_width\"] &gt; 0.1:\n            track_data[\"style\"] = \"fancy\"\n            track_data[\"space_width\"] = pdfmetrics.stringWidth(\" \", self.prms.args[\"scale_line_label_font_face\"],\n                                                               track_data[\"scale_line_label_font_size\"])\n        else:\n            track_data[\"style\"] = \"default\"\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare scale track specific data.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Manager.lovis4uError","title":"<code>lovis4uError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A class for exceptions parsing inherited from the Exception class.</p> Source code in <code>lovis4u/Manager.py</code> <pre><code>class lovis4uError(Exception):\n    \"\"\"A class for exceptions parsing inherited from the Exception class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.adjust_paths","title":"<code>adjust_paths(to)</code>","text":"<p>Change paths in the internal config files for linux or mac.</p> <p>Parameters:</p> <ul> <li> <code>to</code>             (<code>str</code>)         \u2013          <p>mac | linux</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def adjust_paths(to: str) -&gt; None:\n    \"\"\"Change paths in the internal config files for linux or mac.\n\n    Arguments:\n        to (str): mac | linux\n\n    Returns:\n        None\n\n    \"\"\"\n    internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n    config_files = [\"standard.cfg\"]\n    for config_file in config_files:\n        config_file_path = os.path.join(internal_dir, config_file)\n        with open(config_file_path, \"r+\") as config:\n            if to == \"linux\":\n                if not os.path.exists(os.path.join(internal_dir, \"bin/mmseqs_linux\")):\n                    os.system(f\"unzip -q -d {os.path.join(internal_dir, 'bin/')} \"\n                              f\"{os.path.join(internal_dir, 'bin/mmseqs_linux.zip')}\")\n                config_txt = re.sub(r\"mmseqs_mac/bin/mmseqs\", \"mmseqs_linux/bin/mmseqs\", config.read())\n            else:\n                config_txt = re.sub(r\"mmseqs_linux/bin/mmseqs\", \"mmseqs_mac/bin/mmseqs\", config.read())\n            config.seek(0)\n            config.truncate()\n            config.write(config_txt)\n    print(f\"\u2699 mmseqs path was adjusted to {to}\")\n    return None\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.copy_package_data","title":"<code>copy_package_data()</code>","text":"<p>Copy the lovis4u package data folder to your current dir.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def copy_package_data() -&gt; None:\n    \"\"\"Copy the lovis4u package data folder to your current dir.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        users_dir = os.path.join(os.getcwd(), \"lovis4u_data\")\n        internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n        if os.path.exists(users_dir):\n            raise lovis4u.Manager.lovis4uError(\"lovis4u_data folder already exists.\")\n        shutil.copytree(internal_dir, users_dir, ignore=shutil.ignore_patterns(\"help*\", \".*\"))\n        print(\"\u2699 lovis4u_data folder was copied to the current working directory\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(f\"Unable to copy lovis4u folder in your working dir.\") from error\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.feature_nt_to_x_transform","title":"<code>feature_nt_to_x_transform(nt_start, nt_end, feature_strand, locus, layout)</code>","text":"<p>Transform feature coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>feature_strand</code>             (<code>int</code>)         \u2013          <p>1 | -1 corresponding to plus or minus strand, respectively.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def feature_nt_to_x_transform(nt_start: int, nt_end: int, feature_strand: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform feature coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        feature_strand (int): 1 | -1 corresponding to plus or minus strand, respectively.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    left_out, right_out = False, False\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] or coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if nt_start &lt; coordinate[\"start\"]:\n                if coordinate[\"strand\"] == 1:\n                    left_out = True\n                else:\n                    right_out = True\n                nt_start = coordinate[\"start\"]\n            if nt_end &gt; coordinate[\"end\"]:\n                if coordinate[\"strand\"] == 1:\n                    right_out = True\n                else:\n                    left_out = True\n                nt_end = coordinate[\"end\"]\n            x_coordinates = region_nt_to_x_transform(nt_start, nt_end, locus, layout)\n            x_coordinates[\"center\"] = (x_coordinates[\"start\"] + x_coordinates[\"end\"]) / 2\n            x_coordinates[\"orient\"] = feature_strand * coordinate[\"strand\"]\n            x_coordinates[\"lout\"] = left_out\n            x_coordinates[\"rout\"] = right_out\n            break\n    return x_coordinates\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.get_colour","title":"<code>get_colour(name, parameters)</code>","text":"<p>Get HEX colour by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a colour.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>HEX colour.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_colour(name: str, parameters: dict) -&gt; str:\n    \"\"\"Get HEX colour by its name\n\n    Arguments:\n        name (str): name of a colour.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        str: HEX colour.\n\n    \"\"\"\n    hex_c = parameters.args[\"palette\"][parameters.args[name]]\n    return hex_c\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.get_colour_rgba","title":"<code>get_colour_rgba(name, parameters)</code>","text":"<p>Get rgba colour by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a colour.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (            <code>tuple</code> )        \u2013          <p>RGBA colour</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_colour_rgba(name: str, parameters: dict) -&gt; tuple:\n    \"\"\"Get rgba colour by its name\n\n    Arguments:\n        name (str): name of a colour.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        tuple: RGBA colour\n\n    \"\"\"\n    return *matplotlib.colors.hex2color(get_colour(name, parameters)), parameters.args[f\"{name}_alpha\"]\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.nt_to_x_transform","title":"<code>nt_to_x_transform(nt, locus, layout, mode)</code>","text":"<p>Transform nucleotide coordinate to x page coordinate.</p> <p>Parameters:</p> <ul> <li> <code>nt</code>             (<code>int</code>)         \u2013          <p>Nucleotide coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> <li> <code>mode</code>             (<code>str</code>)         \u2013          <p>Mode whether coordinate should be centered to the nt or on the side.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>Corresponding page coordinate.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def nt_to_x_transform(nt: int, locus, layout: dict, mode: str) -&gt; float:\n    \"\"\"Transform nucleotide coordinate to x page coordinate.\n\n    Arguments:\n        nt (int): Nucleotide coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n        mode (str): Mode whether coordinate should be centered to the nt or on the side.\n\n    Returns:\n        float: Corresponding page coordinate.\n\n    \"\"\"\n    passed_x = layout[\"loci_tracks_left_border\"]\n    for c_i in range(len(locus.coordinates)):\n        coordinate = locus.coordinates[c_i]\n        coordinate_region_width = (coordinate[\"end\"] - coordinate[\"start\"] + 1) * layout[\"width_per_nt\"]\n        if coordinate[\"start\"] &lt;= nt &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == 1:\n                relative_nt = nt - coordinate[\"start\"]\n            else:\n                relative_nt = coordinate[\"end\"] - nt\n            if mode == \"start\":\n                pass\n            elif mode == \"center\":\n                relative_nt += 0.5\n            elif mode == \"end\":\n                relative_nt += 1\n            relative_x = relative_nt * layout[\"width_per_nt\"]\n            global_x = passed_x + relative_x\n            break\n        passed_x += coordinate_region_width + layout[\"x_gap_between_regions\"]\n        if c_i &lt; len(locus.coordinates) - 1:\n            if locus.circular:\n                if coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == 1:\n                    if coordinate[\"end\"] == locus.length and locus.coordinates[c_i + 1][\"start\"] == 1:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n                elif coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == -1:\n                    if coordinate[\"start\"] == 1 and locus.coordinates[c_i + 1][\"end\"] == locus.length:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n    return global_x\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.region_nt_to_x_transform","title":"<code>region_nt_to_x_transform(nt_start, nt_end, locus, layout)</code>","text":"<p>Transform region coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def region_nt_to_x_transform(nt_start: int, nt_end: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform region coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] and coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == -1:\n                nt_start, nt_end = nt_end, nt_start\n            x_start = nt_to_x_transform(nt_start, locus, layout, \"start\")\n            x_end = nt_to_x_transform(nt_end, locus, layout, \"end\")\n            break\n    return dict(start=x_start, end=x_end)\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.scale_lightness","title":"<code>scale_lightness(hex_c, scale_l)</code>","text":"<p>Helper function to get darker version of input colour</p> <p>Parameters:</p> <ul> <li> <code>hex_c</code>             (<code>str</code>)         \u2013          <p>input HEX colour</p> </li> <li> <code>scale_l</code>             (<code>float</code>)         \u2013          <p>scale of lightness</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>new HEX colour</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def scale_lightness(hex_c: str, scale_l: float) -&gt; str:\n    \"\"\"Helper function to get darker version of input colour\n\n    Arguments:\n        hex_c (str): input HEX colour\n        scale_l (float): scale of lightness\n\n    Returns:\n        str: new HEX colour\n\n    \"\"\"\n    rgb = matplotlib.colors.hex2color(hex_c)\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n    hex_c = matplotlib.colors.rgb2hex(colorsys.hls_to_rgb(h, min(1, l * scale_l), s=s))\n    return hex_c\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.str_font_size_to_height","title":"<code>str_font_size_to_height(font_size, font_type)</code>","text":"<p>Transform string font size to height.</p> <p>Parameters:</p> <ul> <li> <code>font_size</code>             (<code>float</code>)         \u2013          <p>font_size.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>height of the string.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def str_font_size_to_height(font_size: float, font_type: str) -&gt; float:\n    \"\"\"Transform string font size to height.\n\n    Arguments:\n        font_size (float): font_size.\n        font_type (str): font type (see config file; at this moment only regular is available).\n\n    Returns:\n        float:  height of the string.\n\n    \"\"\"\n\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    height = font_size * (face.ascent - face.descent) / (1000*1.38)\n    return height\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.str_height_to_size","title":"<code>str_height_to_size(height, font_type)</code>","text":"<p>Transform string height to the font size.</p> <p>Parameters:</p> <ul> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>available height of the string.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>font size defined by height.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def str_height_to_size(height: float, font_type: str) -&gt; float:\n    \"\"\"Transform string height to the font size.\n\n    Arguments:\n        height (float): available height of the string.\n        font_type (str): font type (see config file; at this moment only regular is available).\n\n    Returns:\n        float: font size defined by height.\n\n    \"\"\"\n\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    font_size = (1000 * 1.38 * height) / (face.ascent - face.descent)\n    return font_size\n</code></pre>"},{"location":"API/package/#lovis4u.Methods.update_path_extension","title":"<code>update_path_extension(path, new_extension)</code>","text":"<p>Get path basename and replace its extension</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>path to a file</p> </li> <li> <code>new_extension</code>             (<code>str</code>)         \u2013          <p>new extension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>basename of a file with new extension.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def update_path_extension(path: str, new_extension: str) -&gt; str:\n    \"\"\"Get path basename and replace its extension\n\n    Arguments:\n        path (str): path to a file\n        new_extension (str): new extension\n\n    Returns:\n        str: basename of a file with new extension.\n\n    \"\"\"\n    updated_filename = f\"{os.path.splitext(os.path.basename(path))[0]}.{new_extension}\"\n    return updated_filename\n</code></pre>"},{"location":"API/package_data_processing/","title":"Package data processing","text":"<p>This module provides managing classes and methods for the tool.</p>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Feature","title":"<code>Feature</code>","text":"<p>A Feature object represents a locus' feature (currently only CDS) and its properties.</p> <p>Attributes:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>feature_type</code>             (<code>str</code>)         \u2013          <p>Type of element (e.g. CDS or tRNA). Currently only CDS are supported.</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>1-based start genomic coordinate.</p> </li> <li> <code>end</code>             (<code>int</code>)         \u2013          <p>1-based end genomic coordinates</p> </li> <li> <code>strand</code>             (<code>int</code>)         \u2013          <p>Genomic strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the feature which will be used as a label.</p> </li> <li> <code>sequence</code>             (<code>Seq</code>)         \u2013          <p>Feature's sequence.</p> </li> <li> <code>record</code>             (<code>SeqRecord</code>)         \u2013          <p>SeqRecord object of corresponding feature sequence.</p> </li> <li> <code>group</code>             (<code>str</code>)         \u2013          <p>Feature group that defines feature's colour and meant to represent a set of homologous features. Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.</p> </li> <li> <code>group_type</code>             (<code>str</code>)         \u2013          <p>Type of feature group that allow to visualise different set of feature groups differently (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature category which initially is built to handle phrogs category annotation. In visualisation it defines the \"category\" colour annotation under features. Supposed to represent clusters on locus or any second layer of feature properties.</p> </li> <li> <code>vis_prms</code>             (<code>dict</code>)         \u2013          <p>Visualisation parameters that holds colours, label and other info for Drawing methods.</p> </li> <li> <code>overlapping</code>             (<code>bool</code>)         \u2013          <p>Whether feature overlaps with visualised region or not.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Feature:\n    \"\"\"A Feature object represents a locus' feature (currently only CDS) and its properties.\n\n    Attributes:\n        feature_id (str): Feature identifier.\n        feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n        start (int): 1-based start genomic coordinate.\n        end (int): 1-based end genomic coordinates\n        strand (int): Genomic strand (1: plus strand, -1: minus strand).\n        name (str): Name of the feature which will be used as a label.\n        sequence (Bio.Seq.Seq): Feature's sequence.\n        record (Bio.SeqRecord.SeqRecord): SeqRecord object of corresponding feature sequence.\n        group (str): Feature group that defines feature's colour and meant to represent a set of homologous features.\n            Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n        group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n            (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n        category (str): Feature category which initially is built to handle phrogs category annotation.\n            In visualisation it defines the \"category\" colour annotation under features.\n            Supposed to represent clusters on locus or any second layer of feature properties.\n        vis_prms (dict): Visualisation parameters that holds colours, label and other info for Drawing methods.\n        overlapping (bool): Whether feature overlaps with visualised region or not.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, feature_id: str, feature_type: str, start: int, end: int, strand: int, name: str,\n                 sequence: Bio.Seq.Seq, group: str, group_type: str, category: str, vis_prms: dict, overlapping: bool,\n                 parameters: lovis4u.Manager.Parameters):\n        \"\"\"Create a Feature object.\n\n        Arguments:\n            feature_id (str): Feature identifier.\n            feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n            start (int): 1-based start genomic coordinate.\n            end (int): 1-based end genomic coordinates\n            strand (int): Genomic strand (1: plus strand, -1: minus strand).\n            name (str): Name of the feature which will be used as a label.\n            sequence (Bio.Seq.Seq): Feature's sequence.\n            group (str): Feature group that defines feature's colour and meant to represent a set of homologous features.\n                Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n            group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n                (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n            category (str): Feature category which initially is built to handle phrogs category annotation.\n                In visualisation it defines the \"category\" colour annotation under features.\n                Supposed to represent clusters on locus or any second layer of feature properties.\n            vis_prms (dict): Visualisation parameters that holds colours, label and other info for Drawing methods.\n            prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.feature_type = feature_type\n        self.feature_id = feature_id\n        self.start = start\n        self.end = end\n        self.strand = strand\n        self.name = name\n        self.sequence = sequence\n        self.record = Bio.SeqRecord.SeqRecord(seq=self.sequence, id=self.feature_id)\n        self.group = group  # maybe rename later\n        self.group_type = group_type\n        self.category = category\n        self.vis_prms = vis_prms\n        self.vis_prms[\"label\"] = str(name)\n        self.overlapping = overlapping\n        self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Feature.__init__","title":"<code>__init__(feature_id, feature_type, start, end, strand, name, sequence, group, group_type, category, vis_prms, overlapping, parameters)</code>","text":"<p>Create a Feature object.</p> <p>Parameters:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>feature_type</code>             (<code>str</code>)         \u2013          <p>Type of element (e.g. CDS or tRNA). Currently only CDS are supported.</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>1-based start genomic coordinate.</p> </li> <li> <code>end</code>             (<code>int</code>)         \u2013          <p>1-based end genomic coordinates</p> </li> <li> <code>strand</code>             (<code>int</code>)         \u2013          <p>Genomic strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the feature which will be used as a label.</p> </li> <li> <code>sequence</code>             (<code>Seq</code>)         \u2013          <p>Feature's sequence.</p> </li> <li> <code>group</code>             (<code>str</code>)         \u2013          <p>Feature group that defines feature's colour and meant to represent a set of homologous features. Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.</p> </li> <li> <code>group_type</code>             (<code>str</code>)         \u2013          <p>Type of feature group that allow to visualise different set of feature groups differently (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature category which initially is built to handle phrogs category annotation. In visualisation it defines the \"category\" colour annotation under features. Supposed to represent clusters on locus or any second layer of feature properties.</p> </li> <li> <code>vis_prms</code>             (<code>dict</code>)         \u2013          <p>Visualisation parameters that holds colours, label and other info for Drawing methods.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, feature_id: str, feature_type: str, start: int, end: int, strand: int, name: str,\n             sequence: Bio.Seq.Seq, group: str, group_type: str, category: str, vis_prms: dict, overlapping: bool,\n             parameters: lovis4u.Manager.Parameters):\n    \"\"\"Create a Feature object.\n\n    Arguments:\n        feature_id (str): Feature identifier.\n        feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n        start (int): 1-based start genomic coordinate.\n        end (int): 1-based end genomic coordinates\n        strand (int): Genomic strand (1: plus strand, -1: minus strand).\n        name (str): Name of the feature which will be used as a label.\n        sequence (Bio.Seq.Seq): Feature's sequence.\n        group (str): Feature group that defines feature's colour and meant to represent a set of homologous features.\n            Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n        group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n            (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n        category (str): Feature category which initially is built to handle phrogs category annotation.\n            In visualisation it defines the \"category\" colour annotation under features.\n            Supposed to represent clusters on locus or any second layer of feature properties.\n        vis_prms (dict): Visualisation parameters that holds colours, label and other info for Drawing methods.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.feature_type = feature_type\n    self.feature_id = feature_id\n    self.start = start\n    self.end = end\n    self.strand = strand\n    self.name = name\n    self.sequence = sequence\n    self.record = Bio.SeqRecord.SeqRecord(seq=self.sequence, id=self.feature_id)\n    self.group = group  # maybe rename later\n    self.group_type = group_type\n    self.category = category\n    self.vis_prms = vis_prms\n    self.vis_prms[\"label\"] = str(name)\n    self.overlapping = overlapping\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci","title":"<code>Loci</code>","text":"<p>A Loci object holds information about all loci to be plotted and methods for data preparation.</p> <p>Attributes:</p> <ul> <li> <code>loci</code>             (<code>list</code>)         \u2013          <p>List of Locus objects.</p> </li> <li> <code>locus_annotation</code>             (<code>DataFrame</code>)         \u2013          <p>Table with information about each locus that defines visualisation (e.g. coordinates for visualisation, description, etc).</p> </li> <li> <code>feature_annotation</code>             (<code>DataFrame</code>)         \u2013          <p>Table with information about each feature that defines visualisation (e.g. group, name, category, etc).</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Loci:\n    \"\"\"A Loci object holds information about all loci to be plotted and methods for data preparation.\n\n    Attributes:\n        loci (list): List of Locus objects.\n        locus_annotation (pd.DataFrame): Table with information about each locus that defines visualisation\n            (e.g. coordinates for visualisation, description, etc).\n        feature_annotation (pd.DataFrame): Table with information about each feature that defines visualisation\n            (e.g. group, name, category, etc).\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, parameters=lovis4u.Manager.Parameters):\n        \"\"\"Create a Loci object.\n\n        Arguments:\n            parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n        \"\"\"\n        self.loci = []\n        self.locus_annotation = pd.DataFrame(columns=[\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\",\n                                                      \"order\", \"group\"]).set_index(\"sequence_id\")\n        self.feature_annotation = pd.DataFrame(columns=[\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\",\n                                                        \"group\", \"group_type\", \"category\", \"fill_colour\",\n                                                        \"stroke_colour\",\n                                                        \"show_label\"]).set_index(\"feature_id\")\n        self.prms = parameters\n\n    def __load_annotation_file(self, file_path: str, annotation_columns: list, index_column: str) -&gt; pd.DataFrame:\n        \"\"\"Private method to load an annotation file.\n\n        Arguments:\n            file_path (str): File path for an annotation file to be loaded.\n            annotation_columns (list): List of columns that should be considered.\n            index_column (str): Column name to be considered as index.\n\n        Returns:\n              pd.DataFrame: Preprocessed annotation file.\n        \"\"\"\n        annotation_table = pd.read_table(file_path)\n        found_allowed_columns = [i for i in annotation_columns if i in annotation_table.columns]\n        not_found_allowed_columns = [i for i in annotation_columns if i not in annotation_table.columns]\n        annotation_table = annotation_table[found_allowed_columns].set_index(index_column)\n        annotation_table[not_found_allowed_columns] = None\n        return annotation_table\n\n    def load_locus_annotation_file(self, file_path: str) -&gt; None:\n        \"\"\"Load loci annotation file.\n\n        Arguments:\n            file_path (str): File path for a loci annotation file to be loaded.\n\n        Returns:\n            None\n\n        \"\"\"\n        annotation_columns = [\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\", \"order\", \"group\"]\n        self.locus_annotation = self.__load_annotation_file(file_path, annotation_columns, \"sequence_id\")\n        return None\n\n    def load_feature_annotation_file(self, file_path: str) -&gt; None:\n        \"\"\"Load features annotation file.\n\n        Arguments:\n            file_path (str): File path for a features annotation file to be loaded.\n\n        Returns:\n            None\n\n        \"\"\"\n        annotation_columns = [\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\", \"group\", \"group_type\",\n                              \"category\", \"fill_colour\", \"stroke_colour\", \"show_label\"]\n        self.feature_annotation = self.__load_annotation_file(file_path, annotation_columns, \"feature_id\")\n        return None\n\n    def __update_locus_annotation(self, record_id: str, record_description: str, record_length: int) -&gt; None:\n        \"\"\"Private method for updating loci annotation.\n\n        Arguments:\n            record_id (str): Sequence identifier.\n            record_description (str): Sequence description.\n            record_length (int): Sequence length.\n\n        Returns:\n            None\n\n        \"\"\"\n        if record_id not in self.locus_annotation.index:\n            self.locus_annotation.loc[record_id] = {col: None for col in self.locus_annotation.columns}\n\n        default_values = dict(length=record_length, coordinates=f\"1:{record_length}:1\",\n                              description=record_description, circular=1, order=len(self.loci), group=1)\n        self.locus_annotation.loc[record_id] = self.locus_annotation.loc[record_id].fillna(default_values)\n        return None\n\n    def __update_feature_annotation(self, feature_id: str, locus_id: str, coordinates: str, feature_type: str,\n                                    category: str, name: str) -&gt; None:\n        \"\"\"Private method for updating feature annotation.\n\n        Arguments:\n            feature_id (str): Feature identifier.\n            locus_id (str): Sequence description.\n            coordinates (str): Feature coordinates.\n            category (str): Feature type.\n            name (str): Feature name.\n\n\n        Returns:\n            None\n\n        \"\"\"\n        if feature_id not in self.feature_annotation.index:\n            self.feature_annotation.loc[feature_id] = {col: None for col in self.feature_annotation.columns}\n\n        if self.feature_annotation.loc[feature_id][\"group_type\"] in self.prms.args[\"feature_group_types_to_show_label\"] \\\n                or \"all\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n            show_label = 1\n        else:\n            show_label = 0\n        stroke_colour = \"default\"\n        if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                self.feature_annotation.loc[feature_id][\"fill_colour\"] and \\\n                self.feature_annotation.loc[feature_id][\"fill_colour\"] != \"default\":\n            stroke_colour = lovis4u.Methods.scale_lightness(self.feature_annotation.loc[feature_id][\"fill_colour\"],\n                                                            self.prms.args[\"feature_stroke_colour_relative_lightness\"])\n        default_values = dict(locus_id=locus_id, coordinates=coordinates, feature_type=feature_type,\n                              name=name, group=\"\", group_type=\"\", category=category, fill_colour=\"default\",\n                              stroke_colour=stroke_colour,\n                              show_label=show_label)\n        self.feature_annotation.loc[feature_id] = self.feature_annotation.loc[feature_id].fillna(default_values)\n        return None\n\n    def load_loci_from_extended_gff(self, input_f: str, ilund4u_mode: bool = False) -&gt; None:\n        \"\"\"Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide\n            sequence. Such files are produced for example by pharokka annotation tool.\n\n        All files with extension other than .gff (not case-sensitive) will be ignored.\n\n        Arguments:\n            input_folder: folder name with gff files.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        try:\n            if isinstance(input_f, str):\n                input_folder = input_f\n                if not os.path.exists(input_folder):\n                    raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n                gff_files = [os.path.join(input_folder, f) for f in os.listdir(input_folder)]\n            elif isinstance(input_f, list):\n                gff_files = input_f\n            else:\n                raise lovis4u.Manager.lovis4uError(f\"The input for the GFF parsing function must be either a folder or \"\n                                                   f\"a list of files.\")\n            if not gff_files:\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_f} does not contain files.\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u25cb Reading gff file{'s' if len(gff_files) &gt; 1 else ''}...\", file=sys.stdout)\n            for gff_file_path in gff_files:\n                try:\n                    gff_file = gff_file_path\n                    gff_records = list(BCBio.GFF.parse(gff_file_path, limit_info=dict(gff_type=[\"CDS\"])))\n                    if len(gff_records) != 1:\n                        print(f\"\u25cb Warning: gff file {gff_file} contains information for more than 1 \"\n                              f\"sequence. File will be skipped.\")\n                        continue\n                    gff_record = gff_records[0]\n                    try:\n                        record_locus_sequence = gff_record.seq\n                    except Bio.Seq.UndefinedSequenceError:\n                        print(f\"\u25cb Warning: gff file {gff_file} doesn't contain corresponding sequences.\")\n                        continue\n                    if self.prms.args[\"gff_description_source\"] in gff_record.annotations:\n                        record_description = gff_record.annotations[self.prms.args[\"gff_description_source\"]][0]\n                        if isinstance(record_description, tuple):\n                            record_description = \" \".join(record_description)\n                    else:\n                        record_description = \"\"\n                    if self.prms.args[\"use_filename_as_contig_id\"]:\n                        gff_record.id = os.path.splitext(os.path.basename(gff_file))[0]\n                    self.__update_locus_annotation(gff_record.id, record_description, len(record_locus_sequence))\n                    locus_annotation_row = self.locus_annotation.loc[gff_record.id]\n                    coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                                   locus_annotation_row[\"coordinates\"].split(\",\")]\n                    record_locus = Locus(seq_id=gff_record.id, coordinates=coordinates,\n                                         description=locus_annotation_row[\"description\"],\n                                         circular=locus_annotation_row[\"circular\"],\n                                         length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                         order=locus_annotation_row[\"order\"])\n                    features_ids = [i.id for i in gff_record.features]\n                    if len(features_ids) != len(set(features_ids)):\n                        raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} contains duplicated feature ids while\"\n                                                           f\" only unique are allowed.\")\n                    for gff_feature in gff_record.features:\n                        feature_id = gff_feature.id\n                        if ilund4u_mode:\n                            if gff_record.id not in feature_id:\n                                feature_id = f\"{gff_record.id}-{feature_id}\"\n                        transl_table = self.prms.args[\"default_transl_table\"]\n                        if \"transl_table\" in gff_feature.qualifiers.keys():\n                            transl_table = int(gff_feature.qualifiers[\"transl_table\"][0])\n                        name = \"\"\n                        if self.prms.args[\"gff_CDS_name_source\"] in gff_feature.qualifiers:\n                            name = gff_feature.qualifiers[self.prms.args[\"gff_CDS_name_source\"]][0]\n                        category = \"\"\n                        if self.prms.args[\"gff_CDS_category_source\"] in gff_feature.qualifiers:\n                            category = \",\".join(gff_feature.qualifiers[self.prms.args[\"gff_CDS_category_source\"]])\n                        for coordinate in record_locus.coordinates:\n                            overlapping = False\n                            start, end = coordinate[\"start\"], coordinate[\"end\"]\n                            if start &lt;= gff_feature.location.start + 1 &lt;= end or start &lt;= gff_feature.location.end &lt;= end:\n                                overlapping = True\n                                break\n                        if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                            continue\n                        self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                         f\"{int(gff_feature.location.start) + 1}:\"\n                                                         f\"{int(gff_feature.location.end)}:{gff_feature.location.strand}\",\n                                                         \"CDS\", category, name)\n                        feature_annotation_row = self.feature_annotation.loc[feature_id]\n                        feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                          feature_id=feature_id, start=int(gff_feature.location.start) + 1,\n                                          end=int(gff_feature.location.end), strand=gff_feature.location.strand,\n                                          name=feature_annotation_row[\"name\"],\n                                          sequence=gff_feature.translate(record_locus_sequence, table=transl_table,\n                                                                         cds=False)[:-1],\n                                          group=feature_annotation_row[\"group\"],\n                                          group_type=feature_annotation_row[\"group_type\"],\n                                          category=feature_annotation_row[\"category\"],\n                                          vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                        stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                        show_label=feature_annotation_row[\"show_label\"]),\n                                          overlapping=overlapping, parameters=self.prms)\n                        record_locus.features.append(feature)\n                    self.loci.append(record_locus)\n                except:\n                    print(f\"\u25cb Warning: gff file {gff_file} was not read properly and skipped\")\n                    if self.prms.args[\"parsing_debug\"]:\n                        self.prms.args[\"debug\"] = True\n                        raise lovis4u.Manager.lovis4uError()\n            seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n            loci_ids = [l.seq_id for l in self.loci]\n            if len(loci_ids) != len(set(loci_ids)):\n                raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                                   f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                                   f\"as contig id which can help to fix the problem.\")\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                      f\"files folder\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gff folder.\") from error\n\n    def load_loci_from_gb(self, input_folder: str) -&gt; None:\n        \"\"\"Load loci from the folder with genbank files.\n\n        All files with extension other than .gb (not case-sensitive) will be ignored.\n\n        Arguments:\n            input_folder: folder name with gb files.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not os.path.exists(input_folder):\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n        try:\n            gb_files = [f for f in os.listdir(input_folder)]\n            if not gb_files:\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain files.\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u25cb Reading gb file{'s' if len(gb_files) &gt; 1 else ''}...\", file=sys.stdout)\n            for gb_file in gb_files:\n                try:\n                    gb_file_path = os.path.join(input_folder, gb_file)\n                    gb_records = list(Bio.SeqIO.parse(gb_file_path, \"genbank\"))\n                    if len(gb_records) != 1:\n                        print(f\"\u25cb Warning: gb file {gb_file} contains information for more than 1 \"\n                              f\"sequence. File will be skipped.\")\n                        continue\n                    gb_record = gb_records[0]\n                    record_locus_sequence = gb_record.seq\n                    if self.prms.args[\"genbank_description_source\"] == \"description\":\n                        record_description = gb_record.description\n                    elif \"annotations:\" in self.prms.args[\"genbank_description_source\"]:\n                        feature_description_key = self.prms.args[\"genbank_description_source\"].split(\":\")[1]\n                        record_description = gb_record.annotations[feature_description_key]\n                    else:\n                        record_description = \"\"\n                    if self.prms.args[\"use_filename_as_contig_id\"]:\n                        gb_record.id = os.path.splitext(os.path.basename(gb_file))[0]\n                    self.__update_locus_annotation(gb_record.id, record_description, len(record_locus_sequence))\n                    locus_annotation_row = self.locus_annotation.loc[gb_record.id]\n                    coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                                   locus_annotation_row[\"coordinates\"].split(\",\")]\n                    record_locus = Locus(seq_id=gb_record.id, coordinates=coordinates,\n                                         description=locus_annotation_row[\"description\"],\n                                         circular=locus_annotation_row[\"circular\"],\n                                         length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                         order=locus_annotation_row[\"order\"])\n\n                    gb_CDSs = [i for i in gb_record.features if i.type == \"CDS\"]\n                    first_CDS_record = gb_CDSs[0]\n                    id_source = self.prms.args[\"genbank_id_source\"]\n                    if self.prms.args[\"genbank_id_source\"] not in first_CDS_record.qualifiers:\n                        for alternative_id_source in self.prms.args[\"genbank_id_alternative_source\"]:\n                            if alternative_id_source in first_CDS_record.qualifiers:\n                                id_source = alternative_id_source\n                                if self.prms.args[\"verbose\"]:\n                                    print(f\"\u25cb Warning: there is no &lt;{self.prms.args['genbank_id_source']}&gt; attribute \"\n                                          f\"for CDS records in {gb_file}. Alternative &lt;{id_source}&gt; was used instead.\",\n                                          file=sys.stdout)\n                                break\n                        if id_source == self.prms.args[\"genbank_id_source\"]:\n                            print(f\"There is no &lt;{self.prms.args['genbank_id_source']}&gt; \"\n                                  f\"attribute for CDS record found in {gb_file}. We tried to\"\n                                  f\" find any from the alternative list: \"\n                                  f\"{','.join(self.prms.args['genbank_id_alternative_source'])}\"\n                                  f\", but they also weren't found.\")  # add about cmd parameter\n                    features_ids = [i.qualifiers[id_source][0] for i in gb_CDSs]\n                    if len(features_ids) != len(set(features_ids)):\n                        print(f\"GB file {gb_record} contains duplicated feature ids while\"\n                                                           f\" only unique are allowed.\")\n\n                    for gb_feature in gb_CDSs:\n                        feature_id = gb_feature.qualifiers[id_source][0].replace(\"|\", \"_\")\n                        transl_table = self.prms.args[\"default_transl_table\"]\n                        if \"transl_table\" in gb_feature.qualifiers.keys():\n                            transl_table = int(gb_feature.qualifiers[\"transl_table\"][0])\n                        name = \"\"\n                        if self.prms.args[\"genbank_CDS_name_source\"] in gb_feature.qualifiers:\n                            name = gb_feature.qualifiers[self.prms.args[\"genbank_CDS_name_source\"]][0]\n                        category = \"\"\n                        if self.prms.args[\"genbank_CDS_category_source\"] in gb_feature.qualifiers:\n                            category = \",\".join(gb_feature.qualifiers[self.prms.args[\"genbank_CDS_category_source\"]])\n\n                        for coordinate in record_locus.coordinates:\n                            overlapping = False\n                            start, end = coordinate[\"start\"], coordinate[\"end\"]\n                            if start &lt;= gb_feature.location.start + 1 &lt;= end or start &lt;= gb_feature.location.end &lt;= end:\n                                overlapping = True\n                                break\n                        if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                            continue\n                        self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                         f\"{int(gb_feature.location.start) + 1}:\"\n                                                         f\"{int(gb_feature.location.end)}:\"\n                                                         f\"{gb_feature.location.strand}\", \"CDS\", category, name)\n                        feature_annotation_row = self.feature_annotation.loc[feature_id]\n                        feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                          feature_id=feature_id, start=int(gb_feature.location.start) + 1,\n                                          end=int(gb_feature.location.end),\n                                          strand=gb_feature.location.strand,\n                                          name=feature_annotation_row[\"name\"],\n                                          sequence=gb_feature.translate(record_locus_sequence,\n                                                                        table=transl_table,\n                                                                        cds=False)[:-1],\n                                          group=feature_annotation_row[\"group\"],\n                                          group_type=feature_annotation_row[\"group_type\"],\n                                          category=feature_annotation_row[\"category\"],\n                                          vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                        stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                        show_label=feature_annotation_row[\"show_label\"]),\n                                          overlapping = overlapping,\n                                          parameters=self.prms)\n\n                        record_locus.features.append(feature)\n                    self.loci.append(record_locus)\n                except:\n                    print(f\"\u25cb Warning: gb file {gb_file} was not read properly and skipped\")\n                    if self.prms.args[\"parsing_debug\"]:\n                        self.prms.args[\"debug\"] = True\n                        raise lovis4u.Manager.lovis4uError()\n            seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n            loci_ids = [l.seq_id for l in self.loci]\n            if len(loci_ids) != len(set(loci_ids)):\n                raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                                   f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                                   f\"as contig id which can help to fix the problem.\")\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                      f\"files folder\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gb folder.\") from error\n\n    def save_locus_annotation_table(self) -&gt; None:\n        \"\"\"Save loci annotation table to the output folder.\n\n        Output file name is locus_annotation_table.tsv\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"locus_annotation_table.tsv\")\n            self.locus_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"sequence_id\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Loci annotation table was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to save loci annotation table.\") from error\n\n    def save_feature_annotation_table(self) -&gt; None:\n        \"\"\"Save feature annotation table to the output folder.\n\n        Output file name is feature_annotation_table.tsv\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"feature_annotation_table.tsv\")\n            self.feature_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"feature_id\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Feature annotation table was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to save feature annotation table.\") from error\n\n    def mmseqs_cluster(self) -&gt; pd.DataFrame:\n        \"\"\"Cluster all proteins using mmseqs in order to define groups of homologues.\n\n        Returns:\n            pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is\n                defined by representative sequence id within a corresponding cluster.\n\n        \"\"\"\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u25cb Running mmseqs for protein clustering...\", file=sys.stdout)\n        try:\n            feature_records = [feature.record for locus in self.loci for feature in locus.features]\n            temp_input = tempfile.NamedTemporaryFile()\n            Bio.SeqIO.write(feature_records, temp_input.name, \"fasta\")\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            mmseqs_output_folder = os.path.join(self.prms.args[\"output_dir\"], \"mmseqs\")\n            if os.path.exists(mmseqs_output_folder):\n                shutil.rmtree(mmseqs_output_folder)\n            os.mkdir(mmseqs_output_folder)\n            Bio.SeqIO.write(feature_records, os.path.join(mmseqs_output_folder, \"input_proteins.fa\"), \"fasta\")\n            mmseqs_output_folder_db = os.path.join(mmseqs_output_folder, \"DB\")\n            os.mkdir(mmseqs_output_folder_db)\n            mmseqs_stdout = open(os.path.join(mmseqs_output_folder, \"mmseqs_stdout.txt\"), \"w\")\n            mmseqs_stderr = open(os.path.join(mmseqs_output_folder, \"mmseqs_stderr.txt\"), \"w\")\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createdb\", temp_input.name,\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\")], stdout=mmseqs_stdout,\n                           stderr=mmseqs_stderr)\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"cluster\",\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"tmp\"),\n                            \"--cluster-mode\", str(self.prms.args[\"mmseqs_cluster_mode\"]),\n                            \"--cov-mode\", str(self.prms.args[\"mmseqs_cov_mode\"]),\n                            \"--min-seq-id\", str(self.prms.args[\"mmseqs_min_seq_id\"]),\n                            \"-c\", str(self.prms.args[\"mmseqs_c\"]),\n                            \"-s\", str(self.prms.args[\"mmseqs_s\"])], stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createtsv\",\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                            os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\")],\n                           stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n            mmseqs_clustering_results = pd.read_table(os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\"),\n                                                      sep=\"\\t\", header=None, names=[\"cluster\", \"protein_id\"])\n            mmseqs_clustering_results = mmseqs_clustering_results.set_index(\"protein_id\")\n\n            num_of_unique_clusters = len(set(mmseqs_clustering_results[\"cluster\"].to_list()))\n            num_of_proteins = len(mmseqs_clustering_results.index)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {num_of_unique_clusters} clusters for {num_of_proteins} proteins were found with mmseqs\\n\"\n                      f\"    mmseqs clustering results were saved to \"\n                      f\"{os.path.join(mmseqs_output_folder, 'mmseqs_clustering.tsv')}\", file=sys.stdout)\n            return mmseqs_clustering_results\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to run mmseqs clustering.\") from error\n\n    def define_feature_groups(self, dataframe: pd.DataFrame, group_column_name: str = \"cluster\") -&gt; None:\n        \"\"\"Set features attribute \"group\" based on input dataframe.\n\n        By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed\n            feature groups you can set them with feature table.\n\n        Arguments:\n            dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n            group_column_name (str): column name of the dataframe that represent corresponding group to each feature.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n\n            for locus in self.loci:\n                for feature in locus.features:\n                    if feature.group and self.prms.args[\"keep_predefined_groups\"]:\n                        continue\n                    feature.group = dataframe.loc[feature.feature_id, group_column_name]\n                    self.feature_annotation.loc[feature.feature_id, \"group\"] = feature.group\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define protein features groups.\") from error\n\n    def remove_non_overlapping_features(self) -&gt; None:\n        \"\"\"Removes features that are not overlapping with visualisation window.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            ids_of_non_overlapping_objects = []\n            for locus in self.loci:\n                ids_of_non_overlapping_objects += [obj.feature_id for obj in locus.features if not obj.overlapping]\n                filtered_objects = [obj for obj in locus.features if obj.overlapping]\n                locus.features = filtered_objects\n            self.feature_annotation = self.feature_annotation.drop(ids_of_non_overlapping_objects)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to clean non overlapping features.\") from error\n\n    def define_labels_to_be_shown(self):\n        \"\"\"Set feature visaulisation attribute \"show_label\" based on feature groups.\n\n        controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and\n            feature_group_types_to_show_label_on_first_occurrence parameters.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            added_first_occurrence_labels = []\n            for locus in self.loci:\n                for feature in locus.features:\n                    if self.prms.args[\"show_all_feature_labels\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                        continue\n                    if feature.vis_prms[\"label\"] not in self.prms.args[\"feature_labels_to_ignore\"]:\n                        if \"any\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n                            feature.vis_prms[\"show_label\"] = 1\n                        elif feature.group_type in self.prms.args[\"feature_group_types_to_show_label\"]:\n                            feature.vis_prms[\"show_label\"] = 1\n                        elif feature.group_type in \\\n                                self.prms.args[\"feature_group_types_to_show_label_on_first_occurrence\"]:\n                            if feature.group not in added_first_occurrence_labels:\n                                feature.vis_prms[\"show_label\"] = 1\n                                added_first_occurrence_labels.append(feature.group)\n                    else:\n                        feature.vis_prms[\"show_label\"] = 0\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable define feature labels to be shown.\") from error\n\n    def cluster_sequences(self, dataframe: pd.DataFrame, one_cluster: bool) -&gt; None:\n        \"\"\"Define loci order and clusters with proteome similarity based hierarchical clustering.\n            This function changes the order of loci that are plotted and also updates corresponding to each loci group\n            attribute which defines homologues groups of proteomes.\n\n        It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n            groups by other method you can also build pandas dataframe based on that with index corresponding to\n            feature id and column \"cluster\" corresponding to the group.\n\n        Arguments:\n              dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n                one_cluster (bool): consider all sequences to be members of one cluster, but still define the\n                optimal order.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            proteins_loci_dict = collections.defaultdict(collections.deque)\n            loci_clusters_dict = dict()\n            number_of_loci = len(self.loci)\n            if number_of_loci &lt; 2:\n                return None\n            proteome_sizes = pd.Series(np.zeros(number_of_loci, dtype=int))\n            for locus_index in range(number_of_loci):\n                locus = self.loci[locus_index]\n                loci_clusters = [dataframe.loc[feature.feature_id, \"cluster\"] for feature in locus.features]\n                loci_clusters_dict[locus_index] = list(set(loci_clusters))\n                proteome_sizes.iloc[locus_index] = len(set(loci_clusters))\n                for l_cl in loci_clusters:\n                    proteins_loci_dict[l_cl].append(locus_index)\n\n            loci_ids = [locus.seq_id for locus in self.loci]\n            similarity_matrix = pd.DataFrame(0.0, index=loci_ids, columns=loci_ids)\n            for locus_index in range(number_of_loci):\n                counts = pd.Series(np.zeros(number_of_loci, dtype=int))\n                for cluster in loci_clusters_dict[locus_index]:\n                    js = proteins_loci_dict[cluster]\n                    counts.iloc[js] += 1\n                locus_size = proteome_sizes[locus_index]\n                norm_factors = pd.Series(0.5 * (locus_size + proteome_sizes) / (locus_size * proteome_sizes),\n                                         index=counts.index)\n                weights = counts.mul(norm_factors)\n                similarity_matrix.iloc[locus_index] = weights\n            symmetric_distance_matrix = 1 - similarity_matrix\n            np.fill_diagonal(symmetric_distance_matrix.values, 0)\n            linkage_matrix = scipy.cluster.hierarchy.linkage(\n                scipy.spatial.distance.squareform(symmetric_distance_matrix),\n                method=\"average\")\n            dendrogram = scipy.cluster.hierarchy.dendrogram(linkage_matrix, no_plot=True)\n            if not one_cluster:\n                clusters = pd.Series(scipy.cluster.hierarchy.fcluster(linkage_matrix,\n                                                                      self.prms.args[\"clustering_h_value\"],\n                                                                      criterion=\"distance\"),\n                                     index=loci_ids)\n                for locus in self.loci:\n                    locus.group = clusters[locus.seq_id]\n                    self.locus_annotation.loc[locus.seq_id, \"group\"] = locus.group\n            order = dendrogram[\"leaves\"][::-1]\n            self.locus_annotation[\"initial_order\"] = self.locus_annotation[\"order\"]\n            for locus_index in range(number_of_loci):\n                locus = self.loci[locus_index]\n                self.locus_annotation.loc[locus.seq_id, \"order\"] = order.index(locus_index)\n            self.locus_annotation.sort_values(by=\"order\", inplace=True)\n            seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n\n            reordered_similarity_matrix = similarity_matrix.reindex(index=self.locus_annotation.index,\n                                                                    columns=self.locus_annotation.index)\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"proteome_similarity_matrix.tsv\")\n            reordered_similarity_matrix.to_csv(file_path, sep=\"\\t\")\n            num_of_loci_groups = len(set(self.locus_annotation[\"group\"].to_list()))\n            if self.prms.args[\"verbose\"]:\n                if num_of_loci_groups == 1:\n                    print(f\"\u29bf Loci order and {num_of_loci_groups} cluster was defined with proteome similarity based \"\n                          f\"hierarchical clustering\", file=sys.stdout)\n                elif num_of_loci_groups &gt; 1:\n                    print(f\"\u29bf Loci order and {num_of_loci_groups} clusters were defined with proteome similarity based \"\n                          f\"hierarchical clustering\", file=sys.stdout)\n                print(f\"\u29bf Proteome similarity matrix of loci was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to cluster loci sequences.\") from error\n\n    def find_variable_feature_groups(self, mmseqs_results: pd.DataFrame) -&gt; None:\n        \"\"\"Define feature group type attributes (variable or conserved) based on their conservation in corresponding\n            loci group feature.\n\n        It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n            groups by other method you can also build pandas dataframe based on that with index corresponding to\n            feature id and column \"cluster\" corresponding to the group.\n\n        Arguments:\n              mmseqs_results (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_clusters_sizes = self.locus_annotation[\"group\"].value_counts()\n            loci_clusters_cutoff_v = np.round(self.prms.args[\"CDS_is_variable_cutoff\"] * loci_clusters_sizes).astype(\n                int)\n            loci_clusters_cutoff_c = np.round(self.prms.args[\"CDF_is_conserved_cutoff\"] * loci_clusters_sizes).astype(\n                int)\n            loci_clusters_cutoff_v[loci_clusters_cutoff_v == 0] = 1\n            cluster_types = collections.defaultdict(dict)\n            for cluster in set(mmseqs_results[\"cluster\"].to_list()):\n                cluster_proteins = mmseqs_results[mmseqs_results[\"cluster\"] == cluster].index\n                cluster_loci = [locus for locus in self.loci if\n                                any(feature.feature_id in cluster_proteins for feature in locus.features)]\n                cluster_loci_groups = [locus.group for locus in cluster_loci]\n                for cluster_locus_group in cluster_loci_groups:\n                    current_group_cluster_loci = [locus.seq_id for locus in cluster_loci if\n                                                  locus.group == cluster_locus_group]\n                    current_group_cluster_size = len(set(current_group_cluster_loci))\n                    if loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                            current_group_cluster_size &lt;= loci_clusters_cutoff_v[cluster_locus_group]:\n                        cluster_types[cluster_locus_group][cluster] = \"variable\"\n                    elif loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                            (loci_clusters_cutoff_v[cluster_locus_group] &lt; current_group_cluster_size &lt;\n                             loci_clusters_cutoff_c[cluster_locus_group]):\n                        cluster_types[cluster_locus_group][cluster] = \"intermediate\"\n                    else:\n                        cluster_types[cluster_locus_group][cluster] = \"conserved\"\n            for locus in self.loci:\n                locus_group = locus.group\n                for feature in locus.features:\n                    if feature.group_type and self.prms.args[\"keep_predefined_groups\"]:\n                        continue\n                    feature.group_type = cluster_types[locus_group][feature.group]\n                    self.feature_annotation.loc[feature.feature_id, \"group_type\"] = feature.group_type\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n\n    def set_feature_colours_based_on_groups(self) -&gt; None:\n        \"\"\"Define features fill colour based on corresponding feature group and group types.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            feature_groups = set([feature.group for locus in self.loci for feature in locus.features if feature.group])\n            if self.prms.args[\"feature_group_types_to_set_colour\"] and \\\n                    \"all\" not in self.prms.args[\"feature_group_types_to_set_colour\"]:\n                feature_groups = set([feature.group for locus in self.loci for feature in locus.features\n                                      if feature.group and feature.group_type in\n                                      self.prms.args[\"feature_group_types_to_set_colour\"]])\n            number_of_unique_feature_groups = len(feature_groups)\n            if self.prms.args[\"groups_fill_colour_palette_lib\"] == \"seaborn\":\n                colours_rgb = seaborn.color_palette(self.prms.args[\"groups_fill_colour_seaborn_palette\"],\n                                                    number_of_unique_feature_groups,\n                                                    desat=self.prms.args[\"groups_fill_colour_seaborn_desat\"])\n                random.shuffle(colours_rgb)\n            elif self.prms.args[\"groups_fill_colour_palette_lib\"] == \"distinctipy\":\n                colours_rgb = distinctipy.get_colors(number_of_unique_feature_groups,\n                                                     exclude_colours=[(1, 1, 1), (0, 0, 0)],\n                                                     pastel_factor=self.prms.args[\"groups_fill_colours_pastel_factor\"])\n            colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n            colours_dict = {g: c for g, c in zip(list(feature_groups), colours)}\n            for locus in self.loci:\n                for feature in locus.features:\n                    if feature.group in feature_groups:\n                        if self.prms.args[\"keep_predefined_colours\"] and feature.vis_prms[\"fill_colour\"] != \"default\":\n                            continue\n                        feature.vis_prms[\"fill_colour\"] = colours_dict[feature.group]\n                        self.feature_annotation.loc[feature.feature_id, \"fill_colour\"] = feature.vis_prms[\"fill_colour\"]\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to set feature colours based on groups.\") from error\n\n    def set_category_colours(self, use_table: bool = True) -&gt; None:\n        \"\"\"Define colours for each category.\n\n        Arguments:\n            use_table (bool): Bool value whether table with predefined colours should be used or not.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            colours_dict = dict()\n            if use_table:\n                colours_dict.update(\n                    pd.read_table(self.prms.args[\"category_colours\"]).set_index(\"category\")[\"colour\"].to_dict())\n\n            feature_categories = list(set([feature.category for locus in self.loci for feature in locus.features\n                                           if feature.category and feature.category]))\n            if not feature_categories:\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb Warning: there are no feature categories to set colours\", file=sys.stdout)\n            colours_dict = {cat: col for cat, col in colours_dict.items() if cat in feature_categories}\n\n            feature_categories = [ff for ff in feature_categories if ff not in colours_dict.keys()]\n            number_of_unique_feature_functions = len(feature_categories)\n            colours_rgb = seaborn.color_palette(self.prms.args[\"category_colour_seaborn_palette\"],\n                                                number_of_unique_feature_functions,\n                                                desat=self.prms.args[\"category_colour_seaborn_desat\"])\n            random.shuffle(colours_rgb)\n            colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n            colours_dict.update({g: c for g, c in zip(list(feature_categories), colours)})\n            for locus in self.loci:\n                locus.category_colours = colours_dict\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to set category colours.\") from error\n\n    def reorient_loci(self, ilund4u_mode: bool = False) -&gt; None:\n        \"\"\"Auto re-orient loci (reset strands) of loci if they are not matched.\n\n        Function tries to maximise co-orientation of homologous features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            count_of_changed_strands = 0\n            loci = [locus for locus in self.loci]\n            for locus_index in range(1, len(loci)):\n                p_locus = loci[locus_index - 1]\n                c_locus = loci[locus_index]\n                p_locus_strands = list(set([c[\"strand\"] for c in p_locus.coordinates]))\n                c_locus_strands = list(set([c[\"strand\"] for c in c_locus.coordinates]))\n                if len(p_locus_strands) == 1 and len(c_locus_strands) == 1:\n                    if not ilund4u_mode:\n                        pr_locus_features_groups = set([f.group for f in p_locus.features])\n                        c_locus_features_groups = set([f.group for f in c_locus.features])\n                    else:\n                        pr_locus_features_groups = set(\n                            [f.group for f in p_locus.features if f.group_type == \"conserved\"])\n                        c_locus_features_groups = set(\n                            [f.group for f in c_locus.features if f.group_type == \"conserved\"])\n                    overlapped_f_groups = pr_locus_features_groups &amp; c_locus_features_groups\n                    prl_strand, cl_strand = p_locus_strands[0], c_locus_strands[0]\n                    pr_locus_features_strands = {f.group: f.strand * prl_strand for f in p_locus.features if\n                                                 f.group in overlapped_f_groups}\n                    c_locus_features_strands = {f.group: f.strand * cl_strand for f in c_locus.features if\n                                                f.group in overlapped_f_groups}\n                    codirection_score = 0\n\n                    for ovg in overlapped_f_groups:\n                        codirection_score += pr_locus_features_strands[ovg] * c_locus_features_strands[ovg]\n                    if codirection_score &lt; 0:\n                        count_of_changed_strands += 1\n                        annot_coordinates = []\n                        for cc in loci[locus_index].coordinates:\n                            cc[\"strand\"] *= -1\n                            annot_coordinates.append(f\"{cc['start']}:{cc['end']}:{cc['strand']}\")\n                        loci[locus_index].coordinates = loci[locus_index].coordinates[::-1]\n                        annot_coordinates = annot_coordinates[::-1]\n                        self.locus_annotation.loc[c_locus.seq_id, \"coordinates\"] = \",\".join(annot_coordinates)\n                else:\n                    if self.prms.args[\"verbose\"]:\n                        print(\"\u25cb Warning: loci reorientation cannot be applied for loci that have both strands in\"\n                              \" pre-defined coordinates for visualisation\")\n            if self.prms.args[\"verbose\"]:\n                if count_of_changed_strands == 0:\n                    print(f\"\u29bf Orientation was not changed for any locus\", file=sys.stdout)\n                elif count_of_changed_strands == 1:\n                    print(f\"\u29bf Orientation was changed for 1 locus\", file=sys.stdout)\n                elif count_of_changed_strands &gt; 1:\n                    print(f\"\u29bf Orientation was changed for {count_of_changed_strands} loci\", file=sys.stdout)\n\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n\n    def get_loci_lengths_and_n_of_regions(self) -&gt; list[list[int]]:\n        \"\"\"Get loci lengths and number of regions.\n\n        Returns:\n            list: list each element of each contains locus size and number of breaks for visualisation track.\n\n        \"\"\"\n        try:\n            loci_sizes = []\n            for locus in self.loci:\n                number_of_gaps = len(locus.coordinates) - 1\n                if locus.circular:\n                    for i in range(number_of_gaps):\n                        if locus.coordinates[i][\"end\"] == locus.length and locus.coordinates[i + 1][\"start\"] == 1:\n                            number_of_gaps -= 1\n                loci_sizes.append([locus.size, number_of_gaps])\n            return loci_sizes\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to get loci lengths.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__init__","title":"<code>__init__(parameters=lovis4u.Manager.Parameters)</code>","text":"<p>Create a Loci object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>, default:                 <code>Parameters</code> )         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, parameters=lovis4u.Manager.Parameters):\n    \"\"\"Create a Loci object.\n\n    Arguments:\n        parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n    \"\"\"\n    self.loci = []\n    self.locus_annotation = pd.DataFrame(columns=[\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\",\n                                                  \"order\", \"group\"]).set_index(\"sequence_id\")\n    self.feature_annotation = pd.DataFrame(columns=[\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\",\n                                                    \"group\", \"group_type\", \"category\", \"fill_colour\",\n                                                    \"stroke_colour\",\n                                                    \"show_label\"]).set_index(\"feature_id\")\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__load_annotation_file","title":"<code>__load_annotation_file(file_path, annotation_columns, index_column)</code>","text":"<p>Private method to load an annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for an annotation file to be loaded.</p> </li> <li> <code>annotation_columns</code>             (<code>list</code>)         \u2013          <p>List of columns that should be considered.</p> </li> <li> <code>index_column</code>             (<code>str</code>)         \u2013          <p>Column name to be considered as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>pd.DataFrame: Preprocessed annotation file.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __load_annotation_file(self, file_path: str, annotation_columns: list, index_column: str) -&gt; pd.DataFrame:\n    \"\"\"Private method to load an annotation file.\n\n    Arguments:\n        file_path (str): File path for an annotation file to be loaded.\n        annotation_columns (list): List of columns that should be considered.\n        index_column (str): Column name to be considered as index.\n\n    Returns:\n          pd.DataFrame: Preprocessed annotation file.\n    \"\"\"\n    annotation_table = pd.read_table(file_path)\n    found_allowed_columns = [i for i in annotation_columns if i in annotation_table.columns]\n    not_found_allowed_columns = [i for i in annotation_columns if i not in annotation_table.columns]\n    annotation_table = annotation_table[found_allowed_columns].set_index(index_column)\n    annotation_table[not_found_allowed_columns] = None\n    return annotation_table\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__update_feature_annotation","title":"<code>__update_feature_annotation(feature_id, locus_id, coordinates, feature_type, category, name)</code>","text":"<p>Private method for updating feature annotation.</p> <p>Parameters:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>locus_id</code>             (<code>str</code>)         \u2013          <p>Sequence description.</p> </li> <li> <code>coordinates</code>             (<code>str</code>)         \u2013          <p>Feature coordinates.</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature type.</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Feature name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __update_feature_annotation(self, feature_id: str, locus_id: str, coordinates: str, feature_type: str,\n                                category: str, name: str) -&gt; None:\n    \"\"\"Private method for updating feature annotation.\n\n    Arguments:\n        feature_id (str): Feature identifier.\n        locus_id (str): Sequence description.\n        coordinates (str): Feature coordinates.\n        category (str): Feature type.\n        name (str): Feature name.\n\n\n    Returns:\n        None\n\n    \"\"\"\n    if feature_id not in self.feature_annotation.index:\n        self.feature_annotation.loc[feature_id] = {col: None for col in self.feature_annotation.columns}\n\n    if self.feature_annotation.loc[feature_id][\"group_type\"] in self.prms.args[\"feature_group_types_to_show_label\"] \\\n            or \"all\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n        show_label = 1\n    else:\n        show_label = 0\n    stroke_colour = \"default\"\n    if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n            self.feature_annotation.loc[feature_id][\"fill_colour\"] and \\\n            self.feature_annotation.loc[feature_id][\"fill_colour\"] != \"default\":\n        stroke_colour = lovis4u.Methods.scale_lightness(self.feature_annotation.loc[feature_id][\"fill_colour\"],\n                                                        self.prms.args[\"feature_stroke_colour_relative_lightness\"])\n    default_values = dict(locus_id=locus_id, coordinates=coordinates, feature_type=feature_type,\n                          name=name, group=\"\", group_type=\"\", category=category, fill_colour=\"default\",\n                          stroke_colour=stroke_colour,\n                          show_label=show_label)\n    self.feature_annotation.loc[feature_id] = self.feature_annotation.loc[feature_id].fillna(default_values)\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__update_locus_annotation","title":"<code>__update_locus_annotation(record_id, record_description, record_length)</code>","text":"<p>Private method for updating loci annotation.</p> <p>Parameters:</p> <ul> <li> <code>record_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier.</p> </li> <li> <code>record_description</code>             (<code>str</code>)         \u2013          <p>Sequence description.</p> </li> <li> <code>record_length</code>             (<code>int</code>)         \u2013          <p>Sequence length.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __update_locus_annotation(self, record_id: str, record_description: str, record_length: int) -&gt; None:\n    \"\"\"Private method for updating loci annotation.\n\n    Arguments:\n        record_id (str): Sequence identifier.\n        record_description (str): Sequence description.\n        record_length (int): Sequence length.\n\n    Returns:\n        None\n\n    \"\"\"\n    if record_id not in self.locus_annotation.index:\n        self.locus_annotation.loc[record_id] = {col: None for col in self.locus_annotation.columns}\n\n    default_values = dict(length=record_length, coordinates=f\"1:{record_length}:1\",\n                          description=record_description, circular=1, order=len(self.loci), group=1)\n    self.locus_annotation.loc[record_id] = self.locus_annotation.loc[record_id].fillna(default_values)\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.cluster_sequences","title":"<code>cluster_sequences(dataframe, one_cluster)</code>","text":"<p>Define loci order and clusters with proteome similarity based hierarchical clustering.     This function changes the order of loci that are plotted and also updates corresponding to each loci group     attribute which defines homologues groups of proteomes.</p> <p>It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues     groups by other method you can also build pandas dataframe based on that with index corresponding to     feature id and column \"cluster\" corresponding to the group.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features. one_cluster (bool): consider all sequences to be members of one cluster, but still define the optimal order.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def cluster_sequences(self, dataframe: pd.DataFrame, one_cluster: bool) -&gt; None:\n    \"\"\"Define loci order and clusters with proteome similarity based hierarchical clustering.\n        This function changes the order of loci that are plotted and also updates corresponding to each loci group\n        attribute which defines homologues groups of proteomes.\n\n    It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n        groups by other method you can also build pandas dataframe based on that with index corresponding to\n        feature id and column \"cluster\" corresponding to the group.\n\n    Arguments:\n          dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n            one_cluster (bool): consider all sequences to be members of one cluster, but still define the\n            optimal order.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        proteins_loci_dict = collections.defaultdict(collections.deque)\n        loci_clusters_dict = dict()\n        number_of_loci = len(self.loci)\n        if number_of_loci &lt; 2:\n            return None\n        proteome_sizes = pd.Series(np.zeros(number_of_loci, dtype=int))\n        for locus_index in range(number_of_loci):\n            locus = self.loci[locus_index]\n            loci_clusters = [dataframe.loc[feature.feature_id, \"cluster\"] for feature in locus.features]\n            loci_clusters_dict[locus_index] = list(set(loci_clusters))\n            proteome_sizes.iloc[locus_index] = len(set(loci_clusters))\n            for l_cl in loci_clusters:\n                proteins_loci_dict[l_cl].append(locus_index)\n\n        loci_ids = [locus.seq_id for locus in self.loci]\n        similarity_matrix = pd.DataFrame(0.0, index=loci_ids, columns=loci_ids)\n        for locus_index in range(number_of_loci):\n            counts = pd.Series(np.zeros(number_of_loci, dtype=int))\n            for cluster in loci_clusters_dict[locus_index]:\n                js = proteins_loci_dict[cluster]\n                counts.iloc[js] += 1\n            locus_size = proteome_sizes[locus_index]\n            norm_factors = pd.Series(0.5 * (locus_size + proteome_sizes) / (locus_size * proteome_sizes),\n                                     index=counts.index)\n            weights = counts.mul(norm_factors)\n            similarity_matrix.iloc[locus_index] = weights\n        symmetric_distance_matrix = 1 - similarity_matrix\n        np.fill_diagonal(symmetric_distance_matrix.values, 0)\n        linkage_matrix = scipy.cluster.hierarchy.linkage(\n            scipy.spatial.distance.squareform(symmetric_distance_matrix),\n            method=\"average\")\n        dendrogram = scipy.cluster.hierarchy.dendrogram(linkage_matrix, no_plot=True)\n        if not one_cluster:\n            clusters = pd.Series(scipy.cluster.hierarchy.fcluster(linkage_matrix,\n                                                                  self.prms.args[\"clustering_h_value\"],\n                                                                  criterion=\"distance\"),\n                                 index=loci_ids)\n            for locus in self.loci:\n                locus.group = clusters[locus.seq_id]\n                self.locus_annotation.loc[locus.seq_id, \"group\"] = locus.group\n        order = dendrogram[\"leaves\"][::-1]\n        self.locus_annotation[\"initial_order\"] = self.locus_annotation[\"order\"]\n        for locus_index in range(number_of_loci):\n            locus = self.loci[locus_index]\n            self.locus_annotation.loc[locus.seq_id, \"order\"] = order.index(locus_index)\n        self.locus_annotation.sort_values(by=\"order\", inplace=True)\n        seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n\n        reordered_similarity_matrix = similarity_matrix.reindex(index=self.locus_annotation.index,\n                                                                columns=self.locus_annotation.index)\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"proteome_similarity_matrix.tsv\")\n        reordered_similarity_matrix.to_csv(file_path, sep=\"\\t\")\n        num_of_loci_groups = len(set(self.locus_annotation[\"group\"].to_list()))\n        if self.prms.args[\"verbose\"]:\n            if num_of_loci_groups == 1:\n                print(f\"\u29bf Loci order and {num_of_loci_groups} cluster was defined with proteome similarity based \"\n                      f\"hierarchical clustering\", file=sys.stdout)\n            elif num_of_loci_groups &gt; 1:\n                print(f\"\u29bf Loci order and {num_of_loci_groups} clusters were defined with proteome similarity based \"\n                      f\"hierarchical clustering\", file=sys.stdout)\n            print(f\"\u29bf Proteome similarity matrix of loci was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to cluster loci sequences.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.define_feature_groups","title":"<code>define_feature_groups(dataframe, group_column_name='cluster')</code>","text":"<p>Set features attribute \"group\" based on input dataframe.</p> <p>By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed     feature groups you can set them with feature table.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> <li> <code>group_column_name</code>             (<code>str</code>, default:                 <code>'cluster'</code> )         \u2013          <p>column name of the dataframe that represent corresponding group to each feature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def define_feature_groups(self, dataframe: pd.DataFrame, group_column_name: str = \"cluster\") -&gt; None:\n    \"\"\"Set features attribute \"group\" based on input dataframe.\n\n    By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed\n        feature groups you can set them with feature table.\n\n    Arguments:\n        dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n        group_column_name (str): column name of the dataframe that represent corresponding group to each feature.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n\n        for locus in self.loci:\n            for feature in locus.features:\n                if feature.group and self.prms.args[\"keep_predefined_groups\"]:\n                    continue\n                feature.group = dataframe.loc[feature.feature_id, group_column_name]\n                self.feature_annotation.loc[feature.feature_id, \"group\"] = feature.group\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define protein features groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.define_labels_to_be_shown","title":"<code>define_labels_to_be_shown()</code>","text":"<p>Set feature visaulisation attribute \"show_label\" based on feature groups.</p> <p>controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and     feature_group_types_to_show_label_on_first_occurrence parameters.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def define_labels_to_be_shown(self):\n    \"\"\"Set feature visaulisation attribute \"show_label\" based on feature groups.\n\n    controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and\n        feature_group_types_to_show_label_on_first_occurrence parameters.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        added_first_occurrence_labels = []\n        for locus in self.loci:\n            for feature in locus.features:\n                if self.prms.args[\"show_all_feature_labels\"]:\n                    feature.vis_prms[\"show_label\"] = 1\n                    continue\n                if feature.vis_prms[\"label\"] not in self.prms.args[\"feature_labels_to_ignore\"]:\n                    if \"any\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                    elif feature.group_type in self.prms.args[\"feature_group_types_to_show_label\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                    elif feature.group_type in \\\n                            self.prms.args[\"feature_group_types_to_show_label_on_first_occurrence\"]:\n                        if feature.group not in added_first_occurrence_labels:\n                            feature.vis_prms[\"show_label\"] = 1\n                            added_first_occurrence_labels.append(feature.group)\n                else:\n                    feature.vis_prms[\"show_label\"] = 0\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable define feature labels to be shown.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.find_variable_feature_groups","title":"<code>find_variable_feature_groups(mmseqs_results)</code>","text":"<p>Define feature group type attributes (variable or conserved) based on their conservation in corresponding     loci group feature.</p> <p>It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues     groups by other method you can also build pandas dataframe based on that with index corresponding to     feature id and column \"cluster\" corresponding to the group.</p> <p>Parameters:</p> <ul> <li> <code>mmseqs_results</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def find_variable_feature_groups(self, mmseqs_results: pd.DataFrame) -&gt; None:\n    \"\"\"Define feature group type attributes (variable or conserved) based on their conservation in corresponding\n        loci group feature.\n\n    It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n        groups by other method you can also build pandas dataframe based on that with index corresponding to\n        feature id and column \"cluster\" corresponding to the group.\n\n    Arguments:\n          mmseqs_results (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_clusters_sizes = self.locus_annotation[\"group\"].value_counts()\n        loci_clusters_cutoff_v = np.round(self.prms.args[\"CDS_is_variable_cutoff\"] * loci_clusters_sizes).astype(\n            int)\n        loci_clusters_cutoff_c = np.round(self.prms.args[\"CDF_is_conserved_cutoff\"] * loci_clusters_sizes).astype(\n            int)\n        loci_clusters_cutoff_v[loci_clusters_cutoff_v == 0] = 1\n        cluster_types = collections.defaultdict(dict)\n        for cluster in set(mmseqs_results[\"cluster\"].to_list()):\n            cluster_proteins = mmseqs_results[mmseqs_results[\"cluster\"] == cluster].index\n            cluster_loci = [locus for locus in self.loci if\n                            any(feature.feature_id in cluster_proteins for feature in locus.features)]\n            cluster_loci_groups = [locus.group for locus in cluster_loci]\n            for cluster_locus_group in cluster_loci_groups:\n                current_group_cluster_loci = [locus.seq_id for locus in cluster_loci if\n                                              locus.group == cluster_locus_group]\n                current_group_cluster_size = len(set(current_group_cluster_loci))\n                if loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                        current_group_cluster_size &lt;= loci_clusters_cutoff_v[cluster_locus_group]:\n                    cluster_types[cluster_locus_group][cluster] = \"variable\"\n                elif loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                        (loci_clusters_cutoff_v[cluster_locus_group] &lt; current_group_cluster_size &lt;\n                         loci_clusters_cutoff_c[cluster_locus_group]):\n                    cluster_types[cluster_locus_group][cluster] = \"intermediate\"\n                else:\n                    cluster_types[cluster_locus_group][cluster] = \"conserved\"\n        for locus in self.loci:\n            locus_group = locus.group\n            for feature in locus.features:\n                if feature.group_type and self.prms.args[\"keep_predefined_groups\"]:\n                    continue\n                feature.group_type = cluster_types[locus_group][feature.group]\n                self.feature_annotation.loc[feature.feature_id, \"group_type\"] = feature.group_type\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.get_loci_lengths_and_n_of_regions","title":"<code>get_loci_lengths_and_n_of_regions()</code>","text":"<p>Get loci lengths and number of regions.</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list[list[int]]</code> )        \u2013          <p>list each element of each contains locus size and number of breaks for visualisation track.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def get_loci_lengths_and_n_of_regions(self) -&gt; list[list[int]]:\n    \"\"\"Get loci lengths and number of regions.\n\n    Returns:\n        list: list each element of each contains locus size and number of breaks for visualisation track.\n\n    \"\"\"\n    try:\n        loci_sizes = []\n        for locus in self.loci:\n            number_of_gaps = len(locus.coordinates) - 1\n            if locus.circular:\n                for i in range(number_of_gaps):\n                    if locus.coordinates[i][\"end\"] == locus.length and locus.coordinates[i + 1][\"start\"] == 1:\n                        number_of_gaps -= 1\n            loci_sizes.append([locus.size, number_of_gaps])\n        return loci_sizes\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to get loci lengths.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_feature_annotation_file","title":"<code>load_feature_annotation_file(file_path)</code>","text":"<p>Load features annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for a features annotation file to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_feature_annotation_file(self, file_path: str) -&gt; None:\n    \"\"\"Load features annotation file.\n\n    Arguments:\n        file_path (str): File path for a features annotation file to be loaded.\n\n    Returns:\n        None\n\n    \"\"\"\n    annotation_columns = [\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\", \"group\", \"group_type\",\n                          \"category\", \"fill_colour\", \"stroke_colour\", \"show_label\"]\n    self.feature_annotation = self.__load_annotation_file(file_path, annotation_columns, \"feature_id\")\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_loci_from_extended_gff","title":"<code>load_loci_from_extended_gff(input_f, ilund4u_mode=False)</code>","text":"<p>Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide     sequence. Such files are produced for example by pharokka annotation tool.</p> <p>All files with extension other than .gff (not case-sensitive) will be ignored.</p> <p>Parameters:</p> <ul> <li> <code>input_folder</code>         \u2013          <p>folder name with gff files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_from_extended_gff(self, input_f: str, ilund4u_mode: bool = False) -&gt; None:\n    \"\"\"Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide\n        sequence. Such files are produced for example by pharokka annotation tool.\n\n    All files with extension other than .gff (not case-sensitive) will be ignored.\n\n    Arguments:\n        input_folder: folder name with gff files.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    try:\n        if isinstance(input_f, str):\n            input_folder = input_f\n            if not os.path.exists(input_folder):\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n            gff_files = [os.path.join(input_folder, f) for f in os.listdir(input_folder)]\n        elif isinstance(input_f, list):\n            gff_files = input_f\n        else:\n            raise lovis4u.Manager.lovis4uError(f\"The input for the GFF parsing function must be either a folder or \"\n                                               f\"a list of files.\")\n        if not gff_files:\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_f} does not contain files.\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u25cb Reading gff file{'s' if len(gff_files) &gt; 1 else ''}...\", file=sys.stdout)\n        for gff_file_path in gff_files:\n            try:\n                gff_file = gff_file_path\n                gff_records = list(BCBio.GFF.parse(gff_file_path, limit_info=dict(gff_type=[\"CDS\"])))\n                if len(gff_records) != 1:\n                    print(f\"\u25cb Warning: gff file {gff_file} contains information for more than 1 \"\n                          f\"sequence. File will be skipped.\")\n                    continue\n                gff_record = gff_records[0]\n                try:\n                    record_locus_sequence = gff_record.seq\n                except Bio.Seq.UndefinedSequenceError:\n                    print(f\"\u25cb Warning: gff file {gff_file} doesn't contain corresponding sequences.\")\n                    continue\n                if self.prms.args[\"gff_description_source\"] in gff_record.annotations:\n                    record_description = gff_record.annotations[self.prms.args[\"gff_description_source\"]][0]\n                    if isinstance(record_description, tuple):\n                        record_description = \" \".join(record_description)\n                else:\n                    record_description = \"\"\n                if self.prms.args[\"use_filename_as_contig_id\"]:\n                    gff_record.id = os.path.splitext(os.path.basename(gff_file))[0]\n                self.__update_locus_annotation(gff_record.id, record_description, len(record_locus_sequence))\n                locus_annotation_row = self.locus_annotation.loc[gff_record.id]\n                coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                               locus_annotation_row[\"coordinates\"].split(\",\")]\n                record_locus = Locus(seq_id=gff_record.id, coordinates=coordinates,\n                                     description=locus_annotation_row[\"description\"],\n                                     circular=locus_annotation_row[\"circular\"],\n                                     length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                     order=locus_annotation_row[\"order\"])\n                features_ids = [i.id for i in gff_record.features]\n                if len(features_ids) != len(set(features_ids)):\n                    raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} contains duplicated feature ids while\"\n                                                       f\" only unique are allowed.\")\n                for gff_feature in gff_record.features:\n                    feature_id = gff_feature.id\n                    if ilund4u_mode:\n                        if gff_record.id not in feature_id:\n                            feature_id = f\"{gff_record.id}-{feature_id}\"\n                    transl_table = self.prms.args[\"default_transl_table\"]\n                    if \"transl_table\" in gff_feature.qualifiers.keys():\n                        transl_table = int(gff_feature.qualifiers[\"transl_table\"][0])\n                    name = \"\"\n                    if self.prms.args[\"gff_CDS_name_source\"] in gff_feature.qualifiers:\n                        name = gff_feature.qualifiers[self.prms.args[\"gff_CDS_name_source\"]][0]\n                    category = \"\"\n                    if self.prms.args[\"gff_CDS_category_source\"] in gff_feature.qualifiers:\n                        category = \",\".join(gff_feature.qualifiers[self.prms.args[\"gff_CDS_category_source\"]])\n                    for coordinate in record_locus.coordinates:\n                        overlapping = False\n                        start, end = coordinate[\"start\"], coordinate[\"end\"]\n                        if start &lt;= gff_feature.location.start + 1 &lt;= end or start &lt;= gff_feature.location.end &lt;= end:\n                            overlapping = True\n                            break\n                    if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                        continue\n                    self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                     f\"{int(gff_feature.location.start) + 1}:\"\n                                                     f\"{int(gff_feature.location.end)}:{gff_feature.location.strand}\",\n                                                     \"CDS\", category, name)\n                    feature_annotation_row = self.feature_annotation.loc[feature_id]\n                    feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                      feature_id=feature_id, start=int(gff_feature.location.start) + 1,\n                                      end=int(gff_feature.location.end), strand=gff_feature.location.strand,\n                                      name=feature_annotation_row[\"name\"],\n                                      sequence=gff_feature.translate(record_locus_sequence, table=transl_table,\n                                                                     cds=False)[:-1],\n                                      group=feature_annotation_row[\"group\"],\n                                      group_type=feature_annotation_row[\"group_type\"],\n                                      category=feature_annotation_row[\"category\"],\n                                      vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                    stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                    show_label=feature_annotation_row[\"show_label\"]),\n                                      overlapping=overlapping, parameters=self.prms)\n                    record_locus.features.append(feature)\n                self.loci.append(record_locus)\n            except:\n                print(f\"\u25cb Warning: gff file {gff_file} was not read properly and skipped\")\n                if self.prms.args[\"parsing_debug\"]:\n                    self.prms.args[\"debug\"] = True\n                    raise lovis4u.Manager.lovis4uError()\n        seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n        loci_ids = [l.seq_id for l in self.loci]\n        if len(loci_ids) != len(set(loci_ids)):\n            raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                               f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                               f\"as contig id which can help to fix the problem.\")\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                  f\"files folder\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gff folder.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_loci_from_gb","title":"<code>load_loci_from_gb(input_folder)</code>","text":"<p>Load loci from the folder with genbank files.</p> <p>All files with extension other than .gb (not case-sensitive) will be ignored.</p> <p>Parameters:</p> <ul> <li> <code>input_folder</code>             (<code>str</code>)         \u2013          <p>folder name with gb files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_from_gb(self, input_folder: str) -&gt; None:\n    \"\"\"Load loci from the folder with genbank files.\n\n    All files with extension other than .gb (not case-sensitive) will be ignored.\n\n    Arguments:\n        input_folder: folder name with gb files.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not os.path.exists(input_folder):\n        raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n    try:\n        gb_files = [f for f in os.listdir(input_folder)]\n        if not gb_files:\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain files.\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u25cb Reading gb file{'s' if len(gb_files) &gt; 1 else ''}...\", file=sys.stdout)\n        for gb_file in gb_files:\n            try:\n                gb_file_path = os.path.join(input_folder, gb_file)\n                gb_records = list(Bio.SeqIO.parse(gb_file_path, \"genbank\"))\n                if len(gb_records) != 1:\n                    print(f\"\u25cb Warning: gb file {gb_file} contains information for more than 1 \"\n                          f\"sequence. File will be skipped.\")\n                    continue\n                gb_record = gb_records[0]\n                record_locus_sequence = gb_record.seq\n                if self.prms.args[\"genbank_description_source\"] == \"description\":\n                    record_description = gb_record.description\n                elif \"annotations:\" in self.prms.args[\"genbank_description_source\"]:\n                    feature_description_key = self.prms.args[\"genbank_description_source\"].split(\":\")[1]\n                    record_description = gb_record.annotations[feature_description_key]\n                else:\n                    record_description = \"\"\n                if self.prms.args[\"use_filename_as_contig_id\"]:\n                    gb_record.id = os.path.splitext(os.path.basename(gb_file))[0]\n                self.__update_locus_annotation(gb_record.id, record_description, len(record_locus_sequence))\n                locus_annotation_row = self.locus_annotation.loc[gb_record.id]\n                coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                               locus_annotation_row[\"coordinates\"].split(\",\")]\n                record_locus = Locus(seq_id=gb_record.id, coordinates=coordinates,\n                                     description=locus_annotation_row[\"description\"],\n                                     circular=locus_annotation_row[\"circular\"],\n                                     length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                     order=locus_annotation_row[\"order\"])\n\n                gb_CDSs = [i for i in gb_record.features if i.type == \"CDS\"]\n                first_CDS_record = gb_CDSs[0]\n                id_source = self.prms.args[\"genbank_id_source\"]\n                if self.prms.args[\"genbank_id_source\"] not in first_CDS_record.qualifiers:\n                    for alternative_id_source in self.prms.args[\"genbank_id_alternative_source\"]:\n                        if alternative_id_source in first_CDS_record.qualifiers:\n                            id_source = alternative_id_source\n                            if self.prms.args[\"verbose\"]:\n                                print(f\"\u25cb Warning: there is no &lt;{self.prms.args['genbank_id_source']}&gt; attribute \"\n                                      f\"for CDS records in {gb_file}. Alternative &lt;{id_source}&gt; was used instead.\",\n                                      file=sys.stdout)\n                            break\n                    if id_source == self.prms.args[\"genbank_id_source\"]:\n                        print(f\"There is no &lt;{self.prms.args['genbank_id_source']}&gt; \"\n                              f\"attribute for CDS record found in {gb_file}. We tried to\"\n                              f\" find any from the alternative list: \"\n                              f\"{','.join(self.prms.args['genbank_id_alternative_source'])}\"\n                              f\", but they also weren't found.\")  # add about cmd parameter\n                features_ids = [i.qualifiers[id_source][0] for i in gb_CDSs]\n                if len(features_ids) != len(set(features_ids)):\n                    print(f\"GB file {gb_record} contains duplicated feature ids while\"\n                                                       f\" only unique are allowed.\")\n\n                for gb_feature in gb_CDSs:\n                    feature_id = gb_feature.qualifiers[id_source][0].replace(\"|\", \"_\")\n                    transl_table = self.prms.args[\"default_transl_table\"]\n                    if \"transl_table\" in gb_feature.qualifiers.keys():\n                        transl_table = int(gb_feature.qualifiers[\"transl_table\"][0])\n                    name = \"\"\n                    if self.prms.args[\"genbank_CDS_name_source\"] in gb_feature.qualifiers:\n                        name = gb_feature.qualifiers[self.prms.args[\"genbank_CDS_name_source\"]][0]\n                    category = \"\"\n                    if self.prms.args[\"genbank_CDS_category_source\"] in gb_feature.qualifiers:\n                        category = \",\".join(gb_feature.qualifiers[self.prms.args[\"genbank_CDS_category_source\"]])\n\n                    for coordinate in record_locus.coordinates:\n                        overlapping = False\n                        start, end = coordinate[\"start\"], coordinate[\"end\"]\n                        if start &lt;= gb_feature.location.start + 1 &lt;= end or start &lt;= gb_feature.location.end &lt;= end:\n                            overlapping = True\n                            break\n                    if not overlapping and not self.prms.args[\"cluster_all_proteins\"]:\n                        continue\n                    self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                     f\"{int(gb_feature.location.start) + 1}:\"\n                                                     f\"{int(gb_feature.location.end)}:\"\n                                                     f\"{gb_feature.location.strand}\", \"CDS\", category, name)\n                    feature_annotation_row = self.feature_annotation.loc[feature_id]\n                    feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                      feature_id=feature_id, start=int(gb_feature.location.start) + 1,\n                                      end=int(gb_feature.location.end),\n                                      strand=gb_feature.location.strand,\n                                      name=feature_annotation_row[\"name\"],\n                                      sequence=gb_feature.translate(record_locus_sequence,\n                                                                    table=transl_table,\n                                                                    cds=False)[:-1],\n                                      group=feature_annotation_row[\"group\"],\n                                      group_type=feature_annotation_row[\"group_type\"],\n                                      category=feature_annotation_row[\"category\"],\n                                      vis_prms=dict(fill_colour=feature_annotation_row[\"fill_colour\"],\n                                                    stroke_colour=feature_annotation_row[\"stroke_colour\"],\n                                                    show_label=feature_annotation_row[\"show_label\"]),\n                                      overlapping = overlapping,\n                                      parameters=self.prms)\n\n                    record_locus.features.append(feature)\n                self.loci.append(record_locus)\n            except:\n                print(f\"\u25cb Warning: gb file {gb_file} was not read properly and skipped\")\n                if self.prms.args[\"parsing_debug\"]:\n                    self.prms.args[\"debug\"] = True\n                    raise lovis4u.Manager.lovis4uError()\n        seq_id_to_order = self.locus_annotation[\"order\"].to_dict()\n        loci_ids = [l.seq_id for l in self.loci]\n        if len(loci_ids) != len(set(loci_ids)):\n            raise lovis4u.Manager.lovis4uError(f\"The input gff files have duplicated contig ids.\\n\\t\"\n                                               f\"You can use `--use-filename-as-id` parameter to use file name \"\n                                               f\"as contig id which can help to fix the problem.\")\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {len(self.loci)} {'locus was' if len(self.loci) == 1 else 'loci were'} loaded from genbank \"\n                  f\"files folder\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gb folder.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_locus_annotation_file","title":"<code>load_locus_annotation_file(file_path)</code>","text":"<p>Load loci annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for a loci annotation file to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_locus_annotation_file(self, file_path: str) -&gt; None:\n    \"\"\"Load loci annotation file.\n\n    Arguments:\n        file_path (str): File path for a loci annotation file to be loaded.\n\n    Returns:\n        None\n\n    \"\"\"\n    annotation_columns = [\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\", \"order\", \"group\"]\n    self.locus_annotation = self.__load_annotation_file(file_path, annotation_columns, \"sequence_id\")\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.mmseqs_cluster","title":"<code>mmseqs_cluster()</code>","text":"<p>Cluster all proteins using mmseqs in order to define groups of homologues.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is defined by representative sequence id within a corresponding cluster.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def mmseqs_cluster(self) -&gt; pd.DataFrame:\n    \"\"\"Cluster all proteins using mmseqs in order to define groups of homologues.\n\n    Returns:\n        pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is\n            defined by representative sequence id within a corresponding cluster.\n\n    \"\"\"\n    if self.prms.args[\"verbose\"]:\n        print(f\"\u25cb Running mmseqs for protein clustering...\", file=sys.stdout)\n    try:\n        feature_records = [feature.record for locus in self.loci for feature in locus.features]\n        temp_input = tempfile.NamedTemporaryFile()\n        Bio.SeqIO.write(feature_records, temp_input.name, \"fasta\")\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        mmseqs_output_folder = os.path.join(self.prms.args[\"output_dir\"], \"mmseqs\")\n        if os.path.exists(mmseqs_output_folder):\n            shutil.rmtree(mmseqs_output_folder)\n        os.mkdir(mmseqs_output_folder)\n        Bio.SeqIO.write(feature_records, os.path.join(mmseqs_output_folder, \"input_proteins.fa\"), \"fasta\")\n        mmseqs_output_folder_db = os.path.join(mmseqs_output_folder, \"DB\")\n        os.mkdir(mmseqs_output_folder_db)\n        mmseqs_stdout = open(os.path.join(mmseqs_output_folder, \"mmseqs_stdout.txt\"), \"w\")\n        mmseqs_stderr = open(os.path.join(mmseqs_output_folder, \"mmseqs_stderr.txt\"), \"w\")\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createdb\", temp_input.name,\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\")], stdout=mmseqs_stdout,\n                       stderr=mmseqs_stderr)\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"cluster\",\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"tmp\"),\n                        \"--cluster-mode\", str(self.prms.args[\"mmseqs_cluster_mode\"]),\n                        \"--cov-mode\", str(self.prms.args[\"mmseqs_cov_mode\"]),\n                        \"--min-seq-id\", str(self.prms.args[\"mmseqs_min_seq_id\"]),\n                        \"-c\", str(self.prms.args[\"mmseqs_c\"]),\n                        \"-s\", str(self.prms.args[\"mmseqs_s\"])], stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createtsv\",\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                        os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\")],\n                       stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n        mmseqs_clustering_results = pd.read_table(os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\"),\n                                                  sep=\"\\t\", header=None, names=[\"cluster\", \"protein_id\"])\n        mmseqs_clustering_results = mmseqs_clustering_results.set_index(\"protein_id\")\n\n        num_of_unique_clusters = len(set(mmseqs_clustering_results[\"cluster\"].to_list()))\n        num_of_proteins = len(mmseqs_clustering_results.index)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {num_of_unique_clusters} clusters for {num_of_proteins} proteins were found with mmseqs\\n\"\n                  f\"    mmseqs clustering results were saved to \"\n                  f\"{os.path.join(mmseqs_output_folder, 'mmseqs_clustering.tsv')}\", file=sys.stdout)\n        return mmseqs_clustering_results\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to run mmseqs clustering.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.remove_non_overlapping_features","title":"<code>remove_non_overlapping_features()</code>","text":"<p>Removes features that are not overlapping with visualisation window.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def remove_non_overlapping_features(self) -&gt; None:\n    \"\"\"Removes features that are not overlapping with visualisation window.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        ids_of_non_overlapping_objects = []\n        for locus in self.loci:\n            ids_of_non_overlapping_objects += [obj.feature_id for obj in locus.features if not obj.overlapping]\n            filtered_objects = [obj for obj in locus.features if obj.overlapping]\n            locus.features = filtered_objects\n        self.feature_annotation = self.feature_annotation.drop(ids_of_non_overlapping_objects)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to clean non overlapping features.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.reorient_loci","title":"<code>reorient_loci(ilund4u_mode=False)</code>","text":"<p>Auto re-orient loci (reset strands) of loci if they are not matched.</p> <p>Function tries to maximise co-orientation of homologous features.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def reorient_loci(self, ilund4u_mode: bool = False) -&gt; None:\n    \"\"\"Auto re-orient loci (reset strands) of loci if they are not matched.\n\n    Function tries to maximise co-orientation of homologous features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        count_of_changed_strands = 0\n        loci = [locus for locus in self.loci]\n        for locus_index in range(1, len(loci)):\n            p_locus = loci[locus_index - 1]\n            c_locus = loci[locus_index]\n            p_locus_strands = list(set([c[\"strand\"] for c in p_locus.coordinates]))\n            c_locus_strands = list(set([c[\"strand\"] for c in c_locus.coordinates]))\n            if len(p_locus_strands) == 1 and len(c_locus_strands) == 1:\n                if not ilund4u_mode:\n                    pr_locus_features_groups = set([f.group for f in p_locus.features])\n                    c_locus_features_groups = set([f.group for f in c_locus.features])\n                else:\n                    pr_locus_features_groups = set(\n                        [f.group for f in p_locus.features if f.group_type == \"conserved\"])\n                    c_locus_features_groups = set(\n                        [f.group for f in c_locus.features if f.group_type == \"conserved\"])\n                overlapped_f_groups = pr_locus_features_groups &amp; c_locus_features_groups\n                prl_strand, cl_strand = p_locus_strands[0], c_locus_strands[0]\n                pr_locus_features_strands = {f.group: f.strand * prl_strand for f in p_locus.features if\n                                             f.group in overlapped_f_groups}\n                c_locus_features_strands = {f.group: f.strand * cl_strand for f in c_locus.features if\n                                            f.group in overlapped_f_groups}\n                codirection_score = 0\n\n                for ovg in overlapped_f_groups:\n                    codirection_score += pr_locus_features_strands[ovg] * c_locus_features_strands[ovg]\n                if codirection_score &lt; 0:\n                    count_of_changed_strands += 1\n                    annot_coordinates = []\n                    for cc in loci[locus_index].coordinates:\n                        cc[\"strand\"] *= -1\n                        annot_coordinates.append(f\"{cc['start']}:{cc['end']}:{cc['strand']}\")\n                    loci[locus_index].coordinates = loci[locus_index].coordinates[::-1]\n                    annot_coordinates = annot_coordinates[::-1]\n                    self.locus_annotation.loc[c_locus.seq_id, \"coordinates\"] = \",\".join(annot_coordinates)\n            else:\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb Warning: loci reorientation cannot be applied for loci that have both strands in\"\n                          \" pre-defined coordinates for visualisation\")\n        if self.prms.args[\"verbose\"]:\n            if count_of_changed_strands == 0:\n                print(f\"\u29bf Orientation was not changed for any locus\", file=sys.stdout)\n            elif count_of_changed_strands == 1:\n                print(f\"\u29bf Orientation was changed for 1 locus\", file=sys.stdout)\n            elif count_of_changed_strands &gt; 1:\n                print(f\"\u29bf Orientation was changed for {count_of_changed_strands} loci\", file=sys.stdout)\n\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.save_feature_annotation_table","title":"<code>save_feature_annotation_table()</code>","text":"<p>Save feature annotation table to the output folder.</p> <p>Output file name is feature_annotation_table.tsv</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def save_feature_annotation_table(self) -&gt; None:\n    \"\"\"Save feature annotation table to the output folder.\n\n    Output file name is feature_annotation_table.tsv\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"feature_annotation_table.tsv\")\n        self.feature_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"feature_id\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Feature annotation table was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to save feature annotation table.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.save_locus_annotation_table","title":"<code>save_locus_annotation_table()</code>","text":"<p>Save loci annotation table to the output folder.</p> <p>Output file name is locus_annotation_table.tsv</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def save_locus_annotation_table(self) -&gt; None:\n    \"\"\"Save loci annotation table to the output folder.\n\n    Output file name is locus_annotation_table.tsv\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"locus_annotation_table.tsv\")\n        self.locus_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"sequence_id\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Loci annotation table was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to save loci annotation table.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.set_category_colours","title":"<code>set_category_colours(use_table=True)</code>","text":"<p>Define colours for each category.</p> <p>Parameters:</p> <ul> <li> <code>use_table</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Bool value whether table with predefined colours should be used or not.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def set_category_colours(self, use_table: bool = True) -&gt; None:\n    \"\"\"Define colours for each category.\n\n    Arguments:\n        use_table (bool): Bool value whether table with predefined colours should be used or not.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        colours_dict = dict()\n        if use_table:\n            colours_dict.update(\n                pd.read_table(self.prms.args[\"category_colours\"]).set_index(\"category\")[\"colour\"].to_dict())\n\n        feature_categories = list(set([feature.category for locus in self.loci for feature in locus.features\n                                       if feature.category and feature.category]))\n        if not feature_categories:\n            if self.prms.args[\"verbose\"]:\n                print(\"\u25cb Warning: there are no feature categories to set colours\", file=sys.stdout)\n        colours_dict = {cat: col for cat, col in colours_dict.items() if cat in feature_categories}\n\n        feature_categories = [ff for ff in feature_categories if ff not in colours_dict.keys()]\n        number_of_unique_feature_functions = len(feature_categories)\n        colours_rgb = seaborn.color_palette(self.prms.args[\"category_colour_seaborn_palette\"],\n                                            number_of_unique_feature_functions,\n                                            desat=self.prms.args[\"category_colour_seaborn_desat\"])\n        random.shuffle(colours_rgb)\n        colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n        colours_dict.update({g: c for g, c in zip(list(feature_categories), colours)})\n        for locus in self.loci:\n            locus.category_colours = colours_dict\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to set category colours.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.set_feature_colours_based_on_groups","title":"<code>set_feature_colours_based_on_groups()</code>","text":"<p>Define features fill colour based on corresponding feature group and group types.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def set_feature_colours_based_on_groups(self) -&gt; None:\n    \"\"\"Define features fill colour based on corresponding feature group and group types.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        feature_groups = set([feature.group for locus in self.loci for feature in locus.features if feature.group])\n        if self.prms.args[\"feature_group_types_to_set_colour\"] and \\\n                \"all\" not in self.prms.args[\"feature_group_types_to_set_colour\"]:\n            feature_groups = set([feature.group for locus in self.loci for feature in locus.features\n                                  if feature.group and feature.group_type in\n                                  self.prms.args[\"feature_group_types_to_set_colour\"]])\n        number_of_unique_feature_groups = len(feature_groups)\n        if self.prms.args[\"groups_fill_colour_palette_lib\"] == \"seaborn\":\n            colours_rgb = seaborn.color_palette(self.prms.args[\"groups_fill_colour_seaborn_palette\"],\n                                                number_of_unique_feature_groups,\n                                                desat=self.prms.args[\"groups_fill_colour_seaborn_desat\"])\n            random.shuffle(colours_rgb)\n        elif self.prms.args[\"groups_fill_colour_palette_lib\"] == \"distinctipy\":\n            colours_rgb = distinctipy.get_colors(number_of_unique_feature_groups,\n                                                 exclude_colours=[(1, 1, 1), (0, 0, 0)],\n                                                 pastel_factor=self.prms.args[\"groups_fill_colours_pastel_factor\"])\n        colours = list(map(lambda x: matplotlib.colors.rgb2hex(x), colours_rgb))\n        colours_dict = {g: c for g, c in zip(list(feature_groups), colours)}\n        for locus in self.loci:\n            for feature in locus.features:\n                if feature.group in feature_groups:\n                    if self.prms.args[\"keep_predefined_colours\"] and feature.vis_prms[\"fill_colour\"] != \"default\":\n                        continue\n                    feature.vis_prms[\"fill_colour\"] = colours_dict[feature.group]\n                    self.feature_annotation.loc[feature.feature_id, \"fill_colour\"] = feature.vis_prms[\"fill_colour\"]\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to set feature colours based on groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Locus","title":"<code>Locus</code>","text":"<p>A Locus object represents a particular locus that will be one of the sequence tracks on final figure.</p> <p>Attributes:</p> <ul> <li> <code>seq_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier. Can be used to label locus.</p> </li> <li> <code>coordinates</code>             (<code>list</code>)         \u2013          <p>List of regions to be shown. Each region format: dict with keys: start, end, strand and corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>size</code>             (<code>int</code>)         \u2013          <p>total length of regions to be plotted.</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>Sequence description that can be used to label locus.</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>full length of the locus independent on region that should be plotted.</p> </li> <li> <code>circular</code>             (<code>bool</code>)         \u2013          <p>Bool value whether locus is circular or not. It defines whether you have gap or not passing 1 value on the final figure.</p> </li> <li> <code>features</code>             (<code>list</code>)         \u2013          <p>list of Feature objects that overlapped with coordinates.</p> </li> <li> <code>order</code>             (<code>int</code>)         \u2013          <p>index on ordered list of loci visualisation. Can be pre-defined or found based on loci hierarchical clustering with cluster_sequences category.</p> </li> <li> <code>group</code>             (<code>int | str</code>)         \u2013          <p>locus group that defines set of closely-related loci.</p> </li> <li> <code>category_colours</code>             (<code>dict</code>)         \u2013          <p>colours for locus' features categories.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Locus:\n    \"\"\"A Locus object represents a particular locus that will be one of the sequence tracks on final figure.\n\n    Attributes:\n        seq_id (str): Sequence identifier. Can be used to label locus.\n        coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n            corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n        size (int): total length of regions to be plotted.\n        description (str): Sequence description that can be used to label locus.\n        length (int): full length of the locus independent on region that should be plotted.\n        circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n            1 value on the final figure.\n        features (list): list of Feature objects that overlapped with coordinates.\n        order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n            hierarchical clustering with cluster_sequences category.\n        group (int | str): locus group that defines set of closely-related loci.\n        category_colours (dict): colours for locus' features categories.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, seq_id: str, coordinates: list, description: str, length: int, circular: bool,\n                 features: list, order: int, parameters: lovis4u.Manager.Parameters, group: typing.Union[int, str] = 1):\n        \"\"\"Create a Locus object.\n\n        Arguments:\n            seq_id (str): Sequence identifier. Can be used to label locus.\n            coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n                corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n            description (str): Sequence description that can be used to label locus.\n            length (int): full length of the locus independent on region that should be plotted.\n            circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n                1 value on the final figure.\n            features (list): list of Feature objects that overlapped with coordinates.\n            order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n            hierarchical clustering with cluster_sequences category.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n            group (int | str): locus group that defines set of closely-related loci [1].\n\n        \"\"\"\n        self.seq_id = seq_id\n        self.coordinates = coordinates\n        self.size = 0\n        taken_coordinates = []\n        for coordinate in coordinates:\n            self.size += abs(coordinate[\"end\"] - coordinate[\"start\"] + 1)\n            taken_coordinates += list(range(coordinate[\"start\"], coordinate[\"end\"] + 1))\n        if len(taken_coordinates) != len(set(taken_coordinates)):\n            raise lovis4u.Manager.lovis4uError(f\"Specified coordinates seems to be overlapped\"\n                                               f\" or not in 0-based format.\")\n        for coordinate in coordinates:\n            if coordinate[\"start\"] &lt; 1:\n                raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is in 0-based format\"\n                                                   f\" while input should be in 1-based.\")\n            if coordinate[\"end\"] &gt; length:\n                raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is out of sequence length\"\n                                                   f\" ({length} nt).\")\n\n        self.description = description\n        self.length = length\n        self.circular = circular\n        self.features = features\n        self.order = order\n        self.group = group\n        self.category_colours = dict()\n        self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Locus.__init__","title":"<code>__init__(seq_id, coordinates, description, length, circular, features, order, parameters, group=1)</code>","text":"<p>Create a Locus object.</p> <p>Parameters:</p> <ul> <li> <code>seq_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier. Can be used to label locus.</p> </li> <li> <code>coordinates</code>             (<code>list</code>)         \u2013          <p>List of regions to be shown. Each region format: dict with keys: start, end, strand and corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>Sequence description that can be used to label locus.</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>full length of the locus independent on region that should be plotted.</p> </li> <li> <code>circular</code>             (<code>bool</code>)         \u2013          <p>Bool value whether locus is circular or not. It defines whether you have gap or not passing 1 value on the final figure.</p> </li> <li> <code>features</code>             (<code>list</code>)         \u2013          <p>list of Feature objects that overlapped with coordinates.</p> </li> <li> <code>order</code>             (<code>int</code>)         \u2013          <p>index on ordered list of loci visualisation. Can be pre-defined or found based on loci</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> <li> <code>group</code>             (<code>int | str</code>, default:                 <code>1</code> )         \u2013          <p>locus group that defines set of closely-related loci [1].</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, seq_id: str, coordinates: list, description: str, length: int, circular: bool,\n             features: list, order: int, parameters: lovis4u.Manager.Parameters, group: typing.Union[int, str] = 1):\n    \"\"\"Create a Locus object.\n\n    Arguments:\n        seq_id (str): Sequence identifier. Can be used to label locus.\n        coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n            corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n        description (str): Sequence description that can be used to label locus.\n        length (int): full length of the locus independent on region that should be plotted.\n        circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n            1 value on the final figure.\n        features (list): list of Feature objects that overlapped with coordinates.\n        order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n        hierarchical clustering with cluster_sequences category.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n        group (int | str): locus group that defines set of closely-related loci [1].\n\n    \"\"\"\n    self.seq_id = seq_id\n    self.coordinates = coordinates\n    self.size = 0\n    taken_coordinates = []\n    for coordinate in coordinates:\n        self.size += abs(coordinate[\"end\"] - coordinate[\"start\"] + 1)\n        taken_coordinates += list(range(coordinate[\"start\"], coordinate[\"end\"] + 1))\n    if len(taken_coordinates) != len(set(taken_coordinates)):\n        raise lovis4u.Manager.lovis4uError(f\"Specified coordinates seems to be overlapped\"\n                                           f\" or not in 0-based format.\")\n    for coordinate in coordinates:\n        if coordinate[\"start\"] &lt; 1:\n            raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is in 0-based format\"\n                                               f\" while input should be in 1-based.\")\n        if coordinate[\"end\"] &gt; length:\n            raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is out of sequence length\"\n                                               f\" ({length} nt).\")\n\n    self.description = description\n    self.length = length\n    self.circular = circular\n    self.features = features\n    self.order = order\n    self.group = group\n    self.category_colours = dict()\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_drawing/","title":"Package drawing","text":"<p>This module provides visualisation of loci annotation.</p>"},{"location":"API/package_drawing/#lovis4u.Drawing.ColorLegendVis","title":"<code>ColorLegendVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>ColorLegend track object that handles visualisation of legend to feature's category colours.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class ColorLegendVis(Track):\n    \"\"\"ColorLegend track object that handles visualisation of legend to feature's category colours.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a ColorLegend object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n        self.track_height = None\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a ColorLegend track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_upper = self.layout[\"current_y_coordinate\"]\n            canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n            canvas.setFont(self.prms.args[\"colour_legend_font_face\"],\n                           self.track_data[\"colour_legend_label_size\"])\n            for label_dict in self.track_data[\"labels\"]:\n                yl = y_upper + label_dict[\"relative_y\"]\n                yt = y_upper + label_dict[\"relative_y_text\"]\n                canvas.setFillColorRGB(*matplotlib.colors.hex2color(label_dict[\"colour\"]),\n                                       self.prms.args[\"category_annotation_alpha\"])\n                canvas.rect(label_dict[\"label_x\"], yl, label_dict[\"label_width\"],\n                            self.track_data[\"line_width\"], fill=1, stroke=0)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"colour_legend_label_colour\", self.prms))\n                canvas.drawString(label_dict[\"label_x\"], yt, label_dict[\"label\"])\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a colour legend track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ColorLegendVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a ColorLegend object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a ColorLegend object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n    self.track_height = None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ColorLegendVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a ColorLegend track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a ColorLegend track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_upper = self.layout[\"current_y_coordinate\"]\n        canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n        canvas.setFont(self.prms.args[\"colour_legend_font_face\"],\n                       self.track_data[\"colour_legend_label_size\"])\n        for label_dict in self.track_data[\"labels\"]:\n            yl = y_upper + label_dict[\"relative_y\"]\n            yt = y_upper + label_dict[\"relative_y_text\"]\n            canvas.setFillColorRGB(*matplotlib.colors.hex2color(label_dict[\"colour\"]),\n                                   self.prms.args[\"category_annotation_alpha\"])\n            canvas.rect(label_dict[\"label_x\"], yl, label_dict[\"label_width\"],\n                        self.track_data[\"line_width\"], fill=1, stroke=0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"colour_legend_label_colour\", self.prms))\n            canvas.drawString(label_dict[\"label_x\"], yt, label_dict[\"label\"])\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a colour legend track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.CrossTrack","title":"<code>CrossTrack</code>","text":"<p>Parent class for Cross-Tracks visualisation.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class CrossTrack:\n    \"\"\"Parent class for Cross-Tracks visualisation.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout, tracks, parameters):\n        \"\"\"Parent's constructor for creating a CrossTrack object.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            tracks (dict): List with track objects participated in CrossTrack.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.layout = layout\n        self.tracks = tracks\n        self.prms = parameters\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas):\n        \"\"\"Empy parent's method for cross track drawing.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.CrossTrack.__init__","title":"<code>__init__(layout, tracks, parameters)</code>","text":"<p>Parent's constructor for creating a CrossTrack object.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout, tracks, parameters):\n    \"\"\"Parent's constructor for creating a CrossTrack object.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.layout = layout\n    self.tracks = tracks\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.CrossTrack.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for cross track drawing.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas):\n    \"\"\"Empy parent's method for cross track drawing.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.HomologyTrack","title":"<code>HomologyTrack</code>","text":"<p>             Bases: <code>CrossTrack</code></p> <p>Track that handle visualisation of homology lines between homologous features on neighbours' loci.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class HomologyTrack(CrossTrack):\n    \"\"\"Track that handle visualisation of homology lines between homologous features on neighbours' loci.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout, tracks, parameters):\n        \"\"\"Create a HomologyTrack.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            tracks (dict): List with track objects participated in CrossTrack.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(layout, tracks, parameters)\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw HomologyTrack on canvas.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for track in self.tracks:\n                track.track_data[\"y_top\"] = self.layout[\"figure_height\"] - track.layout[\"inverse_y_coordinate\"]\n                track.track_data[\"feature_upper\"] = track.track_data[\"y_top\"] - \\\n                                                    (track.track_data[\"n_label_rows\"] * track.track_data[\n                                                        \"f_label_height\"] *\n                                                     (1 + track.prms.args[\"feature_label_gap\"]))\n            num_of_loci_tracks = len(self.tracks)\n            for ti in range(num_of_loci_tracks - 1):\n                current_track = self.tracks[ti]\n                current_track_features = current_track.track_data[\"features\"]\n                next_track = self.tracks[ti + 1]\n                next_track_features = next_track.track_data[\"features\"]\n                for ctf in current_track_features:\n                    ctf_group = ctf[\"group\"]\n                    next_track_same_group_features = [i for i in next_track_features if i[\"group\"] == ctf_group]\n                    for ntf in next_track_same_group_features:\n                        cty_u = current_track.track_data[\"feature_upper\"]\n                        cty_c = current_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                        cty_b = current_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                        nty_u = next_track.track_data[\"feature_upper\"]\n                        nty_c = next_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                        nty_b = next_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                        ct_arrow_len = min(\n                            self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                            (ctf[\"coordinates\"][\"end\"] - ctf[\"coordinates\"][\"start\"]))\n                        nt_arrow_len = min(\n                            self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                            (ntf[\"coordinates\"][\"end\"] - ntf[\"coordinates\"][\"start\"]))\n                        canvas.setLineCap(0)\n                        canvas.setLineJoin(1)\n                        canvas.setLineWidth(self.prms.args[\"homology_line_width\"])\n                        canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_stroke_colour\", self.prms))\n                        canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_fill_colour\", self.prms))\n                        p = canvas.beginPath()\n\n                        if ctf[\"coordinates\"][\"orient\"] == 1:\n                            cts, cte = ctf[\"coordinates\"][\"start\"], ctf[\"coordinates\"][\"end\"]\n                            p.moveTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                            if not ctf[\"coordinates\"][\"rout\"]:\n                                p.lineTo(ctf[\"coordinates\"][\"end\"] - ct_arrow_len, cty_b)\n                                p.lineTo(ctf[\"coordinates\"][\"end\"], cty_c)\n                            else:\n                                p.lineTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                        elif ctf[\"coordinates\"][\"orient\"] == -1:\n                            cts, cte = ctf[\"coordinates\"][\"end\"], ctf[\"coordinates\"][\"start\"]\n                            p.moveTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                            if not ctf[\"coordinates\"][\"lout\"]:\n                                p.lineTo(ctf[\"coordinates\"][\"start\"] + ct_arrow_len, cty_b)\n                                p.lineTo(ctf[\"coordinates\"][\"start\"], cty_c)\n                            else:\n                                p.lineTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                        if ntf[\"coordinates\"][\"orient\"] == 1:\n                            nts, nte = ntf[\"coordinates\"][\"end\"], ntf[\"coordinates\"][\"start\"]\n                            if not ntf[\"coordinates\"][\"rout\"]:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                                p.lineTo(ntf[\"coordinates\"][\"end\"] - nt_arrow_len, nty_u)\n                            else:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                            if nte &gt;= cts:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                        elif ntf[\"coordinates\"][\"orient\"] == -1:\n                            nts, nte = ntf[\"coordinates\"][\"start\"], ntf[\"coordinates\"][\"end\"]\n                            if not ntf[\"coordinates\"][\"lout\"]:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                                p.lineTo(ntf[\"coordinates\"][\"start\"] + nt_arrow_len, nty_u)\n                            else:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                            if nte &lt;= cts:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                        if (nte &lt;= cts and ctf[\"coordinates\"][\"orient\"] == 1) or (\n                                nte &gt;= cts and ctf[\"coordinates\"][\"orient\"] == -1):\n                            p.lineTo(cts, cty_c)\n                        p.lineTo(cts, cty_b)\n                        canvas.drawPath(p, stroke=1, fill=1)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw homology line track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.HomologyTrack.__init__","title":"<code>__init__(layout, tracks, parameters)</code>","text":"<p>Create a HomologyTrack.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout, tracks, parameters):\n    \"\"\"Create a HomologyTrack.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(layout, tracks, parameters)\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.HomologyTrack.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw HomologyTrack on canvas.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw HomologyTrack on canvas.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for track in self.tracks:\n            track.track_data[\"y_top\"] = self.layout[\"figure_height\"] - track.layout[\"inverse_y_coordinate\"]\n            track.track_data[\"feature_upper\"] = track.track_data[\"y_top\"] - \\\n                                                (track.track_data[\"n_label_rows\"] * track.track_data[\n                                                    \"f_label_height\"] *\n                                                 (1 + track.prms.args[\"feature_label_gap\"]))\n        num_of_loci_tracks = len(self.tracks)\n        for ti in range(num_of_loci_tracks - 1):\n            current_track = self.tracks[ti]\n            current_track_features = current_track.track_data[\"features\"]\n            next_track = self.tracks[ti + 1]\n            next_track_features = next_track.track_data[\"features\"]\n            for ctf in current_track_features:\n                ctf_group = ctf[\"group\"]\n                next_track_same_group_features = [i for i in next_track_features if i[\"group\"] == ctf_group]\n                for ntf in next_track_same_group_features:\n                    cty_u = current_track.track_data[\"feature_upper\"]\n                    cty_c = current_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                    cty_b = current_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                    nty_u = next_track.track_data[\"feature_upper\"]\n                    nty_c = next_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * mm\n                    nty_b = next_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * mm\n                    ct_arrow_len = min(\n                        self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                        (ctf[\"coordinates\"][\"end\"] - ctf[\"coordinates\"][\"start\"]))\n                    nt_arrow_len = min(\n                        self.prms.args[\"feature_height\"] * mm * self.prms.args[\"feature_arrow_length\"],\n                        (ntf[\"coordinates\"][\"end\"] - ntf[\"coordinates\"][\"start\"]))\n                    canvas.setLineCap(0)\n                    canvas.setLineJoin(1)\n                    canvas.setLineWidth(self.prms.args[\"homology_line_width\"])\n                    canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_stroke_colour\", self.prms))\n                    canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"homology_fill_colour\", self.prms))\n                    p = canvas.beginPath()\n\n                    if ctf[\"coordinates\"][\"orient\"] == 1:\n                        cts, cte = ctf[\"coordinates\"][\"start\"], ctf[\"coordinates\"][\"end\"]\n                        p.moveTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                        if not ctf[\"coordinates\"][\"rout\"]:\n                            p.lineTo(ctf[\"coordinates\"][\"end\"] - ct_arrow_len, cty_b)\n                            p.lineTo(ctf[\"coordinates\"][\"end\"], cty_c)\n                        else:\n                            p.lineTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                    elif ctf[\"coordinates\"][\"orient\"] == -1:\n                        cts, cte = ctf[\"coordinates\"][\"end\"], ctf[\"coordinates\"][\"start\"]\n                        p.moveTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                        if not ctf[\"coordinates\"][\"lout\"]:\n                            p.lineTo(ctf[\"coordinates\"][\"start\"] + ct_arrow_len, cty_b)\n                            p.lineTo(ctf[\"coordinates\"][\"start\"], cty_c)\n                        else:\n                            p.lineTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                    if ntf[\"coordinates\"][\"orient\"] == 1:\n                        nts, nte = ntf[\"coordinates\"][\"end\"], ntf[\"coordinates\"][\"start\"]\n                        if not ntf[\"coordinates\"][\"rout\"]:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                            p.lineTo(ntf[\"coordinates\"][\"end\"] - nt_arrow_len, nty_u)\n                        else:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                        p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                        if nte &gt;= cts:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                    elif ntf[\"coordinates\"][\"orient\"] == -1:\n                        nts, nte = ntf[\"coordinates\"][\"start\"], ntf[\"coordinates\"][\"end\"]\n                        if not ntf[\"coordinates\"][\"lout\"]:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                            p.lineTo(ntf[\"coordinates\"][\"start\"] + nt_arrow_len, nty_u)\n                        else:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                        p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                        if nte &lt;= cts:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                    if (nte &lt;= cts and ctf[\"coordinates\"][\"orient\"] == 1) or (\n                            nte &gt;= cts and ctf[\"coordinates\"][\"orient\"] == -1):\n                        p.lineTo(cts, cty_c)\n                    p.lineTo(cts, cty_b)\n                    canvas.drawPath(p, stroke=1, fill=1)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw homology line track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis","title":"<code>LocusVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>LocusVis track object that handles each locus visualisation.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class LocusVis(Track):\n    \"\"\"LocusVis track object that handles each locus visualisation.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a LocusVis object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a LocusVis track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_track_bottom = self.layout[\"current_y_coordinate\"]  - self.track_data[\"track_height\"]\n            feature_height = self.prms.args[\"feature_height\"] * mm\n            y_feature_upper = self.layout[\"current_y_coordinate\"] - (self.track_data[\"n_label_rows\"] *\n                                                                     self.track_data[\"f_label_height\"] *\n                                                                     (1 + self.prms.args[\"feature_label_gap\"]))\n            y_feature_bottom = y_feature_upper - feature_height\n            y_feature_center = y_feature_upper - feature_height * 0.5\n\n            # Sequence label\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"locus_label_colour\", self.prms))\n            canvas.setFont(self.prms.args[\"locus_label_description_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                    label_bottom = y_feature_upper - self.prms.args[\"locus_label_height\"]\n                    canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                           self.track_data[\"locus_description\"])\n                    label_bottom = y_feature_bottom\n                else:\n                    label_bottom = y_feature_bottom + (feature_height - self.prms.args[\"locus_label_height\"]) * 0.5\n                    label = self.track_data[\"locus_description\"]\n                if self.prms.args[\"locus_label_style\"] != \"description\":\n                    label = self.track_data[\"locus_id\"]\n                    canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n                canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom, label)\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                label_bottom = y_track_bottom\n                current_left = self.layout[\"locus_label_left_border\"]\n                if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                    canvas.drawString(current_left, label_bottom, self.track_data[\"locus_description\"])\n                    current_left += self.track_data[\"locus_description_width\"] + self.track_data[\"two_space_width\"]\n                canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n                canvas.drawString(current_left, label_bottom, self.track_data[\"locus_id\"])\n                current_left += self.track_data[\"locus_id_width\"] + self.track_data[\"two_space_width\"]\n                canvas.drawString(current_left, label_bottom, self.track_data[\"text_coordinates\"])\n\n            # Middle line\n            if self.prms.args[\"draw_middle_line\"]:\n                canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n                canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                canvas.setLineCap(0)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                p = canvas.beginPath()\n                for md_line_coordinates in self.track_data[\"middle_line_coordinates\"]:\n                    p.moveTo(md_line_coordinates[\"start\"], y_feature_center)\n                    p.lineTo(md_line_coordinates[\"end\"], y_feature_center)\n                canvas.drawPath(p, stroke=1, fill=0)\n\n            # Category annotation\n            if self.track_data[\"functions_coordinates\"]:\n                for feature_function, ff_region in self.track_data[\"functions_coordinates\"].items():\n                    feature_colour = self.track_data[\"category_colours\"][feature_function]\n                    canvas.setFillColorRGB(*matplotlib.colors.hex2color(feature_colour),\n                                           self.prms.args[\"category_annotation_alpha\"])\n                    canvas.setLineJoin(1)\n                    y_upper_sausage = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n                    y_bottom_sausage = y_upper_sausage - self.prms.args[\"category_annotation_line_width\"] * mm\n                    for ffr in ff_region:\n                        p = canvas.beginPath()\n                        p.moveTo(ffr[0], y_bottom_sausage)\n                        p.lineTo(ffr[0], y_upper_sausage)\n                        p.lineTo(ffr[1], y_upper_sausage)\n                        p.lineTo(ffr[1], y_bottom_sausage)\n                        p.lineTo(ffr[0], y_bottom_sausage)\n                        p.close()\n                        canvas.drawPath(p, stroke=0, fill=1)\n            # Features\n            canvas.setLineCap(0)\n            canvas.setLineJoin(1)\n            canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n            if self.track_data[\"clean_features_coordinates\"]:\n                for f_data in self.track_data[\"features\"]:\n                    f_data_copy = copy.deepcopy(f_data)\n                    f_data_copy[\"stroke_colour\"] = None\n                    f_data_copy[\"fill_colour\"] = (*matplotlib.colors.hex2color(self.prms.args[\"palette\"][\"white\"]), 1)\n                    self.__plot_cds_feature(canvas, f_data_copy, y_center=y_feature_center, height=feature_height)\n            for f_data in self.track_data[\"features\"]:\n                f_data[\"stroke_colour\"] = *matplotlib.colors.hex2color(f_data[\"stroke_colour\"]), self.prms.args[\n                    \"feature_stroke_colour_alpha\"]\n                f_data[\"fill_colour\"] = *matplotlib.colors.hex2color(f_data[\"fill_colour\"]), self.prms.args[\n                    \"feature_fill_colour_alpha\"]\n                self.__plot_cds_feature(canvas, f_data, y_center=y_feature_center, height=feature_height)\n                if f_data[\"label_width\"]:\n                    canvas.setFillColorRGB(*f_data[\"stroke_colour\"])\n                    canvas.setFont(self.prms.args[\"feature_label_font_face\"],\n                                   self.track_data[\"f_label_font_size\"])\n                    fx_center = f_data[\"coordinates\"][\"center\"]\n                    canvas.drawString(f_data[\"label_position\"][0], f_data[\"label_y_bottom\"] + y_feature_upper,\n                                      f_data[\"label\"])\n                    canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n                    underline_colour = f_data[\"stroke_colour\"]\n                    canvas.setStrokeColorRGB(*underline_colour)\n                    canvas.setLineCap(1)\n                    if f_data[\"label_row\"] &gt; 0:\n                        p = canvas.beginPath()\n                        for ls, le in f_data[\"label_line_coordinates\"]:\n                            p.moveTo(fx_center, ls + y_feature_upper)\n                            p.lineTo(fx_center, le + y_feature_upper)\n                        canvas.drawPath(p, stroke=1, fill=0)\n                        l_start = f_data[\"coordinates\"][\"start\"]\n                        l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                        l_end = f_data[\"coordinates\"][\"end\"]\n                        ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                        canvas.line(l_start, ly, l_end, ly)\n                    else:\n                        overlapping = min(f_data[\"coordinates\"][\"end\"], f_data[\"label_position\"][1]) - (\n                            max(f_data[\"coordinates\"][\"start\"], f_data[\"label_position\"][0]))\n                        if overlapping / (f_data[\"label_position\"][1] - f_data[\"label_position\"][0]) &lt; 1:\n                            l_start = max(f_data[\"coordinates\"][\"start\"], fx_center -\n                                          self.track_data[\"feature_label_gap\"])\n                            l_start = f_data[\"coordinates\"][\"start\"]\n                            l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                            l_end = f_data[\"coordinates\"][\"end\"]\n                            ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                            canvas.line(l_start, ly, l_end, ly)\n            # Axis ticks\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n                canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                canvas.setLineCap(1)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n                canvas.setFont(self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                               self.track_data[\"x_axis_annotation\"][\"label_size\"])\n                axis_line_y_coordinate = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n                axis_tick_height = self.prms.args[\"x_axis_ticks_height\"] * mm\n                axis_tick_label_y_coordinate = axis_line_y_coordinate - self.prms.args[\"x_axis_ticks_height\"] * \\\n                                               1.3 * mm - self.prms.args[\"x_axis_ticks_labels_height\"] * mm\n                for ati in range(len(self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"])):\n                    tick_coordinate = self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"][ati]\n                    tick_label_position = self.track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"][ati]\n                    tick_label = self.track_data[\"x_axis_annotation\"][\"axis_tics_labels\"][ati]\n                    canvas.drawCentredString(tick_label_position, axis_tick_label_y_coordinate, tick_label)\n                    canvas.line(tick_coordinate, axis_line_y_coordinate, tick_coordinate,\n                                axis_line_y_coordinate - axis_tick_height)\n                for region in self.track_data[\"x_axis_annotation\"][\"axis_regions\"]:\n                    canvas.setLineCap(0)\n                    canvas.line(region[\"start\"], axis_line_y_coordinate, region[\"end\"], axis_line_y_coordinate)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a Locus track.\") from error\n\n    def __plot_cds_feature(self, canvas: reportlab.pdfgen.canvas.Canvas, feature_data: dict, y_center: float,\n                           height: float) -&gt; None:\n        \"\"\"Helper method to plot feature polygone\n\n        Returns:\n            None\n\n        \"\"\"\n        x_start = feature_data[\"coordinates\"][\"start\"]\n        x_end = feature_data[\"coordinates\"][\"end\"]\n        orientation = feature_data[\"coordinates\"][\"orient\"]\n        left_out = feature_data[\"coordinates\"][\"lout\"]\n        right_out = feature_data[\"coordinates\"][\"rout\"]\n        fill_colour = feature_data[\"fill_colour\"]\n        stroke_colour = feature_data[\"stroke_colour\"]\n        y_center = y_center\n        height = height\n\n        canvas.setLineCap(0)\n        canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n        arrow_length = min(height * self.prms.args[\"feature_arrow_length\"], (x_end - x_start))\n        p = canvas.beginPath()\n        if orientation == 1:\n            if right_out:\n                p.moveTo(x_end, y_center - height / 2)\n                p.lineTo(x_start, y_center - height / 2)\n                p.lineTo(x_start, y_center + height / 2)\n                p.lineTo(x_end, y_center + height / 2)\n            else:\n                p.moveTo(x_start, y_center + height / 2)\n                p.lineTo(x_end - arrow_length, y_center + height / 2)\n                p.lineTo(x_end, y_center)\n                p.lineTo(x_end - arrow_length, y_center - height / 2)\n                p.lineTo(x_start, y_center - height / 2)\n                if not left_out:\n                    p.lineTo(x_start, y_center + height / 2)\n        elif orientation == -1:\n            if left_out:\n                p.moveTo(x_start, y_center - height / 2)\n                p.lineTo(x_end, y_center - height / 2)\n                p.lineTo(x_end, y_center + height / 2)\n                p.lineTo(x_start, y_center + height / 2)\n            else:\n                p.moveTo(x_end, y_center + height / 2)\n                p.lineTo(x_start + arrow_length, y_center + height / 2)\n                p.lineTo(x_start, y_center)\n                p.lineTo(x_start + arrow_length, y_center - height / 2)\n                p.lineTo(x_end, y_center - height / 2)\n                if not right_out:\n                    p.lineTo(x_end, y_center + height / 2)\n        if left_out and right_out:\n            p.moveTo(x_start, y_center + height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n            p.moveTo(x_start, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n        if not left_out and not right_out:\n            p.close()\n        stroke, fill = 0, 0\n        if stroke_colour:\n            canvas.setStrokeColorRGB(*stroke_colour)\n            stroke = 1\n        if fill_colour:\n            canvas.setFillColorRGB(*fill_colour)\n            fill = 1\n        canvas.drawPath(p, stroke=stroke, fill=fill)\n        return None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a LocusVis object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a LocusVis object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis.__plot_cds_feature","title":"<code>__plot_cds_feature(canvas, feature_data, y_center, height)</code>","text":"<p>Helper method to plot feature polygone</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __plot_cds_feature(self, canvas: reportlab.pdfgen.canvas.Canvas, feature_data: dict, y_center: float,\n                       height: float) -&gt; None:\n    \"\"\"Helper method to plot feature polygone\n\n    Returns:\n        None\n\n    \"\"\"\n    x_start = feature_data[\"coordinates\"][\"start\"]\n    x_end = feature_data[\"coordinates\"][\"end\"]\n    orientation = feature_data[\"coordinates\"][\"orient\"]\n    left_out = feature_data[\"coordinates\"][\"lout\"]\n    right_out = feature_data[\"coordinates\"][\"rout\"]\n    fill_colour = feature_data[\"fill_colour\"]\n    stroke_colour = feature_data[\"stroke_colour\"]\n    y_center = y_center\n    height = height\n\n    canvas.setLineCap(0)\n    canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n    arrow_length = min(height * self.prms.args[\"feature_arrow_length\"], (x_end - x_start))\n    p = canvas.beginPath()\n    if orientation == 1:\n        if right_out:\n            p.moveTo(x_end, y_center - height / 2)\n            p.lineTo(x_start, y_center - height / 2)\n            p.lineTo(x_start, y_center + height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n        else:\n            p.moveTo(x_start, y_center + height / 2)\n            p.lineTo(x_end - arrow_length, y_center + height / 2)\n            p.lineTo(x_end, y_center)\n            p.lineTo(x_end - arrow_length, y_center - height / 2)\n            p.lineTo(x_start, y_center - height / 2)\n            if not left_out:\n                p.lineTo(x_start, y_center + height / 2)\n    elif orientation == -1:\n        if left_out:\n            p.moveTo(x_start, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n            p.lineTo(x_start, y_center + height / 2)\n        else:\n            p.moveTo(x_end, y_center + height / 2)\n            p.lineTo(x_start + arrow_length, y_center + height / 2)\n            p.lineTo(x_start, y_center)\n            p.lineTo(x_start + arrow_length, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n            if not right_out:\n                p.lineTo(x_end, y_center + height / 2)\n    if left_out and right_out:\n        p.moveTo(x_start, y_center + height / 2)\n        p.lineTo(x_end, y_center + height / 2)\n        p.moveTo(x_start, y_center - height / 2)\n        p.lineTo(x_end, y_center - height / 2)\n    if not left_out and not right_out:\n        p.close()\n    stroke, fill = 0, 0\n    if stroke_colour:\n        canvas.setStrokeColorRGB(*stroke_colour)\n        stroke = 1\n    if fill_colour:\n        canvas.setFillColorRGB(*fill_colour)\n        fill = 1\n    canvas.drawPath(p, stroke=stroke, fill=fill)\n    return None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a LocusVis track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a LocusVis track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_track_bottom = self.layout[\"current_y_coordinate\"]  - self.track_data[\"track_height\"]\n        feature_height = self.prms.args[\"feature_height\"] * mm\n        y_feature_upper = self.layout[\"current_y_coordinate\"] - (self.track_data[\"n_label_rows\"] *\n                                                                 self.track_data[\"f_label_height\"] *\n                                                                 (1 + self.prms.args[\"feature_label_gap\"]))\n        y_feature_bottom = y_feature_upper - feature_height\n        y_feature_center = y_feature_upper - feature_height * 0.5\n\n        # Sequence label\n        canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"locus_label_colour\", self.prms))\n        canvas.setFont(self.prms.args[\"locus_label_description_font_face\"], self.prms.args[\"locus_label_font_size\"])\n        if self.prms.args[\"locus_label_position\"] == \"left\":\n            if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                label_bottom = y_feature_upper - self.prms.args[\"locus_label_height\"]\n                canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                       self.track_data[\"locus_description\"])\n                label_bottom = y_feature_bottom\n            else:\n                label_bottom = y_feature_bottom + (feature_height - self.prms.args[\"locus_label_height\"]) * 0.5\n                label = self.track_data[\"locus_description\"]\n            if self.prms.args[\"locus_label_style\"] != \"description\":\n                label = self.track_data[\"locus_id\"]\n                canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom, label)\n        elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n            label_bottom = y_track_bottom\n            current_left = self.layout[\"locus_label_left_border\"]\n            if self.prms.args[\"locus_label_style\"] == \"full\" and self.track_data[\"locus_description\"]:\n                canvas.drawString(current_left, label_bottom, self.track_data[\"locus_description\"])\n                current_left += self.track_data[\"locus_description_width\"] + self.track_data[\"two_space_width\"]\n            canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            canvas.drawString(current_left, label_bottom, self.track_data[\"locus_id\"])\n            current_left += self.track_data[\"locus_id_width\"] + self.track_data[\"two_space_width\"]\n            canvas.drawString(current_left, label_bottom, self.track_data[\"text_coordinates\"])\n\n        # Middle line\n        if self.prms.args[\"draw_middle_line\"]:\n            canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            canvas.setLineCap(0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            p = canvas.beginPath()\n            for md_line_coordinates in self.track_data[\"middle_line_coordinates\"]:\n                p.moveTo(md_line_coordinates[\"start\"], y_feature_center)\n                p.lineTo(md_line_coordinates[\"end\"], y_feature_center)\n            canvas.drawPath(p, stroke=1, fill=0)\n\n        # Category annotation\n        if self.track_data[\"functions_coordinates\"]:\n            for feature_function, ff_region in self.track_data[\"functions_coordinates\"].items():\n                feature_colour = self.track_data[\"category_colours\"][feature_function]\n                canvas.setFillColorRGB(*matplotlib.colors.hex2color(feature_colour),\n                                       self.prms.args[\"category_annotation_alpha\"])\n                canvas.setLineJoin(1)\n                y_upper_sausage = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n                y_bottom_sausage = y_upper_sausage - self.prms.args[\"category_annotation_line_width\"] * mm\n                for ffr in ff_region:\n                    p = canvas.beginPath()\n                    p.moveTo(ffr[0], y_bottom_sausage)\n                    p.lineTo(ffr[0], y_upper_sausage)\n                    p.lineTo(ffr[1], y_upper_sausage)\n                    p.lineTo(ffr[1], y_bottom_sausage)\n                    p.lineTo(ffr[0], y_bottom_sausage)\n                    p.close()\n                    canvas.drawPath(p, stroke=0, fill=1)\n        # Features\n        canvas.setLineCap(0)\n        canvas.setLineJoin(1)\n        canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n        if self.track_data[\"clean_features_coordinates\"]:\n            for f_data in self.track_data[\"features\"]:\n                f_data_copy = copy.deepcopy(f_data)\n                f_data_copy[\"stroke_colour\"] = None\n                f_data_copy[\"fill_colour\"] = (*matplotlib.colors.hex2color(self.prms.args[\"palette\"][\"white\"]), 1)\n                self.__plot_cds_feature(canvas, f_data_copy, y_center=y_feature_center, height=feature_height)\n        for f_data in self.track_data[\"features\"]:\n            f_data[\"stroke_colour\"] = *matplotlib.colors.hex2color(f_data[\"stroke_colour\"]), self.prms.args[\n                \"feature_stroke_colour_alpha\"]\n            f_data[\"fill_colour\"] = *matplotlib.colors.hex2color(f_data[\"fill_colour\"]), self.prms.args[\n                \"feature_fill_colour_alpha\"]\n            self.__plot_cds_feature(canvas, f_data, y_center=y_feature_center, height=feature_height)\n            if f_data[\"label_width\"]:\n                canvas.setFillColorRGB(*f_data[\"stroke_colour\"])\n                canvas.setFont(self.prms.args[\"feature_label_font_face\"],\n                               self.track_data[\"f_label_font_size\"])\n                fx_center = f_data[\"coordinates\"][\"center\"]\n                canvas.drawString(f_data[\"label_position\"][0], f_data[\"label_y_bottom\"] + y_feature_upper,\n                                  f_data[\"label\"])\n                canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n                underline_colour = f_data[\"stroke_colour\"]\n                canvas.setStrokeColorRGB(*underline_colour)\n                canvas.setLineCap(1)\n                if f_data[\"label_row\"] &gt; 0:\n                    p = canvas.beginPath()\n                    for ls, le in f_data[\"label_line_coordinates\"]:\n                        p.moveTo(fx_center, ls + y_feature_upper)\n                        p.lineTo(fx_center, le + y_feature_upper)\n                    canvas.drawPath(p, stroke=1, fill=0)\n                    l_start = f_data[\"coordinates\"][\"start\"]\n                    l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                    l_end = f_data[\"coordinates\"][\"end\"]\n                    ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                    canvas.line(l_start, ly, l_end, ly)\n                else:\n                    overlapping = min(f_data[\"coordinates\"][\"end\"], f_data[\"label_position\"][1]) - (\n                        max(f_data[\"coordinates\"][\"start\"], f_data[\"label_position\"][0]))\n                    if overlapping / (f_data[\"label_position\"][1] - f_data[\"label_position\"][0]) &lt; 1:\n                        l_start = max(f_data[\"coordinates\"][\"start\"], fx_center -\n                                      self.track_data[\"feature_label_gap\"])\n                        l_start = f_data[\"coordinates\"][\"start\"]\n                        l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                        l_end = f_data[\"coordinates\"][\"end\"]\n                        ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                        canvas.line(l_start, ly, l_end, ly)\n        # Axis ticks\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            canvas.setLineCap(1)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"x_axis_line_colour\", self.prms))\n            canvas.setFont(self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                           self.track_data[\"x_axis_annotation\"][\"label_size\"])\n            axis_line_y_coordinate = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * mm\n            axis_tick_height = self.prms.args[\"x_axis_ticks_height\"] * mm\n            axis_tick_label_y_coordinate = axis_line_y_coordinate - self.prms.args[\"x_axis_ticks_height\"] * \\\n                                           1.3 * mm - self.prms.args[\"x_axis_ticks_labels_height\"] * mm\n            for ati in range(len(self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"])):\n                tick_coordinate = self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"][ati]\n                tick_label_position = self.track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"][ati]\n                tick_label = self.track_data[\"x_axis_annotation\"][\"axis_tics_labels\"][ati]\n                canvas.drawCentredString(tick_label_position, axis_tick_label_y_coordinate, tick_label)\n                canvas.line(tick_coordinate, axis_line_y_coordinate, tick_coordinate,\n                            axis_line_y_coordinate - axis_tick_height)\n            for region in self.track_data[\"x_axis_annotation\"][\"axis_regions\"]:\n                canvas.setLineCap(0)\n                canvas.line(region[\"start\"], axis_line_y_coordinate, region[\"end\"], axis_line_y_coordinate)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a Locus track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ScaleVis","title":"<code>ScaleVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>ScaleVis track object that handles visualisation of scale bottom line.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class ScaleVis(Track):\n    \"\"\"ScaleVis track object that handles visualisation of scale bottom line.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a LocusVis object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n        self.track_height = None\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a ScaleVis track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_upper = self.layout[\"current_y_coordinate\"]\n            y_bottom = self.layout[\"current_y_coordinate\"] - self.track_data[\"track_height\"]\n            y_center = self.layout[\"current_y_coordinate\"] - 0.5 * self.track_data[\"track_height\"]\n\n            middle_line_x_position = np.mean(self.track_data[\"coordinates\"])\n\n            canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n            canvas.setLineCap(0)\n            canvas.setLineJoin(1)\n            if self.track_data[\"style\"] == \"fancy\":\n                tick_height = self.track_data[\"scale_line_label_height\"]\n\n                p = canvas.beginPath()\n                p.moveTo(self.track_data[\"coordinates\"][0], y_center - 0.5 * tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][0], y_center + 0.5 * tick_height)\n                p.moveTo(self.track_data[\"coordinates\"][0], y_center)\n                p.lineTo(middle_line_x_position - 0.5 * self.track_data[\"scale_line_label_width\"] -\n                         self.track_data[\"space_width\"], y_center)\n                p.moveTo(self.track_data[\"coordinates\"][1], y_center - 0.5 * tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_center + 0.5 * tick_height)\n                p.moveTo(self.track_data[\"coordinates\"][1], y_center)\n                p.lineTo(middle_line_x_position + 0.5 * self.track_data[\"scale_line_label_width\"] +\n                         self.track_data[\"space_width\"], y_center)\n            else:\n                tick_height = self.prms.args[\"scale_line_tics_height\"] * mm\n\n                p = canvas.beginPath()\n                p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][0], y_upper)\n                p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height * 0.5)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height * 0.5)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height)\n            canvas.drawPath(p, stroke=1, fill=0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n            canvas.setFont(self.prms.args[\"scale_line_label_font_face\"],\n                           self.track_data[\"scale_line_label_font_size\"])\n            canvas.drawCentredString(middle_line_x_position, y_bottom, self.track_data[\"scale_label\"])\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a scale track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ScaleVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a LocusVis object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a LocusVis object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n    self.track_height = None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ScaleVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a ScaleVis track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a ScaleVis track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_upper = self.layout[\"current_y_coordinate\"]\n        y_bottom = self.layout[\"current_y_coordinate\"] - self.track_data[\"track_height\"]\n        y_center = self.layout[\"current_y_coordinate\"] - 0.5 * self.track_data[\"track_height\"]\n\n        middle_line_x_position = np.mean(self.track_data[\"coordinates\"])\n\n        canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n        canvas.setStrokeColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n        canvas.setLineCap(0)\n        canvas.setLineJoin(1)\n        if self.track_data[\"style\"] == \"fancy\":\n            tick_height = self.track_data[\"scale_line_label_height\"]\n\n            p = canvas.beginPath()\n            p.moveTo(self.track_data[\"coordinates\"][0], y_center - 0.5 * tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][0], y_center + 0.5 * tick_height)\n            p.moveTo(self.track_data[\"coordinates\"][0], y_center)\n            p.lineTo(middle_line_x_position - 0.5 * self.track_data[\"scale_line_label_width\"] -\n                     self.track_data[\"space_width\"], y_center)\n            p.moveTo(self.track_data[\"coordinates\"][1], y_center - 0.5 * tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_center + 0.5 * tick_height)\n            p.moveTo(self.track_data[\"coordinates\"][1], y_center)\n            p.lineTo(middle_line_x_position + 0.5 * self.track_data[\"scale_line_label_width\"] +\n                     self.track_data[\"space_width\"], y_center)\n        else:\n            tick_height = self.prms.args[\"scale_line_tics_height\"] * mm\n\n            p = canvas.beginPath()\n            p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][0], y_upper)\n            p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height * 0.5)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height * 0.5)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height)\n        canvas.drawPath(p, stroke=1, fill=0)\n        canvas.setFillColorRGB(*lovis4u.Methods.get_colour_rgba(\"scale_line_colour\", self.prms))\n        canvas.setFont(self.prms.args[\"scale_line_label_font_face\"],\n                       self.track_data[\"scale_line_label_font_size\"])\n        canvas.drawCentredString(middle_line_x_position, y_bottom, self.track_data[\"scale_label\"])\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a scale track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.Track","title":"<code>Track</code>","text":"<p>Parent class for visualisation Tracks.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class Track:\n    \"\"\"Parent class for visualisation Tracks.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters: lovis4u.Manager.Parameters):\n        \"\"\"Parent's constructor for creating a Track object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.layout = layout\n        self.track_data = track_data\n        self.prms = parameters\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Empy parent's method for track drawing.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.Track.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Parent's constructor for creating a Track object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters: lovis4u.Manager.Parameters):\n    \"\"\"Parent's constructor for creating a Track object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.layout = layout\n    self.track_data = track_data\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.Track.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for track drawing.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Empy parent's method for track drawing.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/","title":"Package manager","text":"<p>This module provides managing classes and methods for the tool.</p>"},{"location":"API/package_manager/#lovis4u.Manager.Canvas","title":"<code>Canvas</code>","text":"<p>An Image object holds canvas;.</p> <p>Attributes:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>canvas object of the reportlab library.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Canvas:\n    \"\"\"An Image object holds canvas;.\n\n    Attributes:\n        canvas (reportlab.pdfgen.canvas.Canvas): canvas object of the reportlab library.\n\n    \"\"\"\n\n    def __init__(self, filename: str, width: float, height: float, parameters):\n        \"\"\"Create a Canvas object.\n\n        Arguments:\n            filename (str): path and name of the output pdf.\n            width (float): width of the canvas.\n            height (float): height of the pdf.\n\n        \"\"\"\n        self.prms = parameters\n        self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n        self.canvas.setTitle(\"lovis4u output\")\n        self.canvas.setSubject(\"\ud83c\udfa8\")\n        self.canvas.setCreator(\"lovis4u | The Atkinson Lab 4U\")\n\n    def save(self) -&gt; None:\n        \"\"\"Save canvas as a pdf file.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        self.canvas.save()\n        return None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Canvas.__init__","title":"<code>__init__(filename, width, height, parameters)</code>","text":"<p>Create a Canvas object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>path and name of the output pdf.</p> </li> <li> <code>width</code>             (<code>float</code>)         \u2013          <p>width of the canvas.</p> </li> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>height of the pdf.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, filename: str, width: float, height: float, parameters):\n    \"\"\"Create a Canvas object.\n\n    Arguments:\n        filename (str): path and name of the output pdf.\n        width (float): width of the canvas.\n        height (float): height of the pdf.\n\n    \"\"\"\n    self.prms = parameters\n    self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n    self.canvas.setTitle(\"lovis4u output\")\n    self.canvas.setSubject(\"\ud83c\udfa8\")\n    self.canvas.setCreator(\"lovis4u | The Atkinson Lab 4U\")\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Canvas.save","title":"<code>save()</code>","text":"<p>Save canvas as a pdf file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save canvas as a pdf file.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not os.path.exists(self.prms.args[\"output_dir\"]):\n        os.mkdir(self.prms.args[\"output_dir\"])\n    self.canvas.save()\n    return None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager","title":"<code>CanvasManager</code>","text":"<p>Canvas manager object responsible for preprocessing data for visualisation and interaction between visualisation     and raw data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Defines size and coordinate system of a canvas.</p> </li> <li> <code>tracks</code>             (<code>list</code>)         \u2013          <p>List containing Track objects each of them represents visualisation unit (e.g. particular locus).</p> </li> <li> <code>cross_tracks</code>             (<code>list</code>)         \u2013          <p>List containing CrossTrack objects each of them represents visualisation unit that interacts with multiple regular Track objects.</p> </li> </ul> <pre><code>prms (Parameters): Parameters' class object that holds config and cmd arguments.\n</code></pre> Source code in <code>lovis4u/Manager.py</code> <pre><code>class CanvasManager:\n    \"\"\"Canvas manager object responsible for preprocessing data for visualisation and interaction between visualisation\n        and raw data.\n\n    Attributes:\n         layout (dict): Defines size and coordinate system of a canvas.\n         tracks (list): List containing Track objects each of them represents visualisation unit (e.g. particular locus).\n         cross_tracks (list): List containing CrossTrack objects each of them represents visualisation unit that\n            interacts with multiple regular Track objects.\n        prms (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a CanvasManager object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.layout = dict()\n        self.tracks = []\n        self.cross_tracks = []\n        self.prms = parameters\n\n    def define_layout(self, loci) -&gt; None:\n        \"\"\"Define canvas' layout based on input loci.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            annotated_descriptions = [i.description for i in loci.loci if i.description]\n            if not annotated_descriptions and self.prms.args[\"locus_label_style\"] != \"id\":\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb  Warning message: the annotation lacks description. Locus label style is \"\n                          \"changed to 'id'\")\n                self.prms.args[\"locus_label_style\"] = \"id\"\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                if self.prms.args[\"locus_label_style\"] == \"full\":\n                    label_height = self.prms.args[\"feature_height\"] * mm * 0.4\n                else:\n                    label_height = min(1, self.prms.args[\"locus_label_size\"]) * self.prms.args[\"feature_height\"] * mm\n                label_font_size = lovis4u.Methods.str_height_to_size(label_height,\n                                                                     self.prms.args[\"locus_label_id_font_face\"])\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                label_font_size = self.prms.args[\"bottom_locus_label_font_size\"]\n                label_height = lovis4u.Methods.str_font_size_to_height(label_font_size,\n                                                                       self.prms.args[\"locus_label_id_font_face\"])\n            else:\n                raise lovis4u.Manager.lovis4uError(\"Locus label position parameter should be either 'bottom' \"\n                                                   \"or 'left'.\")\n            self.prms.args[\"locus_label_height\"] = label_height\n            self.prms.args[\"locus_label_font_size\"] = label_font_size\n            max_id_string_width = max([pdfmetrics.stringWidth(i.seq_id, self.prms.args[\"locus_label_id_font_face\"],\n                                                              self.prms.args[\"locus_label_font_size\"]) for i in\n                                       loci.loci])\n            if self.prms.args[\"locus_label_style\"] != \"id\":\n                max_descr_string_width = \\\n                    max([pdfmetrics.stringWidth(i, self.prms.args[\"locus_label_description_font_face\"],\n                                                self.prms.args[\"locus_label_font_size\"])\n                         for i in annotated_descriptions])\n\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                max_label_string_width = max(max_id_string_width, max_descr_string_width)\n            elif self.prms.args[\"locus_label_style\"] == \"id\":\n                max_label_string_width = max_id_string_width\n            elif self.prms.args[\"locus_label_style\"] == \"description\":\n                max_label_string_width = max_descr_string_width\n            loci_lengths = loci.get_loci_lengths_and_n_of_regions()\n            self.layout[\"total_nt_width\"] = max(i[0] for i in loci_lengths)\n            if self.prms.args[\"figure_width\"]:\n                if self.prms.args[\"locus_label_position\"] == \"left\":\n                    figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - max_label_string_width - \\\n                                            2 * self.prms.args[\"margin\"] * mm \\\n                                            - self.prms.args[\"gap_after_locus_label\"] * mm\n                elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                    figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - 2 * self.prms.args[\"margin\"] * mm\n                self.prms.args[\"mm_per_nt\"] = mm * figure_width_for_loci / self.layout[\"total_nt_width\"]\n            else:\n                width_per_nt = self.prms.args[\"mm_per_nt\"] * mm\n                figure_width_for_loci = width_per_nt * self.layout[\"total_nt_width\"]\n                if figure_width_for_loci &lt; 8 * cm:\n                    width_per_nt = 8 * cm / self.layout[\"total_nt_width\"]\n                self.prms.args[\"mm_per_nt\"] = width_per_nt / mm\n            self.layout[\"width_per_nt\"] = self.prms.args[\"mm_per_nt\"] / mm\n            self.layout[\"x_gap_between_regions\"] = self.prms.args[\"gap_between_regions\"] * mm\n            each_loci_region_width = [\n                (i[0] * self.layout[\"width_per_nt\"]) + (i[1] * self.layout[\"x_gap_between_regions\"])\n                for i in loci_lengths]\n            max_loci_region_length = max(each_loci_region_width)\n            self.layout[\"locus_label_left_border\"] = self.prms.args[\"margin\"] * mm\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                self.layout[\"locus_label_right_border\"] = self.layout[\n                                                              \"locus_label_left_border\"] + max_label_string_width\n                self.layout[\"loci_tracks_left_border\"] = self.layout[\"locus_label_right_border\"] + \\\n                                                         self.prms.args[\"gap_after_locus_label\"] * mm\n                self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                          max_loci_region_length\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                self.layout[\"loci_tracks_left_border\"] = self.prms.args[\"margin\"] * mm\n                self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                          max_loci_region_length\n            self.layout[\"figure_width\"] = self.layout[\"loci_tracks_right_border\"] + self.prms.args[\"margin\"] * mm\n            self.layout[\"figure_height\"] = self.prms.args[\"margin\"] * mm\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define layout from loci data.\") from error\n\n    def add_loci_tracks(self, loci) -&gt; None:\n        \"\"\"Add loci tracks to your canvas.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for locus in loci.loci:\n                locus_loader = LocusLoader(self.prms)\n                locus_loader.prepare_track_specific_data(locus, self.layout.copy())\n                locus_track_height = locus_loader.calculate_track_height()\n                self.layout[\"figure_height\"] += locus_track_height + self.prms.args[\"gap\"] * mm\n                locus_track = locus_loader.create_track()\n                self.tracks.append(locus_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf {len(loci.loci)} loci tracks were added to the canvas\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add loci tracks to the canvas.\") from error\n\n    def add_categories_colour_legend_track(self, loci) -&gt; None:\n        \"\"\"Add categories colour legend tracks to your canvas.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            colour_legend_loader = CategoriesColorLegendLoader(self.prms)\n            colour_legend_loader.prepare_track_specific_data(self.layout.copy(), loci)\n            colour_legend_track_height = colour_legend_loader.calculate_track_height()\n            if colour_legend_track_height != 0:\n                self.layout[\"figure_height\"] += colour_legend_track_height + self.prms.args[\"gap\"] * mm\n            colour_legend_track = colour_legend_loader.create_track()\n            if isinstance(colour_legend_track, lovis4u.Drawing.ColorLegendVis):\n                self.tracks.append(colour_legend_track)\n                if self.prms.args[\"verbose\"]:\n                    print(f\"\u29bf Categories colour legend track was added to the canvas\", file=sys.stdout)\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add categories colour legend track to the canvas.\") from error\n\n    def add_scale_line_track(self) -&gt; None:\n        \"\"\"Add scale line tracks to your canvas.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            scale_loader = ScaleLoader(self.prms)\n            scale_loader.prepare_track_specific_data(self.layout.copy())\n            scale_track_height = scale_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += scale_track_height + self.prms.args[\"gap\"] * mm\n            scale_track = scale_loader.create_track()\n            self.tracks.append(scale_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Scale line track was added to the canvas\", file=sys.stdout)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n\n    def add_homology_track(self) -&gt; None:\n        \"\"\"Add homology track to your canvas.\n\n        You should add this track after you added loci tracks.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_tracks = [i for i in self.tracks.copy() if isinstance(i, lovis4u.Drawing.LocusVis)]\n            if not loci_tracks:\n                raise lovis4u.Manager.lovis4uError(\"Unable to create homology track if no loci track was added.\")\n            for lt in loci_tracks:\n                lt.track_data[\"clean_features_coordinates\"] = True\n            self.cross_tracks.append(lovis4u.Drawing.HomologyTrack(self.layout, loci_tracks, self.prms))\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Homology track was added to the canvas\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n\n    def plot(self, filename: str) -&gt; None:\n        \"\"\"Plot all added tracks and save the plot as pdf.\n\n        Arguments:\n            filename (str): filename for the output pdf.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            file_path = os.path.join(self.prms.args[\"output_dir\"], filename)\n            self.layout[\"figure_height\"] += (self.prms.args[\"margin\"] - self.prms.args[\"gap\"]) * mm\n            plot = Canvas(file_path, self.layout[\"figure_width\"], self.layout[\"figure_height\"], self.prms)\n\n            for cross_track in self.cross_tracks:\n                cross_track.draw(plot.canvas)\n\n            current_y_coordinate = self.layout[\"figure_height\"] - self.prms.args[\"margin\"] * mm\n            for track in self.tracks:\n                track.layout[\"current_y_coordinate\"] = current_y_coordinate\n                track.layout[\"figure_height\"] = self.layout[\"figure_height\"]\n                track.draw(plot.canvas)\n                current_y_coordinate -= track.track_data[\"track_height\"] + self.prms.args[\"gap\"] * mm\n            plot.save()\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf lovis4u plot was saved as: {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to plot the canvas and save the figure.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a CanvasManager object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a CanvasManager object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.layout = dict()\n    self.tracks = []\n    self.cross_tracks = []\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_categories_colour_legend_track","title":"<code>add_categories_colour_legend_track(loci)</code>","text":"<p>Add categories colour legend tracks to your canvas.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_categories_colour_legend_track(self, loci) -&gt; None:\n    \"\"\"Add categories colour legend tracks to your canvas.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        colour_legend_loader = CategoriesColorLegendLoader(self.prms)\n        colour_legend_loader.prepare_track_specific_data(self.layout.copy(), loci)\n        colour_legend_track_height = colour_legend_loader.calculate_track_height()\n        if colour_legend_track_height != 0:\n            self.layout[\"figure_height\"] += colour_legend_track_height + self.prms.args[\"gap\"] * mm\n        colour_legend_track = colour_legend_loader.create_track()\n        if isinstance(colour_legend_track, lovis4u.Drawing.ColorLegendVis):\n            self.tracks.append(colour_legend_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u29bf Categories colour legend track was added to the canvas\", file=sys.stdout)\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add categories colour legend track to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_homology_track","title":"<code>add_homology_track()</code>","text":"<p>Add homology track to your canvas.</p> <p>You should add this track after you added loci tracks.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_homology_track(self) -&gt; None:\n    \"\"\"Add homology track to your canvas.\n\n    You should add this track after you added loci tracks.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_tracks = [i for i in self.tracks.copy() if isinstance(i, lovis4u.Drawing.LocusVis)]\n        if not loci_tracks:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create homology track if no loci track was added.\")\n        for lt in loci_tracks:\n            lt.track_data[\"clean_features_coordinates\"] = True\n        self.cross_tracks.append(lovis4u.Drawing.HomologyTrack(self.layout, loci_tracks, self.prms))\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Homology track was added to the canvas\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_loci_tracks","title":"<code>add_loci_tracks(loci)</code>","text":"<p>Add loci tracks to your canvas.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_loci_tracks(self, loci) -&gt; None:\n    \"\"\"Add loci tracks to your canvas.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for locus in loci.loci:\n            locus_loader = LocusLoader(self.prms)\n            locus_loader.prepare_track_specific_data(locus, self.layout.copy())\n            locus_track_height = locus_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += locus_track_height + self.prms.args[\"gap\"] * mm\n            locus_track = locus_loader.create_track()\n            self.tracks.append(locus_track)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf {len(loci.loci)} loci tracks were added to the canvas\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add loci tracks to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_scale_line_track","title":"<code>add_scale_line_track()</code>","text":"<p>Add scale line tracks to your canvas.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_scale_line_track(self) -&gt; None:\n    \"\"\"Add scale line tracks to your canvas.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        scale_loader = ScaleLoader(self.prms)\n        scale_loader.prepare_track_specific_data(self.layout.copy())\n        scale_track_height = scale_loader.calculate_track_height()\n        self.layout[\"figure_height\"] += scale_track_height + self.prms.args[\"gap\"] * mm\n        scale_track = scale_loader.create_track()\n        self.tracks.append(scale_track)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf Scale line track was added to the canvas\", file=sys.stdout)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.define_layout","title":"<code>define_layout(loci)</code>","text":"<p>Define canvas' layout based on input loci.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def define_layout(self, loci) -&gt; None:\n    \"\"\"Define canvas' layout based on input loci.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        annotated_descriptions = [i.description for i in loci.loci if i.description]\n        if not annotated_descriptions and self.prms.args[\"locus_label_style\"] != \"id\":\n            if self.prms.args[\"verbose\"]:\n                print(\"\u25cb  Warning message: the annotation lacks description. Locus label style is \"\n                      \"changed to 'id'\")\n            self.prms.args[\"locus_label_style\"] = \"id\"\n        if self.prms.args[\"locus_label_position\"] == \"left\":\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                label_height = self.prms.args[\"feature_height\"] * mm * 0.4\n            else:\n                label_height = min(1, self.prms.args[\"locus_label_size\"]) * self.prms.args[\"feature_height\"] * mm\n            label_font_size = lovis4u.Methods.str_height_to_size(label_height,\n                                                                 self.prms.args[\"locus_label_id_font_face\"])\n        elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n            label_font_size = self.prms.args[\"bottom_locus_label_font_size\"]\n            label_height = lovis4u.Methods.str_font_size_to_height(label_font_size,\n                                                                   self.prms.args[\"locus_label_id_font_face\"])\n        else:\n            raise lovis4u.Manager.lovis4uError(\"Locus label position parameter should be either 'bottom' \"\n                                               \"or 'left'.\")\n        self.prms.args[\"locus_label_height\"] = label_height\n        self.prms.args[\"locus_label_font_size\"] = label_font_size\n        max_id_string_width = max([pdfmetrics.stringWidth(i.seq_id, self.prms.args[\"locus_label_id_font_face\"],\n                                                          self.prms.args[\"locus_label_font_size\"]) for i in\n                                   loci.loci])\n        if self.prms.args[\"locus_label_style\"] != \"id\":\n            max_descr_string_width = \\\n                max([pdfmetrics.stringWidth(i, self.prms.args[\"locus_label_description_font_face\"],\n                                            self.prms.args[\"locus_label_font_size\"])\n                     for i in annotated_descriptions])\n\n        if self.prms.args[\"locus_label_style\"] == \"full\":\n            max_label_string_width = max(max_id_string_width, max_descr_string_width)\n        elif self.prms.args[\"locus_label_style\"] == \"id\":\n            max_label_string_width = max_id_string_width\n        elif self.prms.args[\"locus_label_style\"] == \"description\":\n            max_label_string_width = max_descr_string_width\n        loci_lengths = loci.get_loci_lengths_and_n_of_regions()\n        self.layout[\"total_nt_width\"] = max(i[0] for i in loci_lengths)\n        if self.prms.args[\"figure_width\"]:\n            if self.prms.args[\"locus_label_position\"] == \"left\":\n                figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - max_label_string_width - \\\n                                        2 * self.prms.args[\"margin\"] * mm \\\n                                        - self.prms.args[\"gap_after_locus_label\"] * mm\n            elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n                figure_width_for_loci = self.prms.args[\"figure_width\"] * mm - 2 * self.prms.args[\"margin\"] * mm\n            self.prms.args[\"mm_per_nt\"] = mm * figure_width_for_loci / self.layout[\"total_nt_width\"]\n        else:\n            width_per_nt = self.prms.args[\"mm_per_nt\"] * mm\n            figure_width_for_loci = width_per_nt * self.layout[\"total_nt_width\"]\n            if figure_width_for_loci &lt; 8 * cm:\n                width_per_nt = 8 * cm / self.layout[\"total_nt_width\"]\n            self.prms.args[\"mm_per_nt\"] = width_per_nt / mm\n        self.layout[\"width_per_nt\"] = self.prms.args[\"mm_per_nt\"] / mm\n        self.layout[\"x_gap_between_regions\"] = self.prms.args[\"gap_between_regions\"] * mm\n        each_loci_region_width = [\n            (i[0] * self.layout[\"width_per_nt\"]) + (i[1] * self.layout[\"x_gap_between_regions\"])\n            for i in loci_lengths]\n        max_loci_region_length = max(each_loci_region_width)\n        self.layout[\"locus_label_left_border\"] = self.prms.args[\"margin\"] * mm\n        if self.prms.args[\"locus_label_position\"] == \"left\":\n            self.layout[\"locus_label_right_border\"] = self.layout[\n                                                          \"locus_label_left_border\"] + max_label_string_width\n            self.layout[\"loci_tracks_left_border\"] = self.layout[\"locus_label_right_border\"] + \\\n                                                     self.prms.args[\"gap_after_locus_label\"] * mm\n            self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                      max_loci_region_length\n        elif self.prms.args[\"locus_label_position\"] == \"bottom\":\n            self.layout[\"loci_tracks_left_border\"] = self.prms.args[\"margin\"] * mm\n            self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + \\\n                                                      max_loci_region_length\n        self.layout[\"figure_width\"] = self.layout[\"loci_tracks_right_border\"] + self.prms.args[\"margin\"] * mm\n        self.layout[\"figure_height\"] = self.prms.args[\"margin\"] * mm\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define layout from loci data.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.plot","title":"<code>plot(filename)</code>","text":"<p>Plot all added tracks and save the plot as pdf.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>filename for the output pdf.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def plot(self, filename: str) -&gt; None:\n    \"\"\"Plot all added tracks and save the plot as pdf.\n\n    Arguments:\n        filename (str): filename for the output pdf.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        file_path = os.path.join(self.prms.args[\"output_dir\"], filename)\n        self.layout[\"figure_height\"] += (self.prms.args[\"margin\"] - self.prms.args[\"gap\"]) * mm\n        plot = Canvas(file_path, self.layout[\"figure_width\"], self.layout[\"figure_height\"], self.prms)\n\n        for cross_track in self.cross_tracks:\n            cross_track.draw(plot.canvas)\n\n        current_y_coordinate = self.layout[\"figure_height\"] - self.prms.args[\"margin\"] * mm\n        for track in self.tracks:\n            track.layout[\"current_y_coordinate\"] = current_y_coordinate\n            track.layout[\"figure_height\"] = self.layout[\"figure_height\"]\n            track.draw(plot.canvas)\n            current_y_coordinate -= track.track_data[\"track_height\"] + self.prms.args[\"gap\"] * mm\n        plot.save()\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u29bf lovis4u plot was saved as: {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to plot the canvas and save the figure.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader","title":"<code>CategoriesColorLegendLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A CategoriesColorLegendLoader object prepares data for a categories colour legend track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class CategoriesColorLegendLoader(Loader):\n    \"\"\"A CategoriesColorLegendLoader object prepares data for a categories colour legend track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a CategoriesColorLegendLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, layout: dict, loci) -&gt; None:\n        \"\"\"Prepare ScaleLoader specific data.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            self.track_data = dict()\n            label_height = lovis4u.Methods.str_font_size_to_height(\n                self.prms.args[\"colour_legend_label_font_size\"], self.prms.args[\"colour_legend_font_face\"])\n            line_width = self.prms.args[\"colour_legend_line_width\"] * mm\n            line_gap = 0.4 * label_height\n            self.track_data[\"line_width\"] = line_width\n            self.track_data[\"colour_legend_label_size\"] = self.prms.args[\"colour_legend_label_font_size\"]\n            left_border = self.layout[\"loci_tracks_left_border\"]\n            right_border = self.layout[\"loci_tracks_right_border\"]\n            x_gap = pdfmetrics.stringWidth(\" \" * 5, self.prms.args[\"colour_legend_font_face\"],\n                                           self.track_data[\"colour_legend_label_size\"])\n            y_gap = 0.5 * label_height\n            colour_dict = dict()\n            for locus in loci.loci:\n                colour_dict.update(locus.category_colours)\n            self.track_data[\"labels\"] = []\n            current_x = left_border\n            n_of_rows = 0\n            current_y = - (label_height + line_gap + line_width)\n            for label, colour in colour_dict.items():\n                label_dict = dict()\n                label_width = pdfmetrics.stringWidth(label, self.prms.args[\"colour_legend_font_face\"],\n                                                     self.track_data[\"colour_legend_label_size\"])\n                label_end = current_x + label_width\n                if label_end &gt; right_border:\n                    current_x = left_border\n                    current_y -= (label_height + line_gap + line_width + y_gap)\n                    n_of_rows += 1\n                label_dict[\"label_x\"] = current_x\n                label_dict[\"label_width\"] = label_width\n                label_dict[\"relative_y\"] = current_y\n                label_dict[\"relative_y_text\"] = current_y + line_gap + line_width\n                label_dict[\"colour\"] = colour\n                label_dict[\"label\"] = label\n                self.track_data[\"labels\"].append(label_dict)\n                current_x = label_dict[\"label_x\"] + label_width + x_gap\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare categories colour legend track specific data.\") \\\n                from error\n\n    def calculate_track_height(self):\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            if self.track_data[\"labels\"]:\n                min_relative_y = min([i[\"relative_y\"] for i in self.track_data[\"labels\"]])\n                track_height = abs(min_relative_y)\n            else:\n                track_height = 0\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a categories colour legend track height.\") \\\n                from error\n\n    def create_track(self):\n        \"\"\"Initialise a ColorLegendVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis | None: visualisation track.\n\n        \"\"\"\n        try:\n            if self.track_data[\"labels\"]:\n                return lovis4u.Drawing.ColorLegendVis(self.layout, self.track_data, self.prms)\n            else:\n                if self.prms.args[\"verbose\"]:\n                    print(\"\u25cb Warning message: Category colours legend track cannot be created since there is no \"\n                          \"categories.\", file=sys.stdout)\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a categories colour legend track track object.\") \\\n                from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a CategoriesColorLegendLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a CategoriesColorLegendLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code>        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self):\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        if self.track_data[\"labels\"]:\n            min_relative_y = min([i[\"relative_y\"] for i in self.track_data[\"labels\"]])\n            track_height = abs(min_relative_y)\n        else:\n            track_height = 0\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a categories colour legend track height.\") \\\n            from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a ColorLegendVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis | None: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a ColorLegendVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis | None: visualisation track.\n\n    \"\"\"\n    try:\n        if self.track_data[\"labels\"]:\n            return lovis4u.Drawing.ColorLegendVis(self.layout, self.track_data, self.prms)\n        else:\n            if self.prms.args[\"verbose\"]:\n                print(\"\u25cb Warning message: Category colours legend track cannot be created since there is no \"\n                      \"categories.\", file=sys.stdout)\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a categories colour legend track track object.\") \\\n            from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(layout, loci)</code>","text":"<p>Prepare ScaleLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, layout: dict, loci) -&gt; None:\n    \"\"\"Prepare ScaleLoader specific data.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        self.track_data = dict()\n        label_height = lovis4u.Methods.str_font_size_to_height(\n            self.prms.args[\"colour_legend_label_font_size\"], self.prms.args[\"colour_legend_font_face\"])\n        line_width = self.prms.args[\"colour_legend_line_width\"] * mm\n        line_gap = 0.4 * label_height\n        self.track_data[\"line_width\"] = line_width\n        self.track_data[\"colour_legend_label_size\"] = self.prms.args[\"colour_legend_label_font_size\"]\n        left_border = self.layout[\"loci_tracks_left_border\"]\n        right_border = self.layout[\"loci_tracks_right_border\"]\n        x_gap = pdfmetrics.stringWidth(\" \" * 5, self.prms.args[\"colour_legend_font_face\"],\n                                       self.track_data[\"colour_legend_label_size\"])\n        y_gap = 0.5 * label_height\n        colour_dict = dict()\n        for locus in loci.loci:\n            colour_dict.update(locus.category_colours)\n        self.track_data[\"labels\"] = []\n        current_x = left_border\n        n_of_rows = 0\n        current_y = - (label_height + line_gap + line_width)\n        for label, colour in colour_dict.items():\n            label_dict = dict()\n            label_width = pdfmetrics.stringWidth(label, self.prms.args[\"colour_legend_font_face\"],\n                                                 self.track_data[\"colour_legend_label_size\"])\n            label_end = current_x + label_width\n            if label_end &gt; right_border:\n                current_x = left_border\n                current_y -= (label_height + line_gap + line_width + y_gap)\n                n_of_rows += 1\n            label_dict[\"label_x\"] = current_x\n            label_dict[\"label_width\"] = label_width\n            label_dict[\"relative_y\"] = current_y\n            label_dict[\"relative_y_text\"] = current_y + line_gap + line_width\n            label_dict[\"colour\"] = colour\n            label_dict[\"label\"] = label\n            self.track_data[\"labels\"].append(label_dict)\n            current_x = label_dict[\"label_x\"] + label_width + x_gap\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare categories colour legend track specific data.\") \\\n            from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader","title":"<code>Loader</code>","text":"<p>Parent class for tracks loaders.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Loader:\n    \"\"\"Parent class for tracks loaders.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters: Parameters):\n        \"\"\"Parent's constructor for creating a Loader class object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.prms = parameters\n        self.layout = None\n        self.track_data = None\n\n    def prepare_track_specific_data(self) -&gt; None:\n        \"\"\"Empty parent's method for data preparation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def calculate_track_height(self) -&gt; None:\n        \"\"\"Empty parent's method for track height calculation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def create_track(self) -&gt; None:\n        \"\"\"Empty parent's method for track initialisation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Parent's constructor for creating a Loader class object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters: Parameters):\n    \"\"\"Parent's constructor for creating a Loader class object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.prms = parameters\n    self.layout = None\n    self.track_data = None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Empty parent's method for track height calculation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self) -&gt; None:\n    \"\"\"Empty parent's method for track height calculation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.create_track","title":"<code>create_track()</code>","text":"<p>Empty parent's method for track initialisation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self) -&gt; None:\n    \"\"\"Empty parent's method for track initialisation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.prepare_track_specific_data","title":"<code>prepare_track_specific_data()</code>","text":"<p>Empty parent's method for data preparation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self) -&gt; None:\n    \"\"\"Empty parent's method for data preparation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader","title":"<code>LocusLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A LocusLoader object prepares data for a Locus track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class LocusLoader(Loader):\n    \"\"\"A LocusLoader object prepares data for a Locus track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a LocusLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, locus, layout: dict) -&gt; None:\n        \"\"\"Prepare LocusLoader specific data.\n\n        Attributes:\n            locus (lovis4u.DataProcessing.Locus): corresponding locus object.\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            layout[\"inverse_y_coordinate\"] = layout[\"figure_height\"]\n            track_data = dict()\n            self.track_data = track_data\n            track_data[\"locus_id_width\"] = pdfmetrics.stringWidth(locus.seq_id,\n                                                                  self.prms.args[\"locus_label_id_font_face\"],\n                                                                  self.prms.args[\"locus_label_font_size\"])\n            two_space_width = pdfmetrics.stringWidth(\"  \", self.prms.args[\"locus_label_id_font_face\"],\n                                                     self.prms.args[\"locus_label_font_size\"])\n            track_data[\"two_space_width\"] = two_space_width\n            track_data[\"locus_id\"] = locus.seq_id\n            track_data[\"locus_description\"] = locus.description\n            if locus.description:\n                track_data[\"locus_description_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                               self.prms.args[\"locus_label_description\"\n                                                                                              \"_font_face\"],\n                                                                               self.prms.args[\"locus_label_font_size\"])\n            if self.prms.args[\"locus_label_position\"] == \"bottom\":\n                txt_coordinates = []\n                for i in range(len(locus.coordinates)):\n                    cc = locus.coordinates[i].copy()\n                    cc_txt = f\"{cc['start']}:{cc['end']}{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                    if i &gt; 0 and locus.circular:\n                        if cc[\"start\"] == 1 and locus.coordinates[i - 1][\"end\"] == locus.length:\n                            txt_coordinates[-1] = f\"{locus.coordinates[i - 1]['start']}:{cc['end']}\" \\\n                                                  f\"{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                            continue\n                    txt_coordinates.append(cc_txt)\n                track_data[\"text_coordinates\"] = \", \".join(txt_coordinates)\n                track_data[\"text_coordinates_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                              self.prms.args[\n                                                                                  \"locus_label_id_font_face\"],\n                                                                              self.prms.args[\"locus_label_font_size\"])\n\n            track_data[\"f_label_font_size\"] = self.prms.args[\"feature_label_font_size\"]\n            track_data[\"f_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n                track_data[\"f_label_font_size\"], self.prms.args[\"feature_label_font_face\"])\n            track_data[\"feature_label_gap\"] = self.prms.args[\"feature_label_gap\"] * track_data[\"f_label_height\"]\n\n            # Managing features positions and parameters\n            track_data[\"clean_features_coordinates\"] = False\n            track_data[\"features\"] = []\n            features_taken_nt_coordinates = []\n            for feature in locus.features:\n                features_taken_nt_coordinates.append([feature.start, feature.end])\n                if feature.vis_prms[\"fill_colour\"] == \"default\":\n                    feature.vis_prms[\"fill_colour\"] = lovis4u.Methods.get_colour(\"feature_default_fill_colour\",\n                                                                                 self.prms)\n                if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                        feature.vis_prms[\"stroke_colour\"] == \"default\":\n                    scale_l = self.prms.args[\"feature_stroke_colour_relative_lightness\"]\n                    feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.scale_lightness(feature.vis_prms[\"fill_colour\"],\n                                                                                        scale_l)\n                elif not self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                        feature.vis_prms[\"stroke_colour\"] == \"default\":\n                    feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.get_colour(\"feature_default_stroke_colour\",\n                                                                                   self.prms)\n                f_label_width = 0\n                if feature.vis_prms[\"show_label\"] and feature.vis_prms[\"label\"]:\n                    f_label_width = pdfmetrics.stringWidth(feature.vis_prms[\"label\"],\n                                                           self.prms.args[\"feature_label_font_face\"],\n                                                           track_data[\"f_label_font_size\"])\n                feature_vis_data = feature.vis_prms\n                feature_vis_data[\"coordinates\"] = lovis4u.Methods.feature_nt_to_x_transform(feature.start, feature.end,\n                                                                                            feature.strand, locus,\n                                                                                            layout)\n                feature_vis_data[\"label_width\"] = f_label_width\n                feature_vis_data[\"feature_width\"] = feature_vis_data[\"coordinates\"][\"end\"] - \\\n                                                    feature_vis_data[\"coordinates\"][\"start\"]\n                feature_vis_data[\"group\"] = feature.group\n                track_data[\"features\"].append(feature_vis_data)\n            # Managing category visualisation\n            feature_cateregories = set([feature.category for feature in locus.features if feature.category])\n            track_data[\"functions_coordinates\"] = None\n            if feature_cateregories and locus.category_colours:\n                track_data[\"category_colours\"] = locus.category_colours\n                track_data[\"functions_coordinates\"] = dict()\n                for ff in feature_cateregories:\n                    ff_features = [feature for feature in locus.features if feature.category == ff]\n                    ff_coordinates = [[f.vis_prms[\"coordinates\"][\"start\"], f.vis_prms[\"coordinates\"][\"end\"]] for f in\n                                      ff_features]\n                    track_data[\"functions_coordinates\"][ff] = ff_coordinates\n            # Managing feature labels' positions:\n            taken_label_coordinates = collections.defaultdict(list)\n            if sum([fvd[\"show_label\"] for fvd in track_data[\"features\"]]) &gt; 0:\n                space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"feature_label_font_face\"],\n                                                     track_data[\"f_label_font_size\"])\n                sorted_features = sorted(track_data[\"features\"], key=lambda x: x[\"feature_width\"] - x[\"label_width\"],\n                                         reverse=True)\n                for fvd in [fvd for fvd in sorted_features if fvd[\"label_width\"]]:\n                    feature_center = fvd[\"coordinates\"][\"center\"]\n                    width_diff = fvd[\"label_width\"] - fvd[\"feature_width\"]\n                    left_position = [fvd[\"coordinates\"][\"start\"] - width_diff, fvd[\"coordinates\"][\"end\"]]\n                    centered_position = [feature_center - fvd[\"label_width\"] / 2,\n                                         feature_center + fvd[\"label_width\"] / 2]\n                    right_position = [fvd[\"coordinates\"][\"start\"], fvd[\"coordinates\"][\"end\"] + width_diff]\n                    for pos in [left_position, centered_position, right_position]:\n                        overlap = 0\n                        if pos[0] &lt; layout[\"loci_tracks_left_border\"]:\n                            overlap = layout[\"loci_tracks_left_border\"] - pos[0]\n                        if pos[1] &gt; layout[\"loci_tracks_right_border\"]:\n                            overlap = layout[\"loci_tracks_right_border\"] - pos[1]\n                        if overlap:\n                            pos[0] += overlap\n                            pos[1] += overlap\n                    label_position = centered_position\n                    if width_diff &gt; 0:\n                        left_pos_overlap = [of for of in track_data[\"features\"] if\n                                            (of != fvd and left_position[0] &lt; of[\"coordinates\"][\"end\"] &lt;\n                                             fvd[\"coordinates\"][\"end\"] and of[\"show_label\"])]\n                        right_pos_overlap = [of for of in track_data[\"features\"] if\n                                             (of != fvd and right_position[1] &gt; of[\"coordinates\"][\"start\"] &gt;\n                                              fvd[\"coordinates\"][\"start\"] and of[\"show_label\"])]\n                        if left_pos_overlap and not right_pos_overlap:\n                            min_n_distance = min([fvd[\"coordinates\"][\"start\"] - nf[\"coordinates\"][\"end\"]\n                                                  for nf in left_pos_overlap])\n                            if min_n_distance &lt; space_width:\n                                right_position[0] += space_width + min(0, min_n_distance)\n                                right_position[1] += space_width + min(0, min_n_distance)\n                            label_position = right_position\n                        elif not left_pos_overlap and right_pos_overlap:\n                            min_n_distance = min([nf[\"coordinates\"][\"start\"] - fvd[\"coordinates\"][\"end\"]\n                                                  for nf in right_pos_overlap])\n                            label_position = left_position\n                            if min_n_distance &lt; space_width and left_position[0] != layout[\"loci_tracks_left_border\"]:\n                                left_position[0] -= space_width\n                                left_position[1] -= space_width\n                            else:\n                                label_position = centered_position\n                        else:\n                            label_position = centered_position\n                    fvd[\"label_position\"] = label_position\n                    for label_row in range(0, len(track_data[\"features\"])):\n                        overlapped = False\n                        for taken_coordinate in taken_label_coordinates[label_row]:\n                            if taken_coordinate[0] &lt;= label_position[0] &lt;= taken_coordinate[1] or \\\n                                    taken_coordinate[0] &lt;= label_position[1] &lt;= taken_coordinate[1] or \\\n                                    label_position[0] &lt;= taken_coordinate[0] &lt;= label_position[1] or \\\n                                    label_position[0] &lt;= taken_coordinate[1] &lt;= label_position[1]:\n                                overlapped = True\n                        if not overlapped:\n                            fvd[\"label_row\"] = label_row\n                            taken_label_coordinates[label_row].append(label_position)\n                            break\n                    fvd[\"label_y_bottom\"] = track_data[\"feature_label_gap\"] + \\\n                                            (fvd[\"label_row\"] * track_data[\"f_label_height\"]) + \\\n                                            (fvd[\"label_row\"] * track_data[\"feature_label_gap\"])\n                for fvd in track_data[\"features\"]:\n                    if fvd[\"label_width\"]:\n                        if fvd[\"label_row\"] &gt; 0:\n                            taken_middle_rows = [i for i in range(fvd[\"label_row\"] - 1, -1, -1) if\n                                                 any(taken_coordinate[0] &lt;= fvd[\"coordinates\"][\"center\"] &lt;=\n                                                     taken_coordinate[1]\n                                                     for taken_coordinate in taken_label_coordinates[i])]\n                            label_line_upper = fvd[\"label_y_bottom\"] - track_data[\"feature_label_gap\"] / 2\n                            label_line_bottom = track_data[\"feature_label_gap\"] / 2\n                            label_line_coordinates = []\n                            ll_start = label_line_bottom\n                            for tmr in sorted(taken_middle_rows):\n                                tmr_start = 0.5 * track_data[\"feature_label_gap\"] + \\\n                                            (tmr * track_data[\"f_label_height\"]) + \\\n                                            (tmr * track_data[\"feature_label_gap\"])\n                                tmr_end = tmr_start + track_data[\"f_label_height\"] + \\\n                                          0.5 * track_data[\"feature_label_gap\"]\n                                label_line_coordinates.append([ll_start, tmr_start])\n                                ll_start = tmr_end\n                            label_line_coordinates.append([ll_start, label_line_upper])\n                            fvd[\"label_line_coordinates\"] = label_line_coordinates\n            track_data[\"n_label_rows\"] = sum([1 for k, v in taken_label_coordinates.items() if v])\n            # Managing middle line indicating locus borders\n            if self.prms.args[\"draw_middle_line\"]:\n                regions_for_middle_line = [[c[\"start\"], c[\"end\"]] for c in locus.coordinates]\n                for ftc in features_taken_nt_coordinates:\n                    ftcs, ftse = ftc\n                    for added_region in regions_for_middle_line:\n                        new_regions = []\n                        to_remove = False\n                        if added_region[0] &lt;= ftcs &lt;= added_region[1]:\n                            to_remove = True\n                            if ftcs &gt; added_region[0]:\n                                new_regions.append([added_region[0], ftcs - 1])\n                        if added_region[0] &lt;= ftse &lt;= added_region[1]:\n                            to_remove = True\n                            if ftse &lt; added_region[1]:\n                                new_regions.append([ftse + 1, added_region[1]])\n                        if to_remove:\n                            regions_for_middle_line.remove(added_region)\n                        regions_for_middle_line += new_regions\n                middle_line_coordinates = [lovis4u.Methods.region_nt_to_x_transform(rml[0], rml[1], locus, layout)\n                                           for rml in regions_for_middle_line]\n                track_data[\"middle_line_coordinates\"] = middle_line_coordinates\n            track_data[\"proteome_size\"] = len(locus.features)  # to change if we get other features\n            # Managing individual x axis\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                track_data[\"x_axis_annotation\"] = dict()\n                self.prms.args[\"x_axis_ticks_labels_height\"] = lovis4u.Methods.str_font_size_to_height(\n                    self.prms.args[\"x_axis_ticks_labels_font_size\"],\n                    self.prms.args[\"x_axis_ticks_labels_font_face\"]) / mm\n                track_data[\"x_axis_annotation\"][\"label_size\"] = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n                axis_regions = []\n                axis_tics_coordinates = []\n                for coordinate in locus.coordinates:\n                    axis_regions.append(lovis4u.Methods.region_nt_to_x_transform(coordinate[\"start\"], coordinate[\"end\"],\n                                                                                 locus, layout))\n                    current_tics_coordinates = [coordinate[\"start\"], coordinate[\"end\"]]\n                    axis_tics_coordinates += current_tics_coordinates\n                if len(axis_tics_coordinates) == 2:\n                    nt_range = coordinate[\"end\"] - coordinate[\"start\"]\n                    axis_tics_coordinates.append(coordinate[\"start\"] + int(0.25 * nt_range))\n                    axis_tics_coordinates.append(coordinate[\"start\"] + int(0.5 * nt_range))\n                    axis_tics_coordinates.append(coordinate[\"end\"] - int(0.25 * nt_range))\n\n                axis_tics_positions = list(map(lambda x: lovis4u.Methods.nt_to_x_transform(x, locus, layout, \"center\"),\n                                               axis_tics_coordinates))\n                sorted_tics = sorted(zip(axis_tics_positions, axis_tics_coordinates))\n                sorted_positions, sorted_coordinates = zip(*sorted_tics)\n                axis_tics_positions = list(sorted_positions)\n                axis_tics_coordinates = list(sorted_coordinates)\n                axis_tics_labels = list(map(str, axis_tics_coordinates))\n                axis_tics_label_size = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n                axis_tics_label_width = list(map(lambda x: pdfmetrics.stringWidth(x,\n                                                                                  self.prms.args[\n                                                                                      \"x_axis_ticks_labels_font_face\"],\n                                                                                  axis_tics_label_size),\n                                                 axis_tics_labels))\n\n                space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                     axis_tics_label_size)\n                tics_labels_coordinates = axis_tics_positions.copy()\n                # Shitty, refactor later\n                for t_i in range(len(axis_tics_coordinates)):\n                    label_width = axis_tics_label_width[t_i]\n                    tick_position = axis_tics_positions[t_i]\n                    if t_i == 0:\n                        tics_labels_coordinates[t_i] += label_width * 0.5\n                    elif t_i != len(axis_tics_coordinates) - 1:\n                        center_label_coordinates = [tick_position - 0.5 * label_width,\n                                                    tick_position + 0.5 * label_width]\n                        if center_label_coordinates[0] - space_width &lt;= axis_tics_positions[t_i - 1]:\n                            tics_labels_coordinates[t_i] += label_width * 0.5\n                            if axis_tics_positions[t_i] - axis_tics_positions[t_i - 1] &lt; space_width:\n                                tics_labels_coordinates[t_i] += space_width\n                        if center_label_coordinates[1] + space_width &gt;= axis_tics_positions[t_i + 1]:\n                            tics_labels_coordinates[t_i] -= label_width * 0.5\n                            if axis_tics_positions[t_i + 1] - axis_tics_positions[t_i] &lt; space_width:\n                                tics_labels_coordinates[t_i] -= space_width\n                    if tics_labels_coordinates[t_i] + label_width * 0.5 &gt; layout[\"loci_tracks_right_border\"]:\n                        tics_labels_coordinates[t_i] -= ((tics_labels_coordinates[t_i] + label_width * 0.5) -\n                                                         layout[\"loci_tracks_right_border\"])\n                track_data[\"x_axis_annotation\"][\"axis_regions\"] = axis_regions\n                track_data[\"x_axis_annotation\"][\"axis_tics_position\"] = axis_tics_positions\n                track_data[\"x_axis_annotation\"][\"axis_tics_labels\"] = axis_tics_labels\n                track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"] = tics_labels_coordinates\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare Locus specific data.\") from error\n\n    def calculate_track_height(self) -&gt; float:\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            track_height = self.prms.args[\"feature_height\"] * mm + \\\n                           (self.track_data[\"n_label_rows\"] * self.track_data[\"f_label_height\"] * \\\n                            (1 + self.prms.args[\"feature_label_gap\"]))\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                track_height += (self.prms.args[\"feature_bottom_gap\"] + self.prms.args[\"x_axis_ticks_height\"] * 1.3 + \\\n                                 self.prms.args[\"x_axis_ticks_labels_height\"]) * mm\n            elif not self.prms.args[\"draw_individual_x_axis\"] and self.track_data[\"functions_coordinates\"]:\n                track_height += (self.prms.args[\"feature_bottom_gap\"] + \\\n                                 self.prms.args[\"category_annotation_line_width\"]) * mm\n            if self.prms.args[\"locus_label_position\"] == \"bottom\":\n                track_height += self.prms.args[\"locus_label_height\"] + self.prms.args[\"feature_bottom_gap\"] * mm\n\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a locus track height.\") from error\n\n    def create_track(self):\n        \"\"\"Initialise a LocusVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis: visualisation track.\n\n        \"\"\"\n        try:\n            return lovis4u.Drawing.LocusVis(self.layout, self.track_data, self.prms)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a locus track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a LocusLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a LocusLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self) -&gt; float:\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        track_height = self.prms.args[\"feature_height\"] * mm + \\\n                       (self.track_data[\"n_label_rows\"] * self.track_data[\"f_label_height\"] * \\\n                        (1 + self.prms.args[\"feature_label_gap\"]))\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            track_height += (self.prms.args[\"feature_bottom_gap\"] + self.prms.args[\"x_axis_ticks_height\"] * 1.3 + \\\n                             self.prms.args[\"x_axis_ticks_labels_height\"]) * mm\n        elif not self.prms.args[\"draw_individual_x_axis\"] and self.track_data[\"functions_coordinates\"]:\n            track_height += (self.prms.args[\"feature_bottom_gap\"] + \\\n                             self.prms.args[\"category_annotation_line_width\"]) * mm\n        if self.prms.args[\"locus_label_position\"] == \"bottom\":\n            track_height += self.prms.args[\"locus_label_height\"] + self.prms.args[\"feature_bottom_gap\"] * mm\n\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a locus track height.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a LocusVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a LocusVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis: visualisation track.\n\n    \"\"\"\n    try:\n        return lovis4u.Drawing.LocusVis(self.layout, self.track_data, self.prms)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a locus track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(locus, layout)</code>","text":"<p>Prepare LocusLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, locus, layout: dict) -&gt; None:\n    \"\"\"Prepare LocusLoader specific data.\n\n    Attributes:\n        locus (lovis4u.DataProcessing.Locus): corresponding locus object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        layout[\"inverse_y_coordinate\"] = layout[\"figure_height\"]\n        track_data = dict()\n        self.track_data = track_data\n        track_data[\"locus_id_width\"] = pdfmetrics.stringWidth(locus.seq_id,\n                                                              self.prms.args[\"locus_label_id_font_face\"],\n                                                              self.prms.args[\"locus_label_font_size\"])\n        two_space_width = pdfmetrics.stringWidth(\"  \", self.prms.args[\"locus_label_id_font_face\"],\n                                                 self.prms.args[\"locus_label_font_size\"])\n        track_data[\"two_space_width\"] = two_space_width\n        track_data[\"locus_id\"] = locus.seq_id\n        track_data[\"locus_description\"] = locus.description\n        if locus.description:\n            track_data[\"locus_description_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                           self.prms.args[\"locus_label_description\"\n                                                                                          \"_font_face\"],\n                                                                           self.prms.args[\"locus_label_font_size\"])\n        if self.prms.args[\"locus_label_position\"] == \"bottom\":\n            txt_coordinates = []\n            for i in range(len(locus.coordinates)):\n                cc = locus.coordinates[i].copy()\n                cc_txt = f\"{cc['start']}:{cc['end']}{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                if i &gt; 0 and locus.circular:\n                    if cc[\"start\"] == 1 and locus.coordinates[i - 1][\"end\"] == locus.length:\n                        txt_coordinates[-1] = f\"{locus.coordinates[i - 1]['start']}:{cc['end']}\" \\\n                                              f\"{'(+)' if cc['strand'] == 1 else '(-)'}\"\n                        continue\n                txt_coordinates.append(cc_txt)\n            track_data[\"text_coordinates\"] = \", \".join(txt_coordinates)\n            track_data[\"text_coordinates_width\"] = pdfmetrics.stringWidth(locus.description,\n                                                                          self.prms.args[\n                                                                              \"locus_label_id_font_face\"],\n                                                                          self.prms.args[\"locus_label_font_size\"])\n\n        track_data[\"f_label_font_size\"] = self.prms.args[\"feature_label_font_size\"]\n        track_data[\"f_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n            track_data[\"f_label_font_size\"], self.prms.args[\"feature_label_font_face\"])\n        track_data[\"feature_label_gap\"] = self.prms.args[\"feature_label_gap\"] * track_data[\"f_label_height\"]\n\n        # Managing features positions and parameters\n        track_data[\"clean_features_coordinates\"] = False\n        track_data[\"features\"] = []\n        features_taken_nt_coordinates = []\n        for feature in locus.features:\n            features_taken_nt_coordinates.append([feature.start, feature.end])\n            if feature.vis_prms[\"fill_colour\"] == \"default\":\n                feature.vis_prms[\"fill_colour\"] = lovis4u.Methods.get_colour(\"feature_default_fill_colour\",\n                                                                             self.prms)\n            if self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                    feature.vis_prms[\"stroke_colour\"] == \"default\":\n                scale_l = self.prms.args[\"feature_stroke_colour_relative_lightness\"]\n                feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.scale_lightness(feature.vis_prms[\"fill_colour\"],\n                                                                                    scale_l)\n            elif not self.prms.args[\"set_feature_stroke_colour_based_on_fill_colour\"] and \\\n                    feature.vis_prms[\"stroke_colour\"] == \"default\":\n                feature.vis_prms[\"stroke_colour\"] = lovis4u.Methods.get_colour(\"feature_default_stroke_colour\",\n                                                                               self.prms)\n            f_label_width = 0\n            if feature.vis_prms[\"show_label\"] and feature.vis_prms[\"label\"]:\n                f_label_width = pdfmetrics.stringWidth(feature.vis_prms[\"label\"],\n                                                       self.prms.args[\"feature_label_font_face\"],\n                                                       track_data[\"f_label_font_size\"])\n            feature_vis_data = feature.vis_prms\n            feature_vis_data[\"coordinates\"] = lovis4u.Methods.feature_nt_to_x_transform(feature.start, feature.end,\n                                                                                        feature.strand, locus,\n                                                                                        layout)\n            feature_vis_data[\"label_width\"] = f_label_width\n            feature_vis_data[\"feature_width\"] = feature_vis_data[\"coordinates\"][\"end\"] - \\\n                                                feature_vis_data[\"coordinates\"][\"start\"]\n            feature_vis_data[\"group\"] = feature.group\n            track_data[\"features\"].append(feature_vis_data)\n        # Managing category visualisation\n        feature_cateregories = set([feature.category for feature in locus.features if feature.category])\n        track_data[\"functions_coordinates\"] = None\n        if feature_cateregories and locus.category_colours:\n            track_data[\"category_colours\"] = locus.category_colours\n            track_data[\"functions_coordinates\"] = dict()\n            for ff in feature_cateregories:\n                ff_features = [feature for feature in locus.features if feature.category == ff]\n                ff_coordinates = [[f.vis_prms[\"coordinates\"][\"start\"], f.vis_prms[\"coordinates\"][\"end\"]] for f in\n                                  ff_features]\n                track_data[\"functions_coordinates\"][ff] = ff_coordinates\n        # Managing feature labels' positions:\n        taken_label_coordinates = collections.defaultdict(list)\n        if sum([fvd[\"show_label\"] for fvd in track_data[\"features\"]]) &gt; 0:\n            space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"feature_label_font_face\"],\n                                                 track_data[\"f_label_font_size\"])\n            sorted_features = sorted(track_data[\"features\"], key=lambda x: x[\"feature_width\"] - x[\"label_width\"],\n                                     reverse=True)\n            for fvd in [fvd for fvd in sorted_features if fvd[\"label_width\"]]:\n                feature_center = fvd[\"coordinates\"][\"center\"]\n                width_diff = fvd[\"label_width\"] - fvd[\"feature_width\"]\n                left_position = [fvd[\"coordinates\"][\"start\"] - width_diff, fvd[\"coordinates\"][\"end\"]]\n                centered_position = [feature_center - fvd[\"label_width\"] / 2,\n                                     feature_center + fvd[\"label_width\"] / 2]\n                right_position = [fvd[\"coordinates\"][\"start\"], fvd[\"coordinates\"][\"end\"] + width_diff]\n                for pos in [left_position, centered_position, right_position]:\n                    overlap = 0\n                    if pos[0] &lt; layout[\"loci_tracks_left_border\"]:\n                        overlap = layout[\"loci_tracks_left_border\"] - pos[0]\n                    if pos[1] &gt; layout[\"loci_tracks_right_border\"]:\n                        overlap = layout[\"loci_tracks_right_border\"] - pos[1]\n                    if overlap:\n                        pos[0] += overlap\n                        pos[1] += overlap\n                label_position = centered_position\n                if width_diff &gt; 0:\n                    left_pos_overlap = [of for of in track_data[\"features\"] if\n                                        (of != fvd and left_position[0] &lt; of[\"coordinates\"][\"end\"] &lt;\n                                         fvd[\"coordinates\"][\"end\"] and of[\"show_label\"])]\n                    right_pos_overlap = [of for of in track_data[\"features\"] if\n                                         (of != fvd and right_position[1] &gt; of[\"coordinates\"][\"start\"] &gt;\n                                          fvd[\"coordinates\"][\"start\"] and of[\"show_label\"])]\n                    if left_pos_overlap and not right_pos_overlap:\n                        min_n_distance = min([fvd[\"coordinates\"][\"start\"] - nf[\"coordinates\"][\"end\"]\n                                              for nf in left_pos_overlap])\n                        if min_n_distance &lt; space_width:\n                            right_position[0] += space_width + min(0, min_n_distance)\n                            right_position[1] += space_width + min(0, min_n_distance)\n                        label_position = right_position\n                    elif not left_pos_overlap and right_pos_overlap:\n                        min_n_distance = min([nf[\"coordinates\"][\"start\"] - fvd[\"coordinates\"][\"end\"]\n                                              for nf in right_pos_overlap])\n                        label_position = left_position\n                        if min_n_distance &lt; space_width and left_position[0] != layout[\"loci_tracks_left_border\"]:\n                            left_position[0] -= space_width\n                            left_position[1] -= space_width\n                        else:\n                            label_position = centered_position\n                    else:\n                        label_position = centered_position\n                fvd[\"label_position\"] = label_position\n                for label_row in range(0, len(track_data[\"features\"])):\n                    overlapped = False\n                    for taken_coordinate in taken_label_coordinates[label_row]:\n                        if taken_coordinate[0] &lt;= label_position[0] &lt;= taken_coordinate[1] or \\\n                                taken_coordinate[0] &lt;= label_position[1] &lt;= taken_coordinate[1] or \\\n                                label_position[0] &lt;= taken_coordinate[0] &lt;= label_position[1] or \\\n                                label_position[0] &lt;= taken_coordinate[1] &lt;= label_position[1]:\n                            overlapped = True\n                    if not overlapped:\n                        fvd[\"label_row\"] = label_row\n                        taken_label_coordinates[label_row].append(label_position)\n                        break\n                fvd[\"label_y_bottom\"] = track_data[\"feature_label_gap\"] + \\\n                                        (fvd[\"label_row\"] * track_data[\"f_label_height\"]) + \\\n                                        (fvd[\"label_row\"] * track_data[\"feature_label_gap\"])\n            for fvd in track_data[\"features\"]:\n                if fvd[\"label_width\"]:\n                    if fvd[\"label_row\"] &gt; 0:\n                        taken_middle_rows = [i for i in range(fvd[\"label_row\"] - 1, -1, -1) if\n                                             any(taken_coordinate[0] &lt;= fvd[\"coordinates\"][\"center\"] &lt;=\n                                                 taken_coordinate[1]\n                                                 for taken_coordinate in taken_label_coordinates[i])]\n                        label_line_upper = fvd[\"label_y_bottom\"] - track_data[\"feature_label_gap\"] / 2\n                        label_line_bottom = track_data[\"feature_label_gap\"] / 2\n                        label_line_coordinates = []\n                        ll_start = label_line_bottom\n                        for tmr in sorted(taken_middle_rows):\n                            tmr_start = 0.5 * track_data[\"feature_label_gap\"] + \\\n                                        (tmr * track_data[\"f_label_height\"]) + \\\n                                        (tmr * track_data[\"feature_label_gap\"])\n                            tmr_end = tmr_start + track_data[\"f_label_height\"] + \\\n                                      0.5 * track_data[\"feature_label_gap\"]\n                            label_line_coordinates.append([ll_start, tmr_start])\n                            ll_start = tmr_end\n                        label_line_coordinates.append([ll_start, label_line_upper])\n                        fvd[\"label_line_coordinates\"] = label_line_coordinates\n        track_data[\"n_label_rows\"] = sum([1 for k, v in taken_label_coordinates.items() if v])\n        # Managing middle line indicating locus borders\n        if self.prms.args[\"draw_middle_line\"]:\n            regions_for_middle_line = [[c[\"start\"], c[\"end\"]] for c in locus.coordinates]\n            for ftc in features_taken_nt_coordinates:\n                ftcs, ftse = ftc\n                for added_region in regions_for_middle_line:\n                    new_regions = []\n                    to_remove = False\n                    if added_region[0] &lt;= ftcs &lt;= added_region[1]:\n                        to_remove = True\n                        if ftcs &gt; added_region[0]:\n                            new_regions.append([added_region[0], ftcs - 1])\n                    if added_region[0] &lt;= ftse &lt;= added_region[1]:\n                        to_remove = True\n                        if ftse &lt; added_region[1]:\n                            new_regions.append([ftse + 1, added_region[1]])\n                    if to_remove:\n                        regions_for_middle_line.remove(added_region)\n                    regions_for_middle_line += new_regions\n            middle_line_coordinates = [lovis4u.Methods.region_nt_to_x_transform(rml[0], rml[1], locus, layout)\n                                       for rml in regions_for_middle_line]\n            track_data[\"middle_line_coordinates\"] = middle_line_coordinates\n        track_data[\"proteome_size\"] = len(locus.features)  # to change if we get other features\n        # Managing individual x axis\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            track_data[\"x_axis_annotation\"] = dict()\n            self.prms.args[\"x_axis_ticks_labels_height\"] = lovis4u.Methods.str_font_size_to_height(\n                self.prms.args[\"x_axis_ticks_labels_font_size\"],\n                self.prms.args[\"x_axis_ticks_labels_font_face\"]) / mm\n            track_data[\"x_axis_annotation\"][\"label_size\"] = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n            axis_regions = []\n            axis_tics_coordinates = []\n            for coordinate in locus.coordinates:\n                axis_regions.append(lovis4u.Methods.region_nt_to_x_transform(coordinate[\"start\"], coordinate[\"end\"],\n                                                                             locus, layout))\n                current_tics_coordinates = [coordinate[\"start\"], coordinate[\"end\"]]\n                axis_tics_coordinates += current_tics_coordinates\n            if len(axis_tics_coordinates) == 2:\n                nt_range = coordinate[\"end\"] - coordinate[\"start\"]\n                axis_tics_coordinates.append(coordinate[\"start\"] + int(0.25 * nt_range))\n                axis_tics_coordinates.append(coordinate[\"start\"] + int(0.5 * nt_range))\n                axis_tics_coordinates.append(coordinate[\"end\"] - int(0.25 * nt_range))\n\n            axis_tics_positions = list(map(lambda x: lovis4u.Methods.nt_to_x_transform(x, locus, layout, \"center\"),\n                                           axis_tics_coordinates))\n            sorted_tics = sorted(zip(axis_tics_positions, axis_tics_coordinates))\n            sorted_positions, sorted_coordinates = zip(*sorted_tics)\n            axis_tics_positions = list(sorted_positions)\n            axis_tics_coordinates = list(sorted_coordinates)\n            axis_tics_labels = list(map(str, axis_tics_coordinates))\n            axis_tics_label_size = self.prms.args[\"x_axis_ticks_labels_font_size\"]\n            axis_tics_label_width = list(map(lambda x: pdfmetrics.stringWidth(x,\n                                                                              self.prms.args[\n                                                                                  \"x_axis_ticks_labels_font_face\"],\n                                                                              axis_tics_label_size),\n                                             axis_tics_labels))\n\n            space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                 axis_tics_label_size)\n            tics_labels_coordinates = axis_tics_positions.copy()\n            # Shitty, refactor later\n            for t_i in range(len(axis_tics_coordinates)):\n                label_width = axis_tics_label_width[t_i]\n                tick_position = axis_tics_positions[t_i]\n                if t_i == 0:\n                    tics_labels_coordinates[t_i] += label_width * 0.5\n                elif t_i != len(axis_tics_coordinates) - 1:\n                    center_label_coordinates = [tick_position - 0.5 * label_width,\n                                                tick_position + 0.5 * label_width]\n                    if center_label_coordinates[0] - space_width &lt;= axis_tics_positions[t_i - 1]:\n                        tics_labels_coordinates[t_i] += label_width * 0.5\n                        if axis_tics_positions[t_i] - axis_tics_positions[t_i - 1] &lt; space_width:\n                            tics_labels_coordinates[t_i] += space_width\n                    if center_label_coordinates[1] + space_width &gt;= axis_tics_positions[t_i + 1]:\n                        tics_labels_coordinates[t_i] -= label_width * 0.5\n                        if axis_tics_positions[t_i + 1] - axis_tics_positions[t_i] &lt; space_width:\n                            tics_labels_coordinates[t_i] -= space_width\n                if tics_labels_coordinates[t_i] + label_width * 0.5 &gt; layout[\"loci_tracks_right_border\"]:\n                    tics_labels_coordinates[t_i] -= ((tics_labels_coordinates[t_i] + label_width * 0.5) -\n                                                     layout[\"loci_tracks_right_border\"])\n            track_data[\"x_axis_annotation\"][\"axis_regions\"] = axis_regions\n            track_data[\"x_axis_annotation\"][\"axis_tics_position\"] = axis_tics_positions\n            track_data[\"x_axis_annotation\"][\"axis_tics_labels\"] = axis_tics_labels\n            track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"] = tics_labels_coordinates\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare Locus specific data.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters","title":"<code>Parameters</code>","text":"<p>A Parameters object holds and parse command line's and config's arguments.</p> <p>A Parameters object have to be created in each script since it's used almost by each     class of the tool as a mandatory argument.</p> <p>Attributes:</p> <ul> <li> <code>args</code>             (<code>dict</code>)         \u2013          <p>dictionary that holds all arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Parameters:\n    \"\"\"A Parameters object holds and parse command line's and config's arguments.\n\n    A Parameters object have to be created in each script since it's used almost by each\n        class of the tool as a mandatory argument.\n\n    Attributes:\n        args (dict): dictionary that holds all arguments.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Create a Parameters object.\n\n        \"\"\"\n        self.args = dict(debug=False, verbose=False)\n        self.cmd_arguments = dict()\n\n    def parse_cmd_arguments(self) -&gt; None:\n        \"\"\"Parse command-line args\n\n        Returns:\n            None\n\n        \"\"\"\n        parser = argparse.ArgumentParser(prog=\"lovis4u\", add_help=False,\n                                         usage=\"lovis4u [-gff gff_folder | -gb gb_folder] [optional args]\")\n        parser.add_argument(\"-data\", \"--data\", dest=\"lovis4u_data\", action=\"store_true\")\n        parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n        parser.add_argument(\"-mac\", \"--mac\", dest=\"mac\", action=\"store_true\", default=None)\n        mutually_exclusive_group = parser.add_mutually_exclusive_group()\n        mutually_exclusive_group.add_argument(\"-gff\", \"--gff\", dest=\"gff\", type=str, default=None)\n        mutually_exclusive_group.add_argument(\"-gb\", \"--gb\", dest=\"gb\", type=str, default=None)\n        parser.add_argument(\"-ufid\", \"--use-filename-as-id\", dest=\"use_filename_as_contig_id\", action=\"store_true\",\n                            default=None)\n        parser.add_argument(\"-laf\", \"--locus-annotation-file\", dest=\"locus-annotation\", type=str, default=None)\n        parser.add_argument(\"-faf\", \"--feature-annotation-file\", dest=\"feature-annotation\", type=str, default=None)\n        parser.add_argument(\"-mmseqs-off\", \"--mmseqs-off\", dest=\"mmseqs\", action=\"store_false\")\n        parser.add_argument(\"-cl-owp\", \"--cluster-only-window-proteins\", dest=\"cluster_all_proteins\",\n                            action=\"store_false\", default=None)\n        parser.add_argument(\"-fv-off\", \"--find-variable-off\", dest=\"find-variable\", action=\"store_false\")\n        parser.add_argument(\"-cl-off\", \"--clust_loci-off\", dest=\"clust_loci\", action=\"store_false\")\n        parser.add_argument(\"-oc\", \"--one-cluster\", dest=\"one_cluster\", action=\"store_true\", default=None)\n        parser.add_argument(\"-reorient_loci\", \"--reorient_loci\", dest=\"reorient_loci\", action=\"store_true\")\n        parser.add_argument(\"-lls\", \"--locus-label-style\", dest=\"locus_label_style\",\n                            choices=[\"id\", \"description\", \"full\"], default=None)\n        parser.add_argument(\"-llp\", \"--locus-label-position\", dest=\"locus_label_position\",\n                            choices=[\"left\", \"bottom\"], default=None)\n        parser.add_argument(\"-sgc-off\", \"--set-group-colour-off\", dest=\"set-group-colour\", action=\"store_false\")\n        parser.add_argument(\"-sgcf\", \"--set-group-colour-for\", dest=\"feature_group_types_to_set_colour\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-scc\", \"--set-category-colour\", dest=\"set-category-colour\", action=\"store_true\")\n        parser.add_argument(\"-cct\", \"--category-colour-table\", dest=\"category_colours\", type=str, default=None)\n        parser.add_argument(\"-safl\", \"--show-all-feature-labels\", dest=\"show_all_feature_labels\",\n                            action=\"store_true\")\n        parser.add_argument(\"-sflf\", \"--show-feature-label-for\", dest=\"feature_group_types_to_show_label\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-sfflf\", \"--show-first-feature-label-for\",\n                            dest=\"feature_group_types_to_show_label_on_first_occurrence\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-ifl\", \"--ignored-feature-labels\", dest=\"feature_labels_to_ignore\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-hl\", \"--homology-links\", dest=\"homology-track\", action=\"store_true\")\n        parser.add_argument(\"-slt\", \"--scale-line-track\", dest=\"draw_scale_line_track\", action=\"store_true\",\n                            default=None)\n        parser.add_argument(\"-sxa\", \"--show-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_true\", default=None)\n        parser.add_argument(\"-hix\", \"--hide-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_false\", default=None)\n        parser.add_argument(\"-dml\", \"--draw-middle-line\", dest=\"draw_middle_line\", action=\"store_true\", default=None)\n        parser.add_argument(\"-mm-per-nt\", \"--mm-per-nt\", dest=\"mm_per_nt\", type=float, default=None)\n        parser.add_argument(\"-fw\", \"--figure-width\", dest=\"figure_width\", type=float, default=None)\n        parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n        parser.add_argument(\"--pdf-name\", dest=\"pdf-name\", type=str, default=\"lovis4u.pdf\")\n        parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"standard\")\n        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.0.9\")\n        parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n        parser.add_argument(\"--parsing-debug\", \"-parsing-debug\", dest=\"parsing_debug\", action=\"store_true\")\n        parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n        parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n        args = parser.parse_args()\n        args = vars(args)\n        if len(sys.argv[1:]) == 0:\n            args[\"help\"] = True\n        if args[\"lovis4u_data\"]:\n            lovis4u.Methods.copy_package_data()\n            sys.exit()\n        if args[\"linux\"]:\n            lovis4u.Methods.adjust_paths(\"linux\")\n            sys.exit()\n        if args[\"mac\"]:\n            lovis4u.Methods.adjust_paths(\"mac\")\n            sys.exit()\n        if args[\"help\"]:\n            help_message_path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"help.txt\")\n            with open(help_message_path, \"r\") as help_message:\n                print(help_message.read(), file=sys.stdout)\n                sys.exit()\n        if not args[\"gff\"] and not args[\"gb\"]:\n            raise lovis4u.Manager.lovis4uError(\"-gff or -gb parameter with folder path should be provided\")\n        args_to_keep = [\"locus-annotation\", \"feature-annotation\", \"gb\", \"gff\"]\n        filtered_args = {k: v for k, v in args.items() if v is not None or k in args_to_keep}\n        self.cmd_arguments = filtered_args\n        return None\n\n    def load_config(self, path: str = \"standard\") -&gt; None:\n        \"\"\"Load configuration file.\n\n        Arguments\n            path (str): path to a config file or name (only standard available at this moment).\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if path in [\"standard\", \"A4p1\", \"A4p2\", \"A4L\"]:\n                print(f\"\u25cb Loaded configuration file: '{path}'. List of available: \"\n                      f\"standard (auto-size),\\n\\tA4p1 (A4 page one-column [90mm]), A4p2 (A4 page two-column [190mm]), \"\n                      f\"and A4L (A4 landscape [240mm]).\\n\\tUse -c/--config &lt;name&gt; parameter for choosing.\",\n                      file=sys.stdout)\n                path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", f\"{path}.cfg\")\n            config = configs.load(path).get_config()\n            internal_dir = os.path.dirname(__file__)\n            for key in config[\"root\"].keys():\n                if isinstance(config[\"root\"][key], str):\n                    if config[\"root\"][key] == \"None\":\n                        config[\"root\"][key] = None\n                if isinstance(config[\"root\"][key], str) and \"{internal}\" in config[\"root\"][key]:\n                    config[\"root\"][key] = config[\"root\"][key].replace(\"{internal}\",\n                                                                      os.path.join(internal_dir, \"lovis4u_data\"))\n            config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                                time.strftime(\"%Y_%m_%d-%H_%M\"))\n            keys_to_transform_to_list = [\"feature_group_types_to_set_colour\", \"feature_group_types_to_show_label\",\n                                         \"genbank_id_alternative_source\", \"feature_labels_to_ignore\",\n                                         \"feature_group_types_to_show_label_on_first_occurrence\"]\n            for ktl in keys_to_transform_to_list:\n                if isinstance(config[\"root\"][ktl], str):\n                    if config[\"root\"][ktl] != \"None\":\n                        config[\"root\"][ktl] = [config[\"root\"][ktl]]\n                    else:\n                        config[\"root\"][ktl] = []\n            self.args.update(config[\"root\"])\n            self.load_palette()\n            self.load_fonts()\n            if self.cmd_arguments:\n                self.args.update(self.cmd_arguments)\n\n            if os.path.exists(self.args[\"output_dir\"]):\n                if self.args[\"verbose\"]:\n                    print(\"\u25cb Warning: the output folder already exists. Results will be rewritten (without removal \"\n                          \"other files in this folder)\", file=sys.stdout)\n            self.args[\"locus_label_description_font_face\"] = self.args[f\"locus_label_description_font_face_\" \\\n                                                                       f\"{self.args['locus_label_position']}\"]\n            self.args[\"locus_label_id_font_face\"] = self.args[f\"locus_label_id_font_face_\" \\\n                                                              f\"{self.args['locus_label_position']}\"]\n            # Check conflicts\n            if self.args[\"draw_individual_x_axis\"] and self.args[\"locus_label_position\"] == \"bottom\":\n                raise lovis4uError(\"Individual x-axis cannot be plotted when locus label position\"\n                                   \" set as 'bottom'.\")\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to parse the specified config file. Please check your config file \"\n                               \"or written name.\") from error\n\n    def load_palette(self) -&gt; None:\n        \"\"\"Load palette file.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            palette_path = self.args[f\"palette\"]\n            self.args[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to load palette.\") from error\n\n    def load_fonts(self) -&gt; None:\n        \"\"\"Load fonts.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            font_pattern = re.compile(r\"^font_(.*)$\")\n            font_subdict = {font_pattern.match(key).group(1): value for key, value in self.args.items() if\n                            font_pattern.match(key)}\n            for font_type, font_path in font_subdict.items():\n                pdfmetrics.registerFont(reportlab.pdfbase.ttfonts.TTFont(font_type, font_path))\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to load fonts.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.__init__","title":"<code>__init__()</code>","text":"<p>Create a Parameters object.</p> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self):\n    \"\"\"Create a Parameters object.\n\n    \"\"\"\n    self.args = dict(debug=False, verbose=False)\n    self.cmd_arguments = dict()\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.load_config","title":"<code>load_config(path='standard')</code>","text":"<p>Load configuration file.</p> <p>Arguments     path (str): path to a config file or name (only standard available at this moment).</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_config(self, path: str = \"standard\") -&gt; None:\n    \"\"\"Load configuration file.\n\n    Arguments\n        path (str): path to a config file or name (only standard available at this moment).\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if path in [\"standard\", \"A4p1\", \"A4p2\", \"A4L\"]:\n            print(f\"\u25cb Loaded configuration file: '{path}'. List of available: \"\n                  f\"standard (auto-size),\\n\\tA4p1 (A4 page one-column [90mm]), A4p2 (A4 page two-column [190mm]), \"\n                  f\"and A4L (A4 landscape [240mm]).\\n\\tUse -c/--config &lt;name&gt; parameter for choosing.\",\n                  file=sys.stdout)\n            path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", f\"{path}.cfg\")\n        config = configs.load(path).get_config()\n        internal_dir = os.path.dirname(__file__)\n        for key in config[\"root\"].keys():\n            if isinstance(config[\"root\"][key], str):\n                if config[\"root\"][key] == \"None\":\n                    config[\"root\"][key] = None\n            if isinstance(config[\"root\"][key], str) and \"{internal}\" in config[\"root\"][key]:\n                config[\"root\"][key] = config[\"root\"][key].replace(\"{internal}\",\n                                                                  os.path.join(internal_dir, \"lovis4u_data\"))\n        config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                            time.strftime(\"%Y_%m_%d-%H_%M\"))\n        keys_to_transform_to_list = [\"feature_group_types_to_set_colour\", \"feature_group_types_to_show_label\",\n                                     \"genbank_id_alternative_source\", \"feature_labels_to_ignore\",\n                                     \"feature_group_types_to_show_label_on_first_occurrence\"]\n        for ktl in keys_to_transform_to_list:\n            if isinstance(config[\"root\"][ktl], str):\n                if config[\"root\"][ktl] != \"None\":\n                    config[\"root\"][ktl] = [config[\"root\"][ktl]]\n                else:\n                    config[\"root\"][ktl] = []\n        self.args.update(config[\"root\"])\n        self.load_palette()\n        self.load_fonts()\n        if self.cmd_arguments:\n            self.args.update(self.cmd_arguments)\n\n        if os.path.exists(self.args[\"output_dir\"]):\n            if self.args[\"verbose\"]:\n                print(\"\u25cb Warning: the output folder already exists. Results will be rewritten (without removal \"\n                      \"other files in this folder)\", file=sys.stdout)\n        self.args[\"locus_label_description_font_face\"] = self.args[f\"locus_label_description_font_face_\" \\\n                                                                   f\"{self.args['locus_label_position']}\"]\n        self.args[\"locus_label_id_font_face\"] = self.args[f\"locus_label_id_font_face_\" \\\n                                                          f\"{self.args['locus_label_position']}\"]\n        # Check conflicts\n        if self.args[\"draw_individual_x_axis\"] and self.args[\"locus_label_position\"] == \"bottom\":\n            raise lovis4uError(\"Individual x-axis cannot be plotted when locus label position\"\n                               \" set as 'bottom'.\")\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to parse the specified config file. Please check your config file \"\n                           \"or written name.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.load_fonts","title":"<code>load_fonts()</code>","text":"<p>Load fonts.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_fonts(self) -&gt; None:\n    \"\"\"Load fonts.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        font_pattern = re.compile(r\"^font_(.*)$\")\n        font_subdict = {font_pattern.match(key).group(1): value for key, value in self.args.items() if\n                        font_pattern.match(key)}\n        for font_type, font_path in font_subdict.items():\n            pdfmetrics.registerFont(reportlab.pdfbase.ttfonts.TTFont(font_type, font_path))\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to load fonts.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.load_palette","title":"<code>load_palette()</code>","text":"<p>Load palette file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_palette(self) -&gt; None:\n    \"\"\"Load palette file.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        palette_path = self.args[f\"palette\"]\n        self.args[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to load palette.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.parse_cmd_arguments","title":"<code>parse_cmd_arguments()</code>","text":"<p>Parse command-line args</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def parse_cmd_arguments(self) -&gt; None:\n    \"\"\"Parse command-line args\n\n    Returns:\n        None\n\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"lovis4u\", add_help=False,\n                                     usage=\"lovis4u [-gff gff_folder | -gb gb_folder] [optional args]\")\n    parser.add_argument(\"-data\", \"--data\", dest=\"lovis4u_data\", action=\"store_true\")\n    parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n    parser.add_argument(\"-mac\", \"--mac\", dest=\"mac\", action=\"store_true\", default=None)\n    mutually_exclusive_group = parser.add_mutually_exclusive_group()\n    mutually_exclusive_group.add_argument(\"-gff\", \"--gff\", dest=\"gff\", type=str, default=None)\n    mutually_exclusive_group.add_argument(\"-gb\", \"--gb\", dest=\"gb\", type=str, default=None)\n    parser.add_argument(\"-ufid\", \"--use-filename-as-id\", dest=\"use_filename_as_contig_id\", action=\"store_true\",\n                        default=None)\n    parser.add_argument(\"-laf\", \"--locus-annotation-file\", dest=\"locus-annotation\", type=str, default=None)\n    parser.add_argument(\"-faf\", \"--feature-annotation-file\", dest=\"feature-annotation\", type=str, default=None)\n    parser.add_argument(\"-mmseqs-off\", \"--mmseqs-off\", dest=\"mmseqs\", action=\"store_false\")\n    parser.add_argument(\"-cl-owp\", \"--cluster-only-window-proteins\", dest=\"cluster_all_proteins\",\n                        action=\"store_false\", default=None)\n    parser.add_argument(\"-fv-off\", \"--find-variable-off\", dest=\"find-variable\", action=\"store_false\")\n    parser.add_argument(\"-cl-off\", \"--clust_loci-off\", dest=\"clust_loci\", action=\"store_false\")\n    parser.add_argument(\"-oc\", \"--one-cluster\", dest=\"one_cluster\", action=\"store_true\", default=None)\n    parser.add_argument(\"-reorient_loci\", \"--reorient_loci\", dest=\"reorient_loci\", action=\"store_true\")\n    parser.add_argument(\"-lls\", \"--locus-label-style\", dest=\"locus_label_style\",\n                        choices=[\"id\", \"description\", \"full\"], default=None)\n    parser.add_argument(\"-llp\", \"--locus-label-position\", dest=\"locus_label_position\",\n                        choices=[\"left\", \"bottom\"], default=None)\n    parser.add_argument(\"-sgc-off\", \"--set-group-colour-off\", dest=\"set-group-colour\", action=\"store_false\")\n    parser.add_argument(\"-sgcf\", \"--set-group-colour-for\", dest=\"feature_group_types_to_set_colour\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-scc\", \"--set-category-colour\", dest=\"set-category-colour\", action=\"store_true\")\n    parser.add_argument(\"-cct\", \"--category-colour-table\", dest=\"category_colours\", type=str, default=None)\n    parser.add_argument(\"-safl\", \"--show-all-feature-labels\", dest=\"show_all_feature_labels\",\n                        action=\"store_true\")\n    parser.add_argument(\"-sflf\", \"--show-feature-label-for\", dest=\"feature_group_types_to_show_label\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-sfflf\", \"--show-first-feature-label-for\",\n                        dest=\"feature_group_types_to_show_label_on_first_occurrence\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-ifl\", \"--ignored-feature-labels\", dest=\"feature_labels_to_ignore\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-hl\", \"--homology-links\", dest=\"homology-track\", action=\"store_true\")\n    parser.add_argument(\"-slt\", \"--scale-line-track\", dest=\"draw_scale_line_track\", action=\"store_true\",\n                        default=None)\n    parser.add_argument(\"-sxa\", \"--show-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_true\", default=None)\n    parser.add_argument(\"-hix\", \"--hide-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_false\", default=None)\n    parser.add_argument(\"-dml\", \"--draw-middle-line\", dest=\"draw_middle_line\", action=\"store_true\", default=None)\n    parser.add_argument(\"-mm-per-nt\", \"--mm-per-nt\", dest=\"mm_per_nt\", type=float, default=None)\n    parser.add_argument(\"-fw\", \"--figure-width\", dest=\"figure_width\", type=float, default=None)\n    parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n    parser.add_argument(\"--pdf-name\", dest=\"pdf-name\", type=str, default=\"lovis4u.pdf\")\n    parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"standard\")\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.0.9\")\n    parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n    parser.add_argument(\"--parsing-debug\", \"-parsing-debug\", dest=\"parsing_debug\", action=\"store_true\")\n    parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n    parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n    args = parser.parse_args()\n    args = vars(args)\n    if len(sys.argv[1:]) == 0:\n        args[\"help\"] = True\n    if args[\"lovis4u_data\"]:\n        lovis4u.Methods.copy_package_data()\n        sys.exit()\n    if args[\"linux\"]:\n        lovis4u.Methods.adjust_paths(\"linux\")\n        sys.exit()\n    if args[\"mac\"]:\n        lovis4u.Methods.adjust_paths(\"mac\")\n        sys.exit()\n    if args[\"help\"]:\n        help_message_path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"help.txt\")\n        with open(help_message_path, \"r\") as help_message:\n            print(help_message.read(), file=sys.stdout)\n            sys.exit()\n    if not args[\"gff\"] and not args[\"gb\"]:\n        raise lovis4u.Manager.lovis4uError(\"-gff or -gb parameter with folder path should be provided\")\n    args_to_keep = [\"locus-annotation\", \"feature-annotation\", \"gb\", \"gff\"]\n    filtered_args = {k: v for k, v in args.items() if v is not None or k in args_to_keep}\n    self.cmd_arguments = filtered_args\n    return None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader","title":"<code>ScaleLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A LocusLoader object prepares data for a Scale track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class ScaleLoader(Loader):\n    \"\"\"A LocusLoader object prepares data for a Scale track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a ScaleLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, layout: dict) -&gt; None:\n        \"\"\"Prepare ScaleLoader specific data.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            total_nt_width = self.layout[\"total_nt_width\"]\n            raw_scale_line_nt_width = round(total_nt_width * self.prms.args[\"scale_line_relative_size\"])\n            raw_scale_line_nt_width_pow = int(math.log(raw_scale_line_nt_width, 10))\n            scale_line_nt_width = round(raw_scale_line_nt_width // math.pow(10, raw_scale_line_nt_width_pow) *\n                                        math.pow(10, raw_scale_line_nt_width_pow))\n            track_data = dict()\n            self.track_data = track_data\n            track_data[\"scale_line_nt_width\"] = scale_line_nt_width\n            track_data[\"coordinates\"] = [self.layout[\"loci_tracks_left_border\"],\n                                         self.layout[\"loci_tracks_left_border\"] +\n                                         layout[\"width_per_nt\"] * scale_line_nt_width]\n            track_data[\"scale_line_width\"] = track_data[\"coordinates\"][1] - track_data[\"coordinates\"][0]\n            track_data[\"scale_label\"] = f\"{scale_line_nt_width} nt\"\n            track_data[\"scale_line_label_font_size\"] = self.prms.args[\"scale_line_label_font_size\"]\n            track_data[\"scale_line_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n                track_data[\"scale_line_label_font_size\"], self.prms.args[\"scale_line_label_font_face\"])\n            track_data[\"scale_line_label_width\"] = pdfmetrics.stringWidth(track_data[\"scale_label\"],\n                                                                          self.prms.args[\"scale_line_label_font_face\"],\n                                                                          track_data[\"scale_line_label_font_size\"])\n            if (track_data[\"scale_line_width\"] - track_data[\"scale_line_label_width\"]) / \\\n                    track_data[\"scale_line_width\"] &gt; 0.1:\n                track_data[\"style\"] = \"fancy\"\n                track_data[\"space_width\"] = pdfmetrics.stringWidth(\" \", self.prms.args[\"scale_line_label_font_face\"],\n                                                                   track_data[\"scale_line_label_font_size\"])\n            else:\n                track_data[\"style\"] = \"default\"\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare scale track specific data.\") from error\n\n    def calculate_track_height(self):\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            if self.track_data[\"style\"] == \"fancy\":\n                track_height = self.track_data[\"scale_line_label_height\"]\n            else:\n                track_height = (1.2 * self.prms.args[\"scale_line_tics_height\"] +\n                                self.track_data[\"scale_line_label_height\"])\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a scale track height.\") from error\n\n    def create_track(self):\n        \"\"\"Initialise a ScaleVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis: visualisation track.\n\n        \"\"\"\n        try:\n            return lovis4u.Drawing.ScaleVis(self.layout, self.track_data, self.prms)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a scale track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a ScaleLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a ScaleLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code>        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self):\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        if self.track_data[\"style\"] == \"fancy\":\n            track_height = self.track_data[\"scale_line_label_height\"]\n        else:\n            track_height = (1.2 * self.prms.args[\"scale_line_tics_height\"] +\n                            self.track_data[\"scale_line_label_height\"])\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a scale track height.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a ScaleVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a ScaleVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis: visualisation track.\n\n    \"\"\"\n    try:\n        return lovis4u.Drawing.ScaleVis(self.layout, self.track_data, self.prms)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a scale track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(layout)</code>","text":"<p>Prepare ScaleLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, layout: dict) -&gt; None:\n    \"\"\"Prepare ScaleLoader specific data.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        total_nt_width = self.layout[\"total_nt_width\"]\n        raw_scale_line_nt_width = round(total_nt_width * self.prms.args[\"scale_line_relative_size\"])\n        raw_scale_line_nt_width_pow = int(math.log(raw_scale_line_nt_width, 10))\n        scale_line_nt_width = round(raw_scale_line_nt_width // math.pow(10, raw_scale_line_nt_width_pow) *\n                                    math.pow(10, raw_scale_line_nt_width_pow))\n        track_data = dict()\n        self.track_data = track_data\n        track_data[\"scale_line_nt_width\"] = scale_line_nt_width\n        track_data[\"coordinates\"] = [self.layout[\"loci_tracks_left_border\"],\n                                     self.layout[\"loci_tracks_left_border\"] +\n                                     layout[\"width_per_nt\"] * scale_line_nt_width]\n        track_data[\"scale_line_width\"] = track_data[\"coordinates\"][1] - track_data[\"coordinates\"][0]\n        track_data[\"scale_label\"] = f\"{scale_line_nt_width} nt\"\n        track_data[\"scale_line_label_font_size\"] = self.prms.args[\"scale_line_label_font_size\"]\n        track_data[\"scale_line_label_height\"] = lovis4u.Methods.str_font_size_to_height(\n            track_data[\"scale_line_label_font_size\"], self.prms.args[\"scale_line_label_font_face\"])\n        track_data[\"scale_line_label_width\"] = pdfmetrics.stringWidth(track_data[\"scale_label\"],\n                                                                      self.prms.args[\"scale_line_label_font_face\"],\n                                                                      track_data[\"scale_line_label_font_size\"])\n        if (track_data[\"scale_line_width\"] - track_data[\"scale_line_label_width\"]) / \\\n                track_data[\"scale_line_width\"] &gt; 0.1:\n            track_data[\"style\"] = \"fancy\"\n            track_data[\"space_width\"] = pdfmetrics.stringWidth(\" \", self.prms.args[\"scale_line_label_font_face\"],\n                                                               track_data[\"scale_line_label_font_size\"])\n        else:\n            track_data[\"style\"] = \"default\"\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare scale track specific data.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.lovis4uError","title":"<code>lovis4uError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A class for exceptions parsing inherited from the Exception class.</p> Source code in <code>lovis4u/Manager.py</code> <pre><code>class lovis4uError(Exception):\n    \"\"\"A class for exceptions parsing inherited from the Exception class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_methods/","title":"Package methods","text":"<p>This module provides some methods (e.g. colors tranformation, data copying) used by the tool.</p>"},{"location":"API/package_methods/#lovis4u.Methods.adjust_paths","title":"<code>adjust_paths(to)</code>","text":"<p>Change paths in the internal config files for linux or mac.</p> <p>Parameters:</p> <ul> <li> <code>to</code>             (<code>str</code>)         \u2013          <p>mac | linux</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def adjust_paths(to: str) -&gt; None:\n    \"\"\"Change paths in the internal config files for linux or mac.\n\n    Arguments:\n        to (str): mac | linux\n\n    Returns:\n        None\n\n    \"\"\"\n    internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n    config_files = [\"standard.cfg\"]\n    for config_file in config_files:\n        config_file_path = os.path.join(internal_dir, config_file)\n        with open(config_file_path, \"r+\") as config:\n            if to == \"linux\":\n                if not os.path.exists(os.path.join(internal_dir, \"bin/mmseqs_linux\")):\n                    os.system(f\"unzip -q -d {os.path.join(internal_dir, 'bin/')} \"\n                              f\"{os.path.join(internal_dir, 'bin/mmseqs_linux.zip')}\")\n                config_txt = re.sub(r\"mmseqs_mac/bin/mmseqs\", \"mmseqs_linux/bin/mmseqs\", config.read())\n            else:\n                config_txt = re.sub(r\"mmseqs_linux/bin/mmseqs\", \"mmseqs_mac/bin/mmseqs\", config.read())\n            config.seek(0)\n            config.truncate()\n            config.write(config_txt)\n    print(f\"\u2699 mmseqs path was adjusted to {to}\")\n    return None\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.copy_package_data","title":"<code>copy_package_data()</code>","text":"<p>Copy the lovis4u package data folder to your current dir.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def copy_package_data() -&gt; None:\n    \"\"\"Copy the lovis4u package data folder to your current dir.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        users_dir = os.path.join(os.getcwd(), \"lovis4u_data\")\n        internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n        if os.path.exists(users_dir):\n            raise lovis4u.Manager.lovis4uError(\"lovis4u_data folder already exists.\")\n        shutil.copytree(internal_dir, users_dir, ignore=shutil.ignore_patterns(\"help*\", \".*\"))\n        print(\"\u2699 lovis4u_data folder was copied to the current working directory\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(f\"Unable to copy lovis4u folder in your working dir.\") from error\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.feature_nt_to_x_transform","title":"<code>feature_nt_to_x_transform(nt_start, nt_end, feature_strand, locus, layout)</code>","text":"<p>Transform feature coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>feature_strand</code>             (<code>int</code>)         \u2013          <p>1 | -1 corresponding to plus or minus strand, respectively.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def feature_nt_to_x_transform(nt_start: int, nt_end: int, feature_strand: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform feature coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        feature_strand (int): 1 | -1 corresponding to plus or minus strand, respectively.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    left_out, right_out = False, False\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] or coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if nt_start &lt; coordinate[\"start\"]:\n                if coordinate[\"strand\"] == 1:\n                    left_out = True\n                else:\n                    right_out = True\n                nt_start = coordinate[\"start\"]\n            if nt_end &gt; coordinate[\"end\"]:\n                if coordinate[\"strand\"] == 1:\n                    right_out = True\n                else:\n                    left_out = True\n                nt_end = coordinate[\"end\"]\n            x_coordinates = region_nt_to_x_transform(nt_start, nt_end, locus, layout)\n            x_coordinates[\"center\"] = (x_coordinates[\"start\"] + x_coordinates[\"end\"]) / 2\n            x_coordinates[\"orient\"] = feature_strand * coordinate[\"strand\"]\n            x_coordinates[\"lout\"] = left_out\n            x_coordinates[\"rout\"] = right_out\n            break\n    return x_coordinates\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.get_colour","title":"<code>get_colour(name, parameters)</code>","text":"<p>Get HEX colour by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a colour.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>HEX colour.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_colour(name: str, parameters: dict) -&gt; str:\n    \"\"\"Get HEX colour by its name\n\n    Arguments:\n        name (str): name of a colour.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        str: HEX colour.\n\n    \"\"\"\n    hex_c = parameters.args[\"palette\"][parameters.args[name]]\n    return hex_c\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.get_colour_rgba","title":"<code>get_colour_rgba(name, parameters)</code>","text":"<p>Get rgba colour by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a colour.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (            <code>tuple</code> )        \u2013          <p>RGBA colour</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_colour_rgba(name: str, parameters: dict) -&gt; tuple:\n    \"\"\"Get rgba colour by its name\n\n    Arguments:\n        name (str): name of a colour.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        tuple: RGBA colour\n\n    \"\"\"\n    return *matplotlib.colors.hex2color(get_colour(name, parameters)), parameters.args[f\"{name}_alpha\"]\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.nt_to_x_transform","title":"<code>nt_to_x_transform(nt, locus, layout, mode)</code>","text":"<p>Transform nucleotide coordinate to x page coordinate.</p> <p>Parameters:</p> <ul> <li> <code>nt</code>             (<code>int</code>)         \u2013          <p>Nucleotide coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> <li> <code>mode</code>             (<code>str</code>)         \u2013          <p>Mode whether coordinate should be centered to the nt or on the side.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>Corresponding page coordinate.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def nt_to_x_transform(nt: int, locus, layout: dict, mode: str) -&gt; float:\n    \"\"\"Transform nucleotide coordinate to x page coordinate.\n\n    Arguments:\n        nt (int): Nucleotide coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n        mode (str): Mode whether coordinate should be centered to the nt or on the side.\n\n    Returns:\n        float: Corresponding page coordinate.\n\n    \"\"\"\n    passed_x = layout[\"loci_tracks_left_border\"]\n    for c_i in range(len(locus.coordinates)):\n        coordinate = locus.coordinates[c_i]\n        coordinate_region_width = (coordinate[\"end\"] - coordinate[\"start\"] + 1) * layout[\"width_per_nt\"]\n        if coordinate[\"start\"] &lt;= nt &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == 1:\n                relative_nt = nt - coordinate[\"start\"]\n            else:\n                relative_nt = coordinate[\"end\"] - nt\n            if mode == \"start\":\n                pass\n            elif mode == \"center\":\n                relative_nt += 0.5\n            elif mode == \"end\":\n                relative_nt += 1\n            relative_x = relative_nt * layout[\"width_per_nt\"]\n            global_x = passed_x + relative_x\n            break\n        passed_x += coordinate_region_width + layout[\"x_gap_between_regions\"]\n        if c_i &lt; len(locus.coordinates) - 1:\n            if locus.circular:\n                if coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == 1:\n                    if coordinate[\"end\"] == locus.length and locus.coordinates[c_i + 1][\"start\"] == 1:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n                elif coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == -1:\n                    if coordinate[\"start\"] == 1 and locus.coordinates[c_i + 1][\"end\"] == locus.length:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n    return global_x\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.region_nt_to_x_transform","title":"<code>region_nt_to_x_transform(nt_start, nt_end, locus, layout)</code>","text":"<p>Transform region coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def region_nt_to_x_transform(nt_start: int, nt_end: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform region coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] and coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == -1:\n                nt_start, nt_end = nt_end, nt_start\n            x_start = nt_to_x_transform(nt_start, locus, layout, \"start\")\n            x_end = nt_to_x_transform(nt_end, locus, layout, \"end\")\n            break\n    return dict(start=x_start, end=x_end)\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.scale_lightness","title":"<code>scale_lightness(hex_c, scale_l)</code>","text":"<p>Helper function to get darker version of input colour</p> <p>Parameters:</p> <ul> <li> <code>hex_c</code>             (<code>str</code>)         \u2013          <p>input HEX colour</p> </li> <li> <code>scale_l</code>             (<code>float</code>)         \u2013          <p>scale of lightness</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>new HEX colour</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def scale_lightness(hex_c: str, scale_l: float) -&gt; str:\n    \"\"\"Helper function to get darker version of input colour\n\n    Arguments:\n        hex_c (str): input HEX colour\n        scale_l (float): scale of lightness\n\n    Returns:\n        str: new HEX colour\n\n    \"\"\"\n    rgb = matplotlib.colors.hex2color(hex_c)\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n    hex_c = matplotlib.colors.rgb2hex(colorsys.hls_to_rgb(h, min(1, l * scale_l), s=s))\n    return hex_c\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.str_font_size_to_height","title":"<code>str_font_size_to_height(font_size, font_type)</code>","text":"<p>Transform string font size to height.</p> <p>Parameters:</p> <ul> <li> <code>font_size</code>             (<code>float</code>)         \u2013          <p>font_size.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>height of the string.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def str_font_size_to_height(font_size: float, font_type: str) -&gt; float:\n    \"\"\"Transform string font size to height.\n\n    Arguments:\n        font_size (float): font_size.\n        font_type (str): font type (see config file; at this moment only regular is available).\n\n    Returns:\n        float:  height of the string.\n\n    \"\"\"\n\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    height = font_size * (face.ascent - face.descent) / (1000*1.38)\n    return height\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.str_height_to_size","title":"<code>str_height_to_size(height, font_type)</code>","text":"<p>Transform string height to the font size.</p> <p>Parameters:</p> <ul> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>available height of the string.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>font size defined by height.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def str_height_to_size(height: float, font_type: str) -&gt; float:\n    \"\"\"Transform string height to the font size.\n\n    Arguments:\n        height (float): available height of the string.\n        font_type (str): font type (see config file; at this moment only regular is available).\n\n    Returns:\n        float: font size defined by height.\n\n    \"\"\"\n\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    font_size = (1000 * 1.38 * height) / (face.ascent - face.descent)\n    return font_size\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.update_path_extension","title":"<code>update_path_extension(path, new_extension)</code>","text":"<p>Get path basename and replace its extension</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>path to a file</p> </li> <li> <code>new_extension</code>             (<code>str</code>)         \u2013          <p>new extension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>basename of a file with new extension.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def update_path_extension(path: str, new_extension: str) -&gt; str:\n    \"\"\"Get path basename and replace its extension\n\n    Arguments:\n        path (str): path to a file\n        new_extension (str): new extension\n\n    Returns:\n        str: basename of a file with new extension.\n\n    \"\"\"\n    updated_filename = f\"{os.path.splitext(os.path.basename(path))[0]}.{new_extension}\"\n    return updated_filename\n</code></pre>"},{"location":"API/usage_examples/","title":"Short example-drived guide to LoVis4u API","text":"<p>LoVis4u has a simple API allowing it programmatic usage from within a python program. Below we describe Python snippets that mimic results of command-line calls.</p> <p>See detailed description of each class and method in the \"Library\" section.</p> <pre><code>import lovis4u\n\n# Creating a parameters object and loading config\nparameters = lovis4u.Manager.Parameters()\nparameters.load_config(\"standard\")\n\n# Example of changing a particular parameter\nparameters.args[\"output_dir\"] = \"API_output_example\"\n\n# To turn off progress messages\nparameters.args[\"verbose\"] = False\n\n# Creating a loci object and loading gff files  \nloci = lovis4u.DataProcessing.Loci(parameters=parameters)\n\n# Loading locus and feature annotation tables (optional)\nloci.load_locus_annotation_file(\"file_path\")\nloci.load_feature_annotation_file(\"file_path\")\n\n# Loading folder with gff files (for ex. the example-driven guide)\ngff_folder = \"lovis4u_data/guide/gff_files\" \nloci.load_loci_from_extended_gff(gff_folder)\n\n# Running mmseqs on all encoded proteins and processing results\nmmseqs_clustering_results = loci.mmseqs_cluster()\nloci.define_features_groups(mmseqs_clustering_results)\n\n# Cluster loci (optional)\nloci.cluster_sequences(mmseqs_clustering_results)\n\n# Find variable protein groups (optional)\nloci.find_variable_feature_groups(mmseqs_clustering_results)\n\n# Reoirent loci (optional)\nloci.reorient_loci()\n\n# Set colours  (optional)\nloci.set_feature_colours_based_on_groups()\nloci.set_category_colours()\n\n# Defining labels to be shown (optional)\nloci.define_labels_to_be_shown()\n\n# Saving annotation tables (optional)\nloci.save_feature_annotation_table()\nloci.save_locus_annotation_table()\n\n# Visualisation steps\n# Creating a canvas manager object\ncanvas_manager = lovis4u.Manager.CanvasManager(parameters)\ncanvas_manager.define_layout(loci)\n\n# Adding tracks. The only mandatory: loci\ncanvas_manager.add_loci_tracks(loci)\n\n# We can add scale line on the bottom (optional)\ncanvas_manager.add_scale_line_track()\n\n# Category colours (optional)\ncanvas_manager.add_categories_colour_legend_track(loci)\n\n# And homology line track (optional)\ncanvas_manager.add_homology_track()\n\n# Finally, plotting results and saving the pdf file\ncanvas_manager.plot(filename=\"example.pdf\")\n</code></pre>"},{"location":"ExampleDrivenGuide/cmd_guide/","title":"Example-driven guide","text":"<p>Here we show usage examples of the lovis4u command-line interface. Through this guide we will show you step-by-step how to optimise your visualisation starting from default parameters.</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#before-start","title":"Before start","text":""},{"location":"ExampleDrivenGuide/cmd_guide/#data-preparation","title":"Data preparation","text":"<p>The necessary sample data as well as adjustable tool configuration files are provided by lovis4u at the post-install step with the command:   <code>lovis4u --data</code> This copies the lovis4u_data folder to your working directory.</p> <p>If you work on a Linux machine: after installation you should run: <code>lovis4u --linux</code> This command replaces the tool path (for MMseqs2) in the pre-made config files from the MacOS version (default) to the Linux version. If you run this command for fun and want to change it back you can use <code>lovis4u --mac</code>.</p> <p>For demonstration we will use pharokka generated gff files with the sequences of five Enterobacteria P2-like phages. Gff files are stored at: lovis4u_data/guide/gff_files.  The main difference between pharokka generated gff files and regular gff3 (for ex. which you can download from the NCBI) is that in addition to the annotation rows the annotation contains the corresponding nucleotide sequence in fasta format.</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#building-compatible-gff-files-based-on-nucleotide-sequences","title":"Building compatible gff files based on nucleotide sequences","text":"<p>If your query set of sequences for visualisation contains only nucleotide fasta files, below we will provide the efficient way of using pharokka (phage annotation pipeline) and prokka (prokaryotic genome annotation pipeline) for preparing gff files compatible with LoVis4u. </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#using-pharokka-for-annotation-of-phage-genomes","title":"Using pharokka for annotation of phage genomes","text":"<p>Before running pharokka you need to install pharokka databases (and pharokka itself, of course). Due to the number of non-python dependencies we recommend using a conda environment for this task. See pharokka documentation page for clear instructions.</p> <p>Firstly, you can merge multiple sequences into one fasta file (could be done simply by using cat: <code>cat folder_with_fasta_files/*.fa &gt; merged_fasta.fa</code>. We recommend to merge multiple sequences to one file and using meta mode since in that case we do not load databases for each contig while annotating. </p> <p>Then, you can use pharokka in meta mode with one command: <pre><code>pharokka.py -i merged_fasta.fa  -o pharokka_output  --meta --split -t Num_of_threads \\\n    --skip_mash --dnaapler  -database path_do_pharokka_database \n</code></pre></p> <p>Gff files for each query contig will be stored at: pharokka_output/single_gffs</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#using-prokka-for-annotation-of-prokaryotic-genomes","title":"Using prokka for annotation of prokaryotic genomes","text":"<p>Prokka does not have an equivalent of meta mode which we used in pharokka in the example above. Therefore, for any number of input sequences we prefer running prokka independently for each contig instead of dividing more complex gff files, which requires an additional step. Again, for prokka installation instruction and parameter description see  prokka documentation page.</p> <p>In case your input fasta query files (one sequence per file) are located in single_records folders you can run: <pre><code>for f in single_records/*.fa;  do fb=$(basename $f); nm=${fb//.fa/}; \\ \n    echo prokka --outdir prokka/$nm --prefix $nm --quiet --cpus 1 $f ; \\\n    done | parallel -j num_of_available_threads\n</code></pre> Then you can move generated gff files to one folder using: <pre><code>for f in prokka/*; do fb=$(basename $f); echo mv  $f/$fb.gff prokka_gffs/ ; done | parallel\n</code></pre></p>"},{"location":"ExampleDrivenGuide/cmd_guide/#configuration-files","title":"Configuration files","text":"<p>LoVis4u has a set of editable configuration files with parameters already adjusted for different tasks and page layout:</p> <ul> <li>A4p1 - adjusted for one-column portrait A4 page layout. Figure width - 90mm.</li> <li>A4p2 - adjusted for two-column portrait A4 page layout. Figure width - 190mm.</li> <li>A4L - adjusted for landscape A4 page layout. Figure width - 240mm.</li> <li>standard - flexible width length, scale - 0.05 mm per nucleotide with minimal width - 80mm. </li> </ul> A4 page layout examples <p>Corresponding PDF file </p> <p>By default, standard configuration file is used. You can change it simply by using <code>-c\\--config</code> parameter. For example, to use A4p2 config file use: <code>lovis4u [other arguments] -c A4p2</code>. Below you can find examples with sample data.</p> <p>If you want to edit some config parameters you can first download lovis4u_data folder (see above) to your working directory with <code>lovis4u --data</code> command. In the folder you can find all configuration files. You can then edit any parameters and its name there and specify path to it using the same <code>-c\\--config path_to_new_file.cfg</code> parameter. Even if you break something there, you can always download default config files again with the same <code>lovis4u --data</code> command.</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#example-run-with-default-parameters","title":"Example run with default parameters","text":"<p>Let's start with running lovis4u without using any optional arguments. The only mandatory argument is a folder path containing pharokka generated gff (<code>-gff</code>) files or genbank files (<code>-gb</code>).   </p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files\n</code></pre> <p>Running this command will create an output folder named lovis4u_{current_date} (e.g. lovis4u_2024_04_28-16_36) containing the results files. The name of the output folder can be changed with <code>-o &lt;output_folder_name&gt;</code>.</p> Output folder structure <ul> <li>lovis4u.pdf - vector graphic output (file name can be changed with <code>--pdf-name &lt;filename&gt;</code> parameter)  </li> <li>locus_annotation_table.tsv - table containing annotation (sequence_id, length, coordinates, etc.) for each locus.  </li> <li>feature_annotation_table.tsv - table containing annotation (feature_id, locus_id, coordinates, etc.) for each feature (e.g. CDS)  </li> <li>mmseqs (folder)  <ul> <li>DB - folder with MMseqs databases.  </li> <li>mmmseqs_clustering.tsv - table with proteomes clustering results.  </li> <li>mmmseqs_(stdout/stderr).txt - mmseqs logs.  </li> <li>input_proteins.fa - fasta file with all annotated protein sequences (input to mmseqs).  </li> </ul> </li> <li>proteome_similarity_matrix.tsv - pairwise proteome similarity scores indicating the fraction of shared proteins homologues.  </li> </ul> <p> </p> lovis4u data pre-processing steps <p>By default, lovis4u uses the following data pre-processing steps:  (For details see the Pipeline description page)</p> <ol> <li>The full length of each input sequence is taken for analysis (this can be adjusted using the locus annotation   table, see below).. </li> <li>All proteins annotated to be encoded on input sequences are used as input for MMseqs2 clustering (can be    deactivated with --mmseqs-off parameter). MMseqs2 arguments can be adjusted using config file. Proteins clustered   together are considered to be a set of homologues. Based these results, the \"group\" attribute of each CDS is set.</li> <li>Taking into account the information about the set of homologues from the previous step, lovis4u applies     similarity based hierarchical clustering of proteomes, which it uses to find the optimal order for visualisation and    sets the \"group\" attribute for each locus. The purpose is to group together only related proteomes (keeping the     average proteome set similarity &gt; ~80%). This step can be skipped with the <code>-cl-off, --clust_loci-off</code> parameter.</li> <li>Defining the feature attribute \"group_type\". This allows the use of parameters that refer to a particular set of    feature groups (e.g. set colour or show labels only for \"group_type\" = \"variable\"). By default it sets group_type   \"variable\" for CDS features that are found in less than 0.25 of loci within the locus group, and \"conserved\" for    proteins encoded in more than 0.75 of loci within a group. Others are \"intermediate\" </li> <li>Setting feature colour based on the feature \"group\" attribute (can be deactivated with -sgc-off or --set-group- colour-off). By default loVis4u sets distinct colours only for features with group_type \"variable\". You can change  this with -sgcf or --set-group-colour-for. For example, if you want to set colour only for features with group_type     \"conserved\", run <code>--set-group-colour-for conserved</code>. </li> <li>Defining labels to be shown. By default, lovis4u shows all labels for \"variable\" features and only the first    occurrence for \"conserved\" features. You can show all labels with <code>--show-all-feature-labels</code> or specify group types    for which all labels will be shown with <code>-sflf, --show-feature-label-for &lt;classes&gt;</code>. Additionally, by default lovis4u   ignores the following labels: hypothetical protein, unknown protein. The list of ignored labels can be set with <code>-  ifl, --ignored-feature-labels &lt;feature_label1 [feature_label2 ...]&gt;</code>. The list with this argument can be left empty     to not filter out labels by their name.</li> </ol>"},{"location":"ExampleDrivenGuide/cmd_guide/#useful-parameters-for-basic-runs","title":"Useful parameters for basic runs","text":"<p>The following parameters are particularly useful for basic runs:</p> <ul> <li><code>--reorient_loci</code> - Auto re-orient loci (set new strands) if they are not matched.  This function tries to maximise co-orientation of homologous features.</li> <li><code>-hl</code>, <code>--homology-links</code> - Draw homology link track (Sankey graph).</li> <li>`</li> <li><code>-o &lt;name&gt;</code> - Output dir name.  </li> <li><code>-c &lt;name&gt;</code> - Name of the configuration file.</li> <li><code>c</code> - Set category colour for features and plot category colour legend (Initially designed for pharokka generated gff files, see more detailed description below).</li> </ul> <p>While loci in our test set are already correctly orientated, let's add <code>-hl</code> parameter to draw homology line track and select configuration file for two-column A4 page layout with <code>-c A4p2</code> parameter. Output will be adjusted for publication figure (for instance, in terms of font sizes and figure width set as 190mm). In addition we will plot functional categories of CDSs with <code>--set-category-colour</code> parameter. </p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-category-colour -c A4p2 -o lovis4u_output \n</code></pre> </p> <p>Alternatively, we can select A4L configuration file adjusted for A4 page landscape layout:</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl --set-category-colour -c A4L -o lovis4u_output\n</code></pre> </p> <p>As you can see, the style is slightly different since more available space is expected and font size and object sizes adjusted for 240 mm width. For instance, we have individual x-axis for each track (which can be activated in any run with <code>-sxa</code>, <code>--show-x-axis</code> parameter). Also, position of sequence label is on the left, not in the bottom, which also can be easily changed with <code>-llp</code>, <code>--locus-label-position</code> parameter (e.g. <code>-llp left</code> or <code>-llp bottom</code>).</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#using-the-locus-annotation-table","title":"Using the locus annotation table","text":"<p>As mentioned above, the full length of each locus is taken for visualisation by default. However, you can also specify the sub-coordinates of multiple regions for each locus to be shown. The coordinates together with other information about each locus can be specified in the locus annotation table and used as input with  <code>-laf</code> or <code>--locus-annotation-file</code> parameter. </p> <p>Additionally, after each run lovis4u saves the locus_annotation_table.tsv with annotation parameters used in this particular run. If no table was specified by input then all annotation columns are set with default values.  </p> <p>Default table generated from previous runs:</p> sequence_id length coordinates circular description order group initial_order NC_005056.1 32684 1:32684:1 1 Escherichia phage Wphi 0 1 4 NC_049457.1 33807 1:33807:1 1 Escherichia phage vB_EcoM-12474III 1 1 2 NC_001895.1 33593 1:33593:1 1 Enterobacteria phage P2 2 1 1 NC_049461.1 31834 1:31834:1 1 Bacteriophage R18C 3 1 0 NC_028943.1 29237 1:29237:1 1 Escherichia phage pro483 4 1 3 <p>The locus annotation table can also be used as input for customising the regions and orientations of the sequences shown. After the default run we can take the output locus_annotation_table and edit the information we want to change. Important to note: it is possible to input a table containing only a subset of columns (only the sequence_id column is essential). For other columns or empty cells, lovis4u will set the default values.</p> <p>For example, let's use this table as input:</p> sequence_id coordinates order group NC_005056.1 18320:24320:1,31684:32684:1,1:9360:1 0 1 NC_049461.1 16745:22745:1,30834:31834:1,1:7016:1 1 1 NC_001895.1 18294:24294:1,32593:33593:1,1:8460:1 2 1 NC_049457.1 19308:25308:1,32807:33807:1,1:9474:1 3 1 NC_028943.1 14839:20839:1,28237:29237:1,1:6321:1 4 1 <p>Here we specified only the coordinates, order and group for each locus. Order and group are also specified and kept since it is logical to use clustering results defined during the full locus length run, and to turn off a new attempt to cluster sequences. This is done with the <code>-cl-off, --clust_loci-off</code> parameter. </p> <p>Format for coordinates specification: comma-separated list of start:end:strand. Start and end are in 1-based format, strand: 1 for plus strand and -1 for minus.</p> <p>The table can be found in the guide folder: lovis4u_data/guide/locus_annotation_table_demo_1.tsv</p> <p>Important to note: in order to define classes of proteins (\"conserved\" (core) or \"variable\" (accessory)) LoVis4u clusters encoded proteins using MMseqs2 as was described above. When the full length sequences are plotted it is obvious that all proteins are used. However, when you visualise only subsequences of contigs then you have two options: 1) cluster only proteins that are overlapped with the selected region; 2) cluster all proteins including those that are outside of selected regions. By default the second option is used in order to avoid a situation where an ORF is labelled \"variable\", when in reality it is encoded in each proteome, but outside of the coordinates shown. However, if you need to consider only proteins overlapped with visualisation window, you can force to cluster only them by using <code>-cl-owp</code>, <code>--cluster-only-window-proteins</code> or cluster_all_proteins config parameter setting its value as \"False\".</p> <p>Now we can run:  <pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl -o lovis4u_output \\\n    --locus-annotation-file lovis4u_data/guide/locus_annotation_table_demo_1.tsv -cl-off\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#using-the-feature-annotation-table","title":"Using the feature annotation table","text":"<p>Similarly to the locus annotation table, we can use the feature annotation table to adjust the feature visualisation parameters. Here, feature usually refers to an open reading frame, each of which has its own ID.  After each run, a feature_annotation_table.tsv file is saved in your output folder. Below you can see header of default table created with default parameter run.</p> feature_id locus_id coordinates feature_type name group group_type category fill_colour stroke_colour show_label NC_001895.1_CDS_0001 NC_001895.1 64:2286:1 CDS nicking at origin of replication NC_005056.1_CDS_0001 conserved \"DNA, RNA and nucleotide metabolism\" default default 0 NC_001895.1_CDS_0002 NC_001895.1 2283:2612:1 CDS hypothetical protein NC_005056.1_CDS_0002 intermediate unknown function default default 0 NC_001895.1_CDS_0003 NC_001895.1 2651:3412:-1 CDS hypothetical protein NC_001895.1_CDS_0003 variable unknown function #f165db default 0 NC_001895.1_CDS_0004 NC_001895.1 3587:5347:-1 CDS hypothetical protein NC_001895.1_CDS_0004 variable unknown function #95a134 default 0 NC_001895.1_CDS_0005 NC_001895.1 5347:5517:-1 CDS hypothetical protein NC_001895.1_CDS_0005 variable unknown function #9e9e34 default 0 <p>As with the locus annotation table, we can tweak the parameters and use this as input in subsequent runs.  This is done with the parameter <code>-faf, --feature-annotation-file</code>, a table that contains only the subset of annotation columns that are of interest. For example, you can specify a new label and colour for those particular coding sequences (CDS) that you are interested in.</p> feature_id name fill_colour show_label NC_001895.1_CDS_0001 Updated Name :) #e54e86 1 <p>This table can be found in the guide folder: lovis4u_data/guide/feature_annotation_table_one_row.tsv</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl -o lovis4u_output \\\n    --locus-annotation-file lovis4u_data/guide/locus_annotation_table_demo_1.tsv -cl-off \\\n    --feature-annotation-file lovis4u_data/guide/feature_annotation_table_one_row.tsv\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#other-lovis4u-features","title":"Other LoVis4u features","text":""},{"location":"ExampleDrivenGuide/cmd_guide/#category-colour-and-annotation","title":"Category colour and annotation","text":"<p>Using the parameter <code>--set-category-colour</code> you can use the functional category annotation column for features. The functional category is shown by coloured lines below each ORF. By default it was designed to parse the PHROGs category annotation for proteins and retrieve information about the category in the \"function\" qualifiers in Genbank or GFF files (qualifiers used can be changed in config file) that is part of default output with pharokka annotation. However, you can set the category for each CDS using the above feature annotation table and the \"category\" column. Additionally, you can set the colour codes for your categories using <code>--category-colour-table</code>. For categories that are not found in a table, a random colour will be set. By default, lovis4u uses a pre-made colour table which can be found in lovis4u_data/category_colours.tsv.</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-category-colour\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#individual-x-axis-and-locus-label-position","title":"Individual x-axis and locus label position","text":"<p>In most configuration files (except the A4L for A4 landscape layout) LoVis4u indicates coordinates for visualisation inline with locus label. However, if you prefer a locus label to be placed on the left side you can use the following parameter: <code>-llp left</code> or <code>--locus-label-position left</code>.  When left position for label is selected you can choose to draw individual x-axis line for each locus track using the parameter <code>-sxa</code>, <code>--show-x-axis</code>. For example: <pre><code>lovis4u -gff lovis4u_data/guide/gff_files -llp left -hl --show-x-axis\n</code></pre></p> <p> </p> <p>Alternatively, if you use, for instance, A4L configuration file for A4 landscape layout in which individual x-axis are shown by default you can change it. Using the parameter <code>--hide-x-axis</code> you can deactivate visualisation of the x-axis for each locus track and instead, if you wish, draw a scale line track below. This is done using with <code>-slt, --scale-line-track</code>. Similarly, you can change locus label position to the bottom with <code>-llp bottom</code> parameter.</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -c A4L -hl --hide-x-axis --scale-line-track -llp bottom\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#highlighting-conserved-genes-instead-of-variable","title":"Highlighting conserved genes instead of variable","text":"<p>For many analysis purposes (e.g. conserved neighbourhood visualisation), it is more useful to colourise conserved gene clusters instead of the variable genes. This can be easily switched in lovis4u using the <code>--set-group-colour-for</code> parameter. Te default is to colour by variable but using <code>--set-group-colour-for conserved</code> will change it to the opposite mode. Note that if you have other feature group set in your feature annotation table and you want to set auto-colourising for them as well, you can specify them in a space separated list with this argument (e.g. <code>--set-group-colour-for conserved your_group_1 your_group_2</code>).</p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-group-colour-for conserved\n</code></pre> <p> </p> <p>Note:By default, the colours for groups are randomly set for each group using the seaborn husl palette. In the config file you can change to a more intense hsl palette or change the desaturation parameter.</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#visualisation-of-a-single-sequence","title":"Visualisation of a single sequence","text":"<p>LoVis4u is able to visualise only one sequence. In that case no special parameters are required. However, if you want to highlight each protein group of homologues with a particular colour (protein sequences still will be clustered) you can use the following parameter: <code>--set-group-colour-for conserved</code> which will highlight conserved genes as in the example above (since if only one sequence is in input then all proteins there are considered as \"conserved\")</p> <pre><code>lovis4u -gff lovis4u_data/guide/single_gff_file -hl --set-category-colour -c A4p2 \\\n    --set-group-colour-for conserved\n</code></pre> <p> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#specifying-figure-width-and-more-compact-visualisation","title":"Specifying figure width and more compact visualisation.","text":"<p>For the \"standard\" configuration file Lovis4u tries to set an optimal figure width taking into account the nucleotide size of visualisation window. At the same time, LoVis4u has a set of adjusted configuration file with fixed figure width for one-, two-column, and landscape A4 page layout figures. However, in any case you still can adjust figure width if needed. You can do it in two ways: 1) Using the <code>--mm-per-nt &lt;float value&gt;</code> argument changing scale which defines given space for each nt cell on canvas. Default: 0.005.  2) With <code>-fw, --figure-width &lt;float value [mm]&gt;</code> parameter which defines the total output figure width in mm.  </p> <p>Here we demonstrate usage by plotting a compact visualisation of full loci together with <code>--show-first-feature-label-for</code> argument with an empty list, so not labelling the first occurrence of conserved genes. Note that most of the coloured, variable genes are not labeled in this figure as they are annotated as \u2018hypothetical protein\u2019, which LoVis4u ignores to make figures more compact and informative. You can deactivate ignoring of these labels by using <code>-ifl</code>, <code>--ignored-feature-labels</code> argument, similarly providing an empty list an argument. </p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl -o width_test --show-first-feature-label-for --figure-width 70\n</code></pre> </p>"},{"location":"FAQ/FAQ/","title":"FAQ","text":"<p>Q: Something weird is happening, e.g. program is crashing with my data. What should I do? A: Please add <code>--debug</code> to the command line (or <code>--parsing-debug</code> if some files were not read correctly) and post the details in Issues.</p> <p>Q: GenBank files \"was not read properly and skipped\". A: Firstly, use the <code>--parsing-debug</code> parameter. Old prokka version generated GenBank files with incorrect locus header which then cannot be read by biopython library properly. If it is the case, you will find \"ValueError: Did not recognise the LOCUS line layout:\" line in the traceback. In that case you can use GFF files that are produced by prokka in parallel, or update prokka which should solve the problem.</p>"},{"location":"Gallery/gallery/","title":"Gallery","text":"<p>Here we show usage examples of the LoVis4u command-line interface.  For description of parameters and modes shown on this page visit the Example-driven guide page. </p>"},{"location":"Gallery/gallery/#sample-data-configuration-files","title":"Sample data &amp; Configuration files","text":"<p>The necessary sample data as well as adjustable tool configuration files are provided by lovis4u at the post-install step with the command:   <code>lovis4u --data</code> This copies the lovis4u_data folder to your working directory.</p> <p>Also important to describe the set of editable configuration files with parameters already adjusted for different tasks and page layout:</p> <ul> <li>A4p1 - adjusted for one-column portrait A4 page layout. Figure width - 90mm.</li> <li>A4p2 - adjusted for two-column portrait A4 page layout. Figure width - 190mm.</li> <li>A4L - adjusted for landscape A4 page layout. Figure width - 240mm.</li> <li>standard - flexible width length, scale - 0.05 mm per nucleotide with minimal width - 80mm. </li> </ul> A4 page layout examples <p>Corresponding PDF file </p>"},{"location":"Gallery/gallery/#the-full-length-visualisation-of-loci","title":"The full-length visualisation of loci","text":""},{"location":"Gallery/gallery/#miltiple-sequences","title":"Miltiple sequences","text":"<p>Visualisation with homology lines and category colours. Figure size: two-column of A4 page publication layout [190mm].</p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-category-colour -c A4p2\n</code></pre> <p> </p> <p>Visualisation with homology lines and category colours. Figure. size: compact one-column A4 page visualisation without labelling of conserved proteins [90mm].</p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-category-colour \\\n    --show-first-feature-label-for  -c A4p1\n</code></pre> <p> </p>"},{"location":"Gallery/gallery/#one-sequence","title":"One sequence","text":"<p>Visualisation of a single sequence with highlighted protein groups of homologues by different colours. Figure size: two-column A4 page publication layout [190mm].</p> <pre><code>lovis4u -gff lovis4u_data/guide/single_gff_file -hl --set-category-colour -c A4p2 \\\n    --set-group-colour-for conserved\n</code></pre> <p> </p>"},{"location":"Gallery/gallery/#visualisation-of-user-defined-regions","title":"Visualisation of user-defined regions","text":"<p>Visualisation of user-defined regions, one region per locus. Figure size: one-column A4 page layout [90mm].</p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files -c A4p1 --locus-annotation-file lovis4u_data/guide/locus_annotation_table_demo_2.tsv \\ \n    -cl-off -hl --set-category-colour\n</code></pre> <p> </p> <p>Visualisation of user-defined regions, two regions per locus. Figure size: two-column of A4 page publication layout [190mm].</p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl -o lovis4u_output_m_loci  \\\n    --locus-annotation-file lovis4u_data/guide/locus_annotation_table_demo_1.tsv -cl-off -llp left  -slt\n</code></pre> <p> </p>"},{"location":"Parameters/cmd_parameters/","title":"\u0421ommand-line parameters","text":""},{"location":"Parameters/cmd_parameters/#post-install-steps","title":"Post-install steps","text":"<code>--data</code> Creates the 'lovis4u_data' folder in the current working directory.  The folder contains adjustable configuration files used by lovis4u  (e.g. config, palettes...) <code>--linux</code> Replaces the mmseqs path in the pre-made config file from the MacOS  version [default] to the Linux version. <code>--mac</code> Replaces the mmseqs path in the pre-made config file from the Linux"},{"location":"Parameters/cmd_parameters/#mandatory-arguments","title":"Mandatory arguments","text":"<code>-gff &lt;folder&gt;</code> Path to a folder containing extended gff files.  Each gff file should contain corresponding nucleotide sequence.  (designed to handle pharokka produced annotation files). <p>OR</p> <code>-gb &lt;folder&gt;</code> Path to a folder containing genbank files."},{"location":"Parameters/cmd_parameters/#optional-arguments-data-processing","title":"Optional arguments | Data processing","text":"<code>-laf, --locus-annotation-file &lt;file path&gt;</code> Path to the locus annotation table.  (See documentation for details) <code>-faf, --feature-annotation-file &lt;file path&gt;</code> Path to the feature annotation table.  (See documentation for details) <code>-mmseqs-off, --mmseqs-off</code> Deactivate mmseqs clustering of proteomes of loci. <code>-fv-off, --find-variable-off</code> Deactivate annotation of variable or conserved protein clusters. <code>-cl-off, --clust_loci-off</code> Deactivate defining locus order and using similarity based hierarchical clustering of proteomes. <code>-oc, --one-cluster</code> Consider all sequences to be members of one cluster but use clustering dendrogram to define the optimal order. <code>-reorient_loci, --reorient_loci</code> Auto re-orient loci (set new strands) if they are not matched.  (Function tries to maximise co-orientation of homologous features.)"},{"location":"Parameters/cmd_parameters/#optional-arguments-locus-visualisation","title":"Optional arguments | Locus visualisation","text":"<code>-sgc-off, --set-group-colour-off</code> Deactivate auto-setting of feature fill and stroke colours.  (Pre-set colours specified in feature annotation table will be kept.) <code>-sgcf, --set-group-colour-for &lt;feature_group1 [feature group2 ...]&gt;</code> Space-separated list of feature groups for which colours should be set.  [default: variable, labeled] <code>-scc, --set-category-colour</code> Set category colour for features and plot category colour legend. <code>-cct, --category-colour-table &lt;file path&gt;</code> Path to the table with colour code for categories.  Default table can be found in lovis4u_data folder. <code>-lls, --locus-label-style &lt;id|description|full&gt;</code> Locus label style based on input sequence annotation. <code>-safl, --show-all-feature-labels</code> Display all feature labels. <code>-sflf, --show-feature-label-for  &lt;feature_group1 [feature group2 ...]&gt;</code> Space-separated list of feature groups for which label should be shown.  [default: variable, labeled] <code>-sfflf, --show-first-feature-label-for &lt;feature_group1 [feature group2 ...]&gt;</code> Space-separated list of feature group types for which label will be displayed   only for the first occurrence of feature homologues group.  [default: shell/core] <code>-ifl, --ignored-feature-labels &lt;feature_label1 [feature_label2 ...]&gt;</code> Space-separated list of feature names for which label won't be shown.  [default: hypothetical protein, unknown protein] <code>-hix, --hide-x-axis</code> Do not plot individual x-axis for each locus track. <code>-dml, --draw-middle-line</code> Draw middle line for each locus. <code>-mm-per-nt, --mm-per-nt &lt;float value&gt;</code> Scale which defines given space for each nt cell on canvas.  [default: auto (0.0022 - 0.02, depending on window size)] <code>-fw, --figure-width &lt;float value&gt;</code> Output figure width in cm."},{"location":"Parameters/cmd_parameters/#optional-arguments-additional-tracks","title":"Optional arguments | Additional tracks","text":"<code>-hl, --homology-links</code> Draw homology link track. <code>-slt, --scale-line-track</code> Draw scale line track."},{"location":"Parameters/cmd_parameters/#optional-arguments-others","title":"Optional arguments | others","text":"<code>-o &lt;name&gt;</code> Output dir name. It will be created if it does not exist.  [default: lovis4u_{current_date}; e.g. uorf4u_2022_07_25-20_41] <code>--pdf-name &lt;name&gt;</code> Name of the output pdf file (will be saved in the output folder).  [default: lovis4u.pdf] <code>-c &lt;standard|&lt;file.cfg&gt;</code> Path to a configuration file or name of a premade config file  [default: standard]"},{"location":"Parameters/cmd_parameters/#miscellaneous-arguments","title":"Miscellaneous arguments","text":"<code>-h, --help</code> Show this help message and exit. <code>-v, --version</code> Show program version. <code>--debug</code> Provide detailed stack trace for debugging purposes. <code>-q, --quiet</code> Don't show progress messages."},{"location":"Parameters/config_parameters/","title":"Configuration file parameters","text":"<p>lovis4u configuration file allows detailed customization of the tool's parameters.</p> <p>Note: You can copy the lovis4u_data folder that contains the config files to your wiking directory with <code>lovis4u --data</code> command and safely edit and use them without affecting 'internal' config. If you want to use a copied config file, use <code>-c path_to_config</code>.</p>"},{"location":"Parameters/config_parameters/#description-is-under-construction","title":"Description is under construction...","text":"<p>;[Data Processing] default_transl_table = 11 gff_description_source = description gff_CDS_name_source = product  gff_CDS_category_source = function genbank_id_source = protein_id genbank_id_alternative_source = ID,id,PROTEIN_ID genbank_description_source = annotations:organism genbank_CDS_name_source = product genbank_CDS_category_source = function CDS_is_variable_cutoff = 0.25 keep_predefined_groups = True keep_predefined_colors = True  </p> <p>;[mmseqs parameters] mmseqs_cluster_mode = 0 mmseqs_cov_mode = 0 mmseqs_min_seq_id = 0.35 mmseqs_c = 0.8   mmseqs_s = 6.5  </p> <p>;[Paths] palette = {internal}/palette.txt mmseqs_binary = {internal}/bin/mmseqs_mac/bin/mmseqs   category_colors = {internal}/category_colors.tsv font_italic = {internal}/fonts/Lato-Italic.ttf font_light = {internal}/fonts/Lato-Light.ttf font_light_italic = {internal}/fonts/Lato-LightItalic.ttf font_regular = {internal}/fonts/Lato-Regular.ttf font_bold = {internal}/fonts/Lato-Bold.ttf font_mono = {internal}/fonts/RobotoMono-Regular.ttf  </p> <p>;[Output] verbose = True debug = False output_dir = lovis4u_{current_date}  </p> <p>;[General figure parameters] margin = 0.1 gap = 0.1 mm_per_nt = auto figure_width = None  </p> <p>;[Locus track primary settings] locus_label_style = full locus_label_description_font_face = italic locus_label_id_font_face = regular draw_individual_x_axis = True draw_middle_line = False feature_default_fill_color = fancy_grey feature_default_stroke_color = grey set_feature_stroke_color_based_on_fill_color = True feature_stroke_color_relative_lightness = 0.4 feature_group_types_to_set_color = variable,labeled groups_fill_color_palette_lib = seaborn groups_fill_color_seaborn_palette = husl groups_fill_color_seaborn_desat = 0.95 feature_labels_to_ignore = hypothetical protein, unknown protein feature_group_types_to_show_label = variable,labeled feature_group_types_to_show_label_on_first_occurrence = shell/core show_all_feature_labels = False category_color_seaborn_palette = hls category_color_seaborn_desat = 0.9  </p> <p>;[Locus track advanced settings] feature_height = 0.3 feature_stroke_width = 0.3 feature_arrow_length = 0.6 feature_bottom_gap = 0.04 locus_label_size = 0.7 locus_label_color = black locus_label_color_alpha = 1 gap_after_locus_label = 0.1 x_axis_ticks_height = 0.07 x_axis_ticks_labels_height = 0.1 x_axis_ticks_labels_font_face = light x_axis_line_width = 0.3 x_axis_line_color = black x_axis_line_color_alpha = 1 category_annotation_alpha = 1 category_annotation_line_width = 0.07 groups_fill_colors_pastel_factor = 0.4 feature_stroke_color_alpha = 1 feature_fill_color_alpha = 0.7 groups_stroke_colors_alpha = 1 feature_label_size = 0.5 feature_label_gap = 0.5 feature_label_font_face = regular gap_between_regions = 0.5  </p> <p>;[Homology_track] homology_fill_color = lightgrey homology_fill_color_alpha = 1 homology_line_width = 0.1 homology_stroke_color = grey homology_stroke_color_alpha = 0  </p> <p>;[Scale line track] scale_line_relative_size = 0.3 scale_line_width = 0.3 scale_line_tics_height = 0.05 scale_line_color = black scale_line_color_alpha = 1 scale_line_label_height = 0.13 scale_line_label_font_face = regular  </p> <p>;[Category color legend] color_legend_label_size = 0.15 color_legend_line_height = 0.07 color_legend_font_face = regular color_legend_label_color = black color_legend_label_color_alpha = 1  </p>"},{"location":"Pipeline/pipeline/","title":"Pipeline description","text":"<p>Here we describe in details each step of the LoVis4u workflow, which schematically is shown on the Figure 1. For description of generated files, visualisation, and frequently used parameters, see the Example-driven guide page.   </p>"},{"location":"Pipeline/pipeline/#defining-groups-of-protein-homologues-and-proteome-filtering","title":"Defining groups of protein homologues and proteome filtering","text":"<p>The first step is reading input data in gff or genbank formats. While reading the files, we store all encoded protein sequences in a fasta file, which will be used as input for MMseqs clustering. </p> <p>After gff files are read, we use the MMseqs2 clustering pipeline with all encoded proteins as input. All the clustering parameters can be adjusted using the configuration file. By default, we use the following parameters: <code>--cluster mode 0 --cov-mode 0 --min-seq-id 0.25 -c 0.8 -s 7</code> (see mmseqs documentation for a detailed description).</p> <p>We then treat each cluster of proteins as a group of homologues. For each group we set the identifier (id) attribute as the id of the representative protein for the cluster.</p> <p>While processing the MMseqs results we iterate over all proteomes and all encoded proteins of each proteome, setting the attribute \u201dgroup\u201d for each CDS as id of cluster it belongs to. </p>"},{"location":"Pipeline/pipeline/#hierarchical-clustering-of-proteomes","title":"Hierarchical clustering of proteomes","text":"<p>The second major step is ordering and clustering of proteomes. Firstly we build the matrix of proteome similarity. For each pair of proteomes, say \\(i^{th}\\) and \\(j^{th}\\) proteomes we have weight \\(w_{ij}:\\) $$ w_{ij} = (\\frac{\\vert G_i \\cap G_j \\vert}{\\vert G_i \\vert} + \\frac{\\vert G_i \\cap G_j|}{|G_j|})\\cdot\\frac{1}{2} = \\frac{|G_i \\cap G_j|\\cdot(|G_i|+|G_j|)}{2|G_i||G_j|}; \\,\\, w_{ij}\\in[0,1]; \\, \\, w_{ij} = w_{ji} \\,\\, \\forall\\,i,j $$  where \\(|G_i|\\), \\(|G_j|\\) are lengths (number of unique elements) of the sets of protein groups of \\(i^{th}\\) and \\(j^{th}\\) proteomes, respectively. \\(|G_i \\cap G_j|\\) is the number of shared (overlapped) protein groups between \\(i^{th}\\) and \\(j^{th}\\) proteomes. The meaning of \\(w_{ij}\\) is average value of two fractions: the first \\(|G_i \\cap G_j|/|G_i|\\) is the number of shared homologues normalised to the length of \\(i^{th}\\) proteome set of protein groups, and the second \\(|G_i \\cap G_j|/|G_j|\\) - the same number of shared homologues with normalisation to the \\(j^{th}\\) proteome. The average of the two normalisations gives the required symmetric property with respect to its indexes. That is, \\(w_{ij}\\) is a metric of similarity of two genomes in terms of their proteome composition.</p> <p>Then, for each pair of proteomes we calculate the pairwise distance value which is simply defined as: \\(d_{ij} = 1 - w_{ij}\\). The matrix of distances is used then for hierarchical clustering using scipy library. The order of sequences for visualisation is defined by obtained dendrogram. Additionally, to define clusters of input sequences we use average linkage method and height cutoff which is set by default as 0.35. If you want to define the optimal order but consider all sequences to be member of one cluster, you can use <code>--one-cluster</code> optional argument. We treat each proteome cluster as a group of relatively more closely related proteomes, which we can use for our subsequent analyses.</p>"},{"location":"Pipeline/pipeline/#defining-protein-group-classes","title":"Defining protein group classes","text":"<p>Within each proteome cluster we can find homologous protein groups that are encoded in different fractions of the proteomes. Those that are found in the majority of proteomes we call \u201cconserved\u201d (equivalent to \u201ccore\u201d in pan-genome analyses). Those protein groups that are found in a relatively small fraction of proteomes then we call \u201cvariable\u201d (equivalent to \u201ccloud\u201d in pan-genome analyses). Finally, those protein groups that are neither very variable nor very conserved, we refer to as \u201cintermediate\u201d  (\u201cshell\u201d in pan-genome analyses).</p> <p>For each protein group \\(g_i\\) within a proteome cluster \\(c\\) that consists of \\(N_c\\) proteomes, we the define protein group presence fraction as \\(f_i =  N_c^{g_i}/N_c\\), where \\(N_c^{g_i}\\) is the number of proteomes of \\(c\\) community that contain the \\(g_i\\) protein group. if \\(f_i \\leq 0.25\\) \\(g_i\\) group class is set as \"variable\", if $ 0.25 &lt; f_i &lt; 0.75$ then \\(g_i\\) is \"intermediate\", and, if $ f_i \\geq 0.75 $ we say that \\(g_i\\) is \"conserved\". </p>"},{"location":"Pipeline/pipeline/#feature-and-locus-annotation-tables","title":"Feature and Locus annotation tables","text":"<p>The results of sequence clustering and information about proteins are saved as feature and locus annotation tables. They also cal be used as input if you have pre-defined values. See the example-driven guide for the details.</p>"},{"location":"VersionLog/versions/","title":"Version log","text":"<ul> <li> <p>Ver 0.0.9 - 27 September 2024 </p> <ul> <li>Set of new configuration files and styles for layouts of A4 page (one-,two-columns, and landscape)</li> <li>New design and locus label positions.</li> <li>New config and cmd parameters.</li> <li>Update of the home page with new uiser guide and the gallery page.</li> </ul> </li> <li> <p>Ver 0.0.8 - 18 September 2024 </p> <ul> <li>Suffix requirments for input files are removed.</li> <li>Subset of files with incorrect format will not lead to the error, only to the warning message.</li> </ul> </li> <li> <p>Ver 0.0.7 - 4 September 2024 </p> <ul> <li>Minor API update. </li> <li><code>--one-cluster</code> parameter is added.</li> </ul> </li> <li> <p>Ver 0.0.6 - 2 July 2024 </p> <ul> <li>Update of parameter names.</li> </ul> </li> <li> <p>Ver 0.0.5 - 27 June 2024 </p> <ul> <li>Minor fixes.</li> </ul> </li> <li> <p>Ver 0.0.4 - 13 June 2024 </p> <ul> <li>Minor fixes.</li> </ul> </li> <li> <p>Ver 0.0.3 - 3 May 2024 - first public release. </p> </li> </ul>"}]}