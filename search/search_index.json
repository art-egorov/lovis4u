{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["trimmer","stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#description","title":"Description","text":"<p>LoVis4u is a bioinformatics tool for Loci Visualisation.</p> <p>Supported input: Genbank, gff3 with sequence   Supported output: Static vector graphics (pdf)  Programming language: Python3  OS: MacOS, Linux Python dependencies: biopython, bcbio-gff, scipy, configs, argparse, pandas, distinctipy, matplotlib, seaborn, reportlab Python version: &gt;= 3.9 OS-level dependencies: MMseqs2 (included in the package) License: WTFPL Version: 0.0.3 (May 2024)</p> <p>Pipeline: </p> <p>Visualisation example: </p>"},{"location":"#installation","title":"Installation","text":"<ul> <li>The most stable release of lovis4u can be installed directly from pypi:</li> </ul> <pre><code>python3 -m pip install lovis4u\n</code></pre> <ul> <li>The development version is available at github :</li> </ul> <pre><code>git clone https://github.com/art-egorov/lovis4u.git\ncd lovis4u\npython3 -m pip install --upgrade pip\npython3 -m pip install setuptools wheel\npython3 setup.py sdist\npython3 -m pip install -e .\n</code></pre> <p>! If you're a linux user, run <code>lovis4u --linux</code> post-install command once to update paths in the premade config files that set by default for MacOS users.</p>"},{"location":"#reference","title":"Reference","text":"<p>If you find lovis4u useful, please cite: Artyom. A. Egorov, Gemma C. Atkinson, lovis4u: ..., ...</p>"},{"location":"#contact","title":"Contact","text":"<p>Please contact us by e-mail artemdotegorovATmeddotludotse or use Issues to report any technical problems. You can also use Discussions section for sharing your ideas or feature requests! </p>"},{"location":"#authors","title":"Authors","text":"<p>LoVis4u is developed by Artyom Egorov at the Atkinson Lab, Department of Experimental Medical Science, Lund University, Sweden \ud83c\uddf8\ud83c\uddea. We are open for suggestions to extend and improve LoVis4u functionality. Please don't hesitate to share your ideas or feature requests.</p>"},{"location":"API/package_data_processing/","title":"lovis4u.DataProcessing","text":"<p>This module provides managing classes and methods for the tool.</p>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Feature","title":"<code>Feature</code>","text":"<p>A Feature object represents a locus' feature (currently only CDS) and its properties.</p> <p>Attributes:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>feature_type</code>             (<code>str</code>)         \u2013          <p>Type of element (e.g. CDS or tRNA). Currently only CDS are supported.</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>1-based start genomic coordinate.</p> </li> <li> <code>end</code>             (<code>int</code>)         \u2013          <p>1-based end genomic coordinates</p> </li> <li> <code>strand</code>             (<code>int</code>)         \u2013          <p>Genomic strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the feature which will be used as a label.</p> </li> <li> <code>sequence</code>             (<code>Seq</code>)         \u2013          <p>Feature's sequence.</p> </li> <li> <code>record</code>             (<code>SeqRecord</code>)         \u2013          <p>SeqRecord object of corresponding feature sequence.</p> </li> <li> <code>group</code>             (<code>str</code>)         \u2013          <p>Feature group that defines feature's color and meant to represent a set of homologous features. Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.</p> </li> <li> <code>group_type</code>             (<code>str</code>)         \u2013          <p>Type of feature group that allow to visualise different set of feature groups differently (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature category which initially is built to handle phrogs category annotation. In visualisation it defines the \"category\" color annotation under features. Supposed to represent clusters on locus or any second layer of feature properties.</p> </li> <li> <code>vis_prms</code>             (<code>dict</code>)         \u2013          <p>Visualisation parameters that holds colors, label and other info for Drawing methods.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Feature:\n    \"\"\"A Feature object represents a locus' feature (currently only CDS) and its properties.\n\n    Attributes:\n        feature_id (str): Feature identifier.\n        feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n        start (int): 1-based start genomic coordinate.\n        end (int): 1-based end genomic coordinates\n        strand (int): Genomic strand (1: plus strand, -1: minus strand).\n        name (str): Name of the feature which will be used as a label.\n        sequence (Bio.Seq.Seq): Feature's sequence.\n        record (Bio.SeqRecord.SeqRecord): SeqRecord object of corresponding feature sequence.\n        group (str): Feature group that defines feature's color and meant to represent a set of homologous features.\n            Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n        group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n            (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n        category (str): Feature category which initially is built to handle phrogs category annotation.\n            In visualisation it defines the \"category\" color annotation under features.\n            Supposed to represent clusters on locus or any second layer of feature properties.\n        vis_prms (dict): Visualisation parameters that holds colors, label and other info for Drawing methods.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, feature_id: str, feature_type: str, start: int, end: int, strand: int, name: str,\n                 sequence: Bio.Seq.Seq, group: str, group_type: str, category: str, vis_prms: dict,\n                 parameters: lovis4u.Manager.Parameters):\n        \"\"\"Create a Feature object.\n\n        Arguments:\n            feature_id (str): Feature identifier.\n            feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n            start (int): 1-based start genomic coordinate.\n            end (int): 1-based end genomic coordinates\n            strand (int): Genomic strand (1: plus strand, -1: minus strand).\n            name (str): Name of the feature which will be used as a label.\n            sequence (Bio.Seq.Seq): Feature's sequence.\n            group (str): Feature group that defines feature's color and meant to represent a set of homologous features.\n                Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n            group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n                (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n            category (str): Feature category which initially is built to handle phrogs category annotation.\n                In visualisation it defines the \"category\" color annotation under features.\n                Supposed to represent clusters on locus or any second layer of feature properties.\n            vis_prms (dict): Visualisation parameters that holds colors, label and other info for Drawing methods.\n            prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.feature_type = feature_type\n        self.feature_id = feature_id\n        self.start = start\n        self.end = end\n        self.strand = strand\n        self.name = name\n        self.sequence = sequence\n        self.record = Bio.SeqRecord.SeqRecord(seq=self.sequence, id=self.feature_id)\n        self.group = group  # maybe rename later\n        self.group_type = group_type\n        self.category = category\n        self.vis_prms = vis_prms\n        self.vis_prms[\"label\"] = name\n        self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Feature.__init__","title":"<code>__init__(feature_id, feature_type, start, end, strand, name, sequence, group, group_type, category, vis_prms, parameters)</code>","text":"<p>Create a Feature object.</p> <p>Parameters:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>feature_type</code>             (<code>str</code>)         \u2013          <p>Type of element (e.g. CDS or tRNA). Currently only CDS are supported.</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>1-based start genomic coordinate.</p> </li> <li> <code>end</code>             (<code>int</code>)         \u2013          <p>1-based end genomic coordinates</p> </li> <li> <code>strand</code>             (<code>int</code>)         \u2013          <p>Genomic strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the feature which will be used as a label.</p> </li> <li> <code>sequence</code>             (<code>Seq</code>)         \u2013          <p>Feature's sequence.</p> </li> <li> <code>group</code>             (<code>str</code>)         \u2013          <p>Feature group that defines feature's color and meant to represent a set of homologous features. Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.</p> </li> <li> <code>group_type</code>             (<code>str</code>)         \u2013          <p>Type of feature group that allow to visualise different set of feature groups differently (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature category which initially is built to handle phrogs category annotation. In visualisation it defines the \"category\" color annotation under features. Supposed to represent clusters on locus or any second layer of feature properties.</p> </li> <li> <code>vis_prms</code>             (<code>dict</code>)         \u2013          <p>Visualisation parameters that holds colors, label and other info for Drawing methods.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, feature_id: str, feature_type: str, start: int, end: int, strand: int, name: str,\n             sequence: Bio.Seq.Seq, group: str, group_type: str, category: str, vis_prms: dict,\n             parameters: lovis4u.Manager.Parameters):\n    \"\"\"Create a Feature object.\n\n    Arguments:\n        feature_id (str): Feature identifier.\n        feature_type (str): Type of element (e.g. CDS or tRNA). Currently only CDS are supported.\n        start (int): 1-based start genomic coordinate.\n        end (int): 1-based end genomic coordinates\n        strand (int): Genomic strand (1: plus strand, -1: minus strand).\n        name (str): Name of the feature which will be used as a label.\n        sequence (Bio.Seq.Seq): Feature's sequence.\n        group (str): Feature group that defines feature's color and meant to represent a set of homologous features.\n            Can be set with Loci.mmseqs_cluster() method that uses mmseqs clustering to define CDS feature groups.\n        group_type (str): Type of feature group that allow to visualise different set of feature groups differently\n            (e.g. plot labels only for features which group_type is \"variable\" or \"labeled\").\n        category (str): Feature category which initially is built to handle phrogs category annotation.\n            In visualisation it defines the \"category\" color annotation under features.\n            Supposed to represent clusters on locus or any second layer of feature properties.\n        vis_prms (dict): Visualisation parameters that holds colors, label and other info for Drawing methods.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.feature_type = feature_type\n    self.feature_id = feature_id\n    self.start = start\n    self.end = end\n    self.strand = strand\n    self.name = name\n    self.sequence = sequence\n    self.record = Bio.SeqRecord.SeqRecord(seq=self.sequence, id=self.feature_id)\n    self.group = group  # maybe rename later\n    self.group_type = group_type\n    self.category = category\n    self.vis_prms = vis_prms\n    self.vis_prms[\"label\"] = name\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci","title":"<code>Loci</code>","text":"<p>A Loci object holds information about all loci to be plotted and methods for data preparation.</p> <p>Attributes:</p> <ul> <li> <code>loci</code>             (<code>list</code>)         \u2013          <p>List of Locus objects.</p> </li> <li> <code>loci_annotation</code>             (<code>DataFrame</code>)         \u2013          <p>Table with information about each locus that defines visualisation (e.g. coordinates for visualisation, description, etc).</p> </li> <li> <code>feature_annotation</code>             (<code>DataFrame</code>)         \u2013          <p>Table with information about each feature that defines visualisation (e.g. group, name, category, etc).</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Loci:\n    \"\"\"A Loci object holds information about all loci to be plotted and methods for data preparation.\n\n    Attributes:\n        loci (list): List of Locus objects.\n        loci_annotation (pd.DataFrame): Table with information about each locus that defines visualisation\n            (e.g. coordinates for visualisation, description, etc).\n        feature_annotation (pd.DataFrame): Table with information about each feature that defines visualisation\n            (e.g. group, name, category, etc).\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, parameters=lovis4u.Manager.Parameters):\n        \"\"\"Create a Loci object.\n\n        Arguments:\n            parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n        \"\"\"\n        self.loci = []\n        self.loci_annotation = pd.DataFrame(columns=[\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\",\n                                                     \"order\", \"group\"]).set_index(\"sequence_id\")\n        self.feature_annotation = pd.DataFrame(columns=[\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\",\n                                                        \"group\", \"group_type\", \"category\", \"fill_color\", \"stroke_color\",\n                                                        \"show_label\"]).set_index(\"feature_id\")\n        self.prms = parameters\n\n    def __load_annotation_file(self, file_path: str, annotation_columns: list, index_column: str) -&gt; pd.DataFrame:\n        \"\"\"Private method to load an annotation file.\n\n        Arguments:\n            file_path (str): File path for an annotation file to be loaded.\n            annotation_columns (list): List of columns that should be considered.\n            index_column (str): Column name to be considered as index.\n\n        Returns:\n              pd.DataFrame: Preprocessed annotation file.\n        \"\"\"\n        annotation_table = pd.read_table(file_path)\n        found_allowed_columns = [i for i in annotation_columns if i in annotation_table.columns]\n        not_found_allowed_columns = [i for i in annotation_columns if i not in annotation_table.columns]\n        annotation_table = annotation_table[found_allowed_columns].set_index(index_column)\n        annotation_table[not_found_allowed_columns] = None\n        return annotation_table\n\n    def load_loci_annotation_file(self, file_path: str) -&gt; None:\n        \"\"\"Load loci annotation file.\n\n        Arguments:\n            file_path (str): File path for a loci annotation file to be loaded.\n\n        Returns:\n            None\n\n        \"\"\"\n        annotation_columns = [\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\", \"order\", \"group\"]\n        self.loci_annotation = self.__load_annotation_file(file_path, annotation_columns, \"sequence_id\")\n        return None\n\n    def load_features_annotation_file(self, file_path: str) -&gt; None:\n        \"\"\"Load features annotation file.\n\n        Arguments:\n            file_path (str): File path for a features annotation file to be loaded.\n\n        Returns:\n            None\n\n        \"\"\"\n        annotation_columns = [\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\", \"group\", \"group_type\",\n                              \"category\", \"fill_color\", \"stroke_color\", \"show_label\"]\n        self.feature_annotation = self.__load_annotation_file(file_path, annotation_columns, \"feature_id\")\n        return None\n\n    def __update_loci_annotation(self, record_id: str, record_description: str, record_length: int) -&gt; None:\n        \"\"\"Private method for updating loci annotation.\n\n        Arguments:\n            record_id (str): Sequence identifier.\n            record_description (str): Sequence description.\n            record_length (int): Sequence length.\n\n        Returns:\n            None\n\n        \"\"\"\n        if record_id not in self.loci_annotation.index:\n            self.loci_annotation.loc[record_id] = {col: None for col in self.loci_annotation.columns}\n\n        default_values = dict(length=record_length, coordinates=f\"1:{record_length}:1\",\n                              description=record_description, circular=1, order=len(self.loci), group=1)\n        self.loci_annotation.loc[record_id] = self.loci_annotation.loc[record_id].fillna(default_values)\n        return None\n\n    def __update_feature_annotation(self, feature_id: str, locus_id: str, coordinates: str, feature_type: str,\n                                    category: str, name: str) -&gt; None:\n        \"\"\"Private method for updating feature annotation.\n\n        Arguments:\n            feature_id (str): Feature identifier.\n            locus_id (str): Sequence description.\n            coordinates (str): Feature coordinates.\n            category (str): Feature type.\n            name (str): Feature name.\n\n\n        Returns:\n            None\n\n        \"\"\"\n        if feature_id not in self.feature_annotation.index:\n            self.feature_annotation.loc[feature_id] = {col: None for col in self.feature_annotation.columns}\n\n        if self.feature_annotation.loc[feature_id][\"group_type\"] in self.prms.args[\"feature_group_types_to_show_label\"] \\\n                or \"all\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n            show_label = 1\n        else:\n            show_label = 0\n        stroke_color = \"default\"\n        if self.prms.args[\"set_feature_stroke_color_based_on_fill_color\"] and \\\n                self.feature_annotation.loc[feature_id][\"fill_color\"] and \\\n                self.feature_annotation.loc[feature_id][\"fill_color\"] != \"default\":\n            stroke_color = lovis4u.Methods.scale_lightness(self.feature_annotation.loc[feature_id][\"fill_color\"],\n                                                           self.prms.args[\"feature_stroke_color_relative_lightness\"])\n        default_values = dict(locus_id=locus_id, coordinates=coordinates, feature_type=feature_type,\n                              name=name, group=\"\", group_type=\"\", category=category, fill_color=\"default\",\n                              stroke_color=stroke_color,\n                              show_label=show_label)\n        self.feature_annotation.loc[feature_id] = self.feature_annotation.loc[feature_id].fillna(default_values)\n        return None\n\n    def load_loci_from_extended_gff(self, input_folder: str) -&gt; None:\n        \"\"\"Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide\n            sequence. Such files are produced for example by pharokka annotation tool.\n\n        All files with extension other than .gff (not case-sensitive) will be ignored.\n\n        Arguments:\n            input_folder: folder name with gff files.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not os.path.exists(input_folder):\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n        try:\n            gff_files = [f for f in os.listdir(input_folder) if os.path.splitext(f)[-1].lower() == \".gff\"]\n            if not gff_files:\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain .gff(.GFF) files.\")\n            for gff_file in gff_files:\n                gff_file_path = os.path.join(input_folder, gff_file)\n                gff_records = list(BCBio.GFF.parse(gff_file_path, limit_info=dict(gff_type=[\"CDS\"])))\n                if len(gff_records) != 1:\n                    raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} does not contain information for only\"\n                                                       f\" 1 sequence.\")\n                gff_record = gff_records[0]\n                try:\n                    record_locus_sequence = gff_record.seq\n                except Bio.Seq.UndefinedSequenceError as error:\n                    raise lovis4u.Manager.lovis4uError(f\"gff file doesn't contain corresponding sequences.\") from error\n                if self.prms.args[\"gff_description_source\"] in gff_record.annotations:\n                    record_description = gff_record.annotations[self.prms.args[\"gff_description_source\"]][0]\n                    if isinstance(record_description, tuple):\n                        record_description = \" \".join(record_description)\n                else:\n                    record_description = \"\"\n\n                self.__update_loci_annotation(gff_record.id, record_description, len(record_locus_sequence))\n                locus_annotation_row = self.loci_annotation.loc[gff_record.id]\n                coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                               locus_annotation_row[\"coordinates\"].split(\",\")]\n                record_locus = Locus(seq_id=gff_record.id, coordinates=coordinates,\n                                     description=locus_annotation_row[\"description\"],\n                                     circular=locus_annotation_row[\"circular\"],\n                                     length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                     order=locus_annotation_row[\"order\"])\n                features_ids = [i.id for i in gff_record.features]\n                if len(features_ids) != len(set(features_ids)):\n                    raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} contains duplicated feature ids while\"\n                                                       f\" only unique are allowed.\")\n                for gff_feature in gff_record.features:\n                    feature_id = gff_feature.id\n                    transl_table = self.prms.args[\"default_transl_table\"]\n                    if \"transl_table\" in gff_feature.qualifiers.keys():\n                        transl_table = int(gff_feature.qualifiers[\"transl_table\"][0])\n                    name = \"\"\n                    if self.prms.args[\"gff_CDS_name_source\"] in gff_feature.qualifiers:\n                        name = gff_feature.qualifiers[self.prms.args[\"gff_CDS_name_source\"]][0]\n                    category = \"\"\n                    if self.prms.args[\"gff_CDS_category_source\"] in gff_feature.qualifiers:\n                        category = \",\".join(gff_feature.qualifiers[self.prms.args[\"gff_CDS_category_source\"]])\n                    for coordinate in record_locus.coordinates:\n                        start, end = coordinate[\"start\"], coordinate[\"end\"]\n                        if start &lt;= gff_feature.location.start + 1 &lt;= end or start &lt;= gff_feature.location.end &lt;= end:\n                            self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                             f\"{int(gff_feature.location.start) + 1}:\"\n                                                             f\"{int(gff_feature.location.end)}:{gff_feature.location.strand}\",\n                                                             \"CDS\", category, name)\n                            feature_annotation_row = self.feature_annotation.loc[feature_id]\n                            feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                              feature_id=feature_id, start=int(gff_feature.location.start) + 1,\n                                              end=int(gff_feature.location.end), strand=gff_feature.location.strand,\n                                              name=feature_annotation_row[\"name\"],\n                                              sequence=gff_feature.translate(record_locus_sequence, table=transl_table,\n                                                                             cds=False)[:-1],\n                                              group=feature_annotation_row[\"group\"],\n                                              group_type=feature_annotation_row[\"group_type\"], category=category,\n                                              vis_prms=dict(fill_color=feature_annotation_row[\"fill_color\"],\n                                                            stroke_color=feature_annotation_row[\"stroke_color\"],\n                                                            show_label=feature_annotation_row[\"show_label\"]),\n                                              parameters=self.prms)\n                            record_locus.features.append(feature)\n                self.loci.append(record_locus)\n            seq_id_to_order = self.loci_annotation[\"order\"].to_dict()\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n            if self.prms.args[\"verbose\"]:\n                if len(self.loci) == 1:\n                    print(f\"\ud83d\udce5 {len(self.loci)} locus was loaded from extended gff files folder\", file=sys.stdout)\n                else:\n                    print(f\"\ud83d\udce5 {len(self.loci)} loci were loaded from extended gff files folder\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gff folder.\") from error\n\n    def load_loci_from_gb(self, input_folder: str) -&gt; None:\n        \"\"\"Load loci from the folder with genbank files.\n\n        All files with extension other than .gb (not case-sensitive) will be ignored.\n\n        Arguments:\n            input_folder: folder name with gb files.\n\n        Returns:\n            None\n\n        \"\"\"\n        if not os.path.exists(input_folder):\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n        try:\n            gb_files = [f for f in os.listdir(input_folder) if os.path.splitext(f)[-1].lower() == \".gb\"]\n            if not gb_files:\n                raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain .gb(.GB) files.\")\n            for gb_file in gb_files:\n                gb_file_path = os.path.join(input_folder, gb_file)\n                gb_records = list(Bio.SeqIO.parse(gb_file_path, \"genbank\"))\n                if len(gb_records) != 1:\n                    raise lovis4u.Manager.lovis4uError(f\"gb file {gb_file} does not contain information for only\"\n                                                       f\" 1 sequence.\")\n                gb_record = gb_records[0]\n                record_locus_sequence = gb_record.seq\n                if self.prms.args[\"genbank_description_source\"] == \"description\":\n                    record_description = gb_record.description\n                elif \"annotations:\" in self.prms.args[\"genbank_description_source\"]:\n                    feature_description_key = self.prms.args[\"genbank_description_source\"].split(\":\")[1]\n                    record_description = gb_record.annotations[feature_description_key]\n                else:\n                    record_description = \"\"\n                self.__update_loci_annotation(gb_record.id, record_description, len(record_locus_sequence))\n                locus_annotation_row = self.loci_annotation.loc[gb_record.id]\n                coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                               locus_annotation_row[\"coordinates\"].split(\",\")]\n                record_locus = Locus(seq_id=gb_record.id, coordinates=coordinates,\n                                     description=locus_annotation_row[\"description\"],\n                                     circular=locus_annotation_row[\"circular\"],\n                                     length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                     order=locus_annotation_row[\"order\"])\n\n                gb_CDSs = [i for i in gb_record.features if i.type == \"CDS\"]\n                first_CDS_record = gb_CDSs[0]\n                id_source = self.prms.args[\"genbank_id_source\"]\n                if self.prms.args[\"genbank_id_source\"] not in first_CDS_record.qualifiers:\n                    for alternative_id_source in self.prms.args[\"genbank_id_alternative_source\"]:\n                        if alternative_id_source in first_CDS_record.qualifiers:\n                            id_source = alternative_id_source\n                            print(f\"\u2757 Warning: there is no &lt;{self.prms.args['genbank_id_source']}&gt; attribute \"\n                                  f\"for CDS records in {gb_file}. Alternative &lt;{id_source}&gt; was used instead.\",\n                                  file=sys.stdout)\n                            break\n                    if id_source == self.prms.args[\"genbank_id_source\"]:\n                        raise lovis4u.Manager.lovis4uError(f\"There is no &lt;{self.prms.args['genbank_id_source']}&gt; \"\n                                                           f\"attribute for CDS record found in {gb_file}. We tried to\"\n                                                           f\" find any from the alternative list: \"\n                                                           f\"{','.join(self.prms.args['genbank_id_alternative_source'])}\"\n                                                           f\", but they also weren't found.\")  # add about cmd parameter\n                features_ids = [i.qualifiers[id_source][0] for i in gb_CDSs]\n                if len(features_ids) != len(set(features_ids)):\n                    raise lovis4u.Manager.lovis4uError(f\"GB file {gb_record} contains duplicated feature ids while\"\n                                                       f\" only unique are allowed.\")\n                for gb_feature in gb_CDSs:\n                    feature_id = gb_feature.qualifiers[id_source][0].replace(\"|\", \"_\")\n                    transl_table = self.prms.args[\"default_transl_table\"]\n                    if \"transl_table\" in gb_feature.qualifiers.keys():\n                        transl_table = int(gb_feature.qualifiers[\"transl_table\"][0])\n                    name = \"\"\n                    if self.prms.args[\"genbank_CDS_name_source\"] in gb_feature.qualifiers:\n                        name = gb_feature.qualifiers[self.prms.args[\"genbank_CDS_name_source\"]][0]\n                    category = \"\"\n                    if self.prms.args[\"genbank_CDS_category_source\"] in gb_feature.qualifiers:\n                        category = \",\".join(gb_feature.qualifiers[self.prms.args[\"genbank_CDS_category_source\"]])\n                    for coordinate in record_locus.coordinates:\n                        start, end = coordinate[\"start\"], coordinate[\"end\"]\n                        if start &lt;= gb_feature.location.start + 1 &lt;= end or start &lt;= gb_feature.location.end &lt;= end:\n                            self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                             f\"{int(gb_feature.location.start) + 1}:\"\n                                                             f\"{int(gb_feature.location.end)}:\"\n                                                             f\"{gb_feature.location.strand}\", \"CDS\", category, name)\n                            feature_annotation_row = self.feature_annotation.loc[feature_id]\n                            feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                              feature_id=feature_id, start=int(gb_feature.location.start) + 1,\n                                              end=int(gb_feature.location.end),\n                                              strand=gb_feature.location.strand, name=feature_annotation_row[\"name\"],\n                                              sequence=gb_feature.translate(record_locus_sequence, table=transl_table,\n                                                                            cds=False)[:-1],\n                                              group=feature_annotation_row[\"group\"],\n                                              group_type=feature_annotation_row[\"group_type\"], category=category,\n                                              vis_prms=dict(fill_color=feature_annotation_row[\"fill_color\"],\n                                                            stroke_color=feature_annotation_row[\"stroke_color\"],\n                                                            show_label=feature_annotation_row[\"show_label\"]),\n                                              parameters=self.prms)\n\n                            record_locus.features.append(feature)\n                self.loci.append(record_locus)\n            seq_id_to_order = self.loci_annotation[\"order\"].to_dict()\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n            if self.prms.args[\"verbose\"]:\n                if len(self.loci) == 1:\n                    print(f\"\ud83d\udce5 {len(self.loci)} locus was loaded from genbank files folder\", file=sys.stdout)\n                else:\n                    print(f\"\ud83d\udce5 {len(self.loci)} loci were loaded from genbank files folder\", file=sys.stdout)\n\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gb folder.\") from error\n\n    def save_loci_annotation_table(self) -&gt; None:\n        \"\"\"Save loci annotation table to the output folder.\n\n        Output file name is loci_annotation_table.tsv\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"loci_annotation_table.tsv\")\n            self.loci_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"sequence_id\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\ud83d\udc8c Loci annotation table was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to save loci annotation table.\") from error\n\n    def save_features_annotation_table(self) -&gt; None:\n        \"\"\"Save feature annotation table to the output folder.\n\n        Output file name is features_annotation_table.tsv\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"features_annotation_table.tsv\")\n            self.feature_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"feature_id\")\n            if self.prms.args[\"verbose\"]:\n                print(f\"\ud83d\udc8c Feature annotation table was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to save feature annotation table.\") from error\n\n    def mmseqs_cluster(self) -&gt; pd.DataFrame:\n        \"\"\"Cluster all proteins using mmseqs in order to define groups of homologues.\n\n        Returns:\n            pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is\n                defined by representative sequence id within a corresponding cluster.\n\n        \"\"\"\n        if self.prms.args[\"verbose\"]:\n            print(f\"\ud83d\ude80 Running mmseqs for protein clustering...\", file=sys.stdout)\n        try:\n            feature_records = [feature.record for locus in self.loci for feature in locus.features]\n            temp_input = tempfile.NamedTemporaryFile()\n            Bio.SeqIO.write(feature_records, temp_input.name, \"fasta\")\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            mmseqs_output_folder = os.path.join(self.prms.args[\"output_dir\"], \"mmseqs\")\n            if os.path.exists(mmseqs_output_folder):\n                shutil.rmtree(mmseqs_output_folder)\n            os.mkdir(mmseqs_output_folder)\n            Bio.SeqIO.write(feature_records, os.path.join(mmseqs_output_folder, \"input_proteins.fa\"), \"fasta\")\n            mmseqs_output_folder_db = os.path.join(mmseqs_output_folder, \"DB\")\n            os.mkdir(mmseqs_output_folder_db)\n            mmseqs_stdout = open(os.path.join(mmseqs_output_folder, \"mmseqs_stdout.txt\"), \"w\")\n            mmseqs_stderr = open(os.path.join(mmseqs_output_folder, \"mmseqs_stderr.txt\"), \"w\")\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createdb\", temp_input.name,\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\")], stdout=mmseqs_stdout,\n                           stderr=mmseqs_stderr)\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"cluster\",\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"tmp\"),\n                            \"--cluster-mode\", str(self.prms.args[\"mmseqs_cluster_mode\"]),\n                            \"--cov-mode\", str(self.prms.args[\"mmseqs_cov_mode\"]),\n                            \"--min-seq-id\", str(self.prms.args[\"mmseqs_min_seq_id\"]),\n                            \"-c\", str(self.prms.args[\"mmseqs_c\"]),\n                            \"-s\", str(self.prms.args[\"mmseqs_s\"])], stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n            subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createtsv\",\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                            os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                            os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\")],\n                           stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n            mmseqs_clustering_results = pd.read_table(os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\"),\n                                                      sep=\"\\t\", header=None, names=[\"cluster\", \"protein_id\"])\n            mmseqs_clustering_results = mmseqs_clustering_results.set_index(\"protein_id\")\n\n            num_of_unique_clusters = len(set(mmseqs_clustering_results[\"cluster\"].to_list()))\n            num_of_proteins = len(mmseqs_clustering_results.index)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u2705 {num_of_unique_clusters} clusters for {num_of_proteins} proteins were found with mmseqs\\n\"\n                      f\"\ud83d\udc8c mmseqs clustering results were saved to \"\n                      f\"{os.path.join(mmseqs_output_folder, 'mmseqs_clustering.tsv')}\", file=sys.stdout)\n            return mmseqs_clustering_results\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to run mmseqs clustering.\") from error\n\n    def define_features_groups(self, dataframe: pd.DataFrame, group_column_name: str = \"cluster\") -&gt; None:\n        \"\"\"Set features attribute \"group\" based on input dataframe.\n\n        By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed\n            feature groups you can set them with feature table.\n\n        Arguments:\n            dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n            group_column_name (str): column name of the dataframe that represent corresponding group to each feature.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for locus in self.loci:\n                for feature in locus.features:\n                    if feature.group and self.prms.args[\"keep_predefined_groups\"]:\n                        continue\n                    feature.group = dataframe.loc[feature.feature_id, group_column_name]\n                    self.feature_annotation.loc[feature.feature_id, \"group\"] = feature.group\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define protein features groups.\") from error\n\n    def define_labels_to_be_shown(self):\n        \"\"\"Set feature visaulisation attribute \"show_label\" based on feature groups.\n\n        controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and\n            feature_group_types_to_show_label_on_first_occurrence parameters.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            added_first_occurrence_labels = []\n            for locus in self.loci:\n                for feature in locus.features:\n                    if self.prms.args[\"show_all_feature_labels\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                        continue\n                    if feature.vis_prms[\"label\"] not in self.prms.args[\"feature_labels_to_ignore\"]:\n                        if \"any\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n                            feature.vis_prms[\"show_label\"] = 1\n                        elif feature.group_type in self.prms.args[\"feature_group_types_to_show_label\"]:\n                            feature.vis_prms[\"show_label\"] = 1\n                        elif feature.group_type in \\\n                                self.prms.args[\"feature_group_types_to_show_label_on_first_occurrence\"]:\n                            if feature.group not in added_first_occurrence_labels:\n                                feature.vis_prms[\"show_label\"] = 1\n                                added_first_occurrence_labels.append(feature.group)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable define feature labels to be shown.\") from error\n\n    def cluster_sequences(self, dataframe: pd.DataFrame) -&gt; None:\n        \"\"\"Define loci order and clusters with proteome similarity based hierarchical clustering.\n            This function changes the order of loci that are plotted and also updates corresponding to each loci group\n            attribute which defines homologues groups of proteomes.\n\n        It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n            groups by other method you can also build pandas dataframe based on that with index corresponding to\n            feature id and column \"cluster\" corresponding to the group.\n\n        Arguments:\n              dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            proteins_loci_dict = collections.defaultdict(collections.deque)\n            loci_clusters_dict = dict()\n            number_of_loci = len(self.loci)\n            proteome_sizes = pd.Series(np.zeros(number_of_loci, dtype=int))\n            for locus_index in range(number_of_loci):\n                locus = self.loci[locus_index]\n                loci_clusters = [dataframe.loc[feature.feature_id, \"cluster\"] for feature in locus.features]\n                loci_clusters_dict[locus_index] = list(set(loci_clusters))\n                proteome_sizes.iloc[locus_index] = len(set(loci_clusters))\n                for l_cl in loci_clusters:\n                    proteins_loci_dict[l_cl].append(locus_index)\n\n            loci_ids = [locus.seq_id for locus in self.loci]\n            similarity_matrix = pd.DataFrame(0.0, index=loci_ids, columns=loci_ids)\n            for locus_index in range(number_of_loci):\n                counts = pd.Series(np.zeros(number_of_loci, dtype=int))\n                for cluster in loci_clusters_dict[locus_index]:\n                    js = proteins_loci_dict[cluster]\n                    counts.iloc[js] += 1\n                locus_size = proteome_sizes[locus_index]\n                norm_factors = pd.Series(0.5 * (locus_size + proteome_sizes) / (locus_size * proteome_sizes),\n                                         index=counts.index)\n                weights = counts.mul(norm_factors)\n                similarity_matrix.iloc[locus_index] = weights\n            symmetric_distance_matrix = 1 - similarity_matrix\n            np.fill_diagonal(symmetric_distance_matrix.values, 0)\n            linkage_matrix = scipy.cluster.hierarchy.linkage(\n                scipy.spatial.distance.squareform(symmetric_distance_matrix),\n                method=\"average\")\n            dendrogram = scipy.cluster.hierarchy.dendrogram(linkage_matrix, no_plot=True)\n            clusters = pd.Series(scipy.cluster.hierarchy.fcluster(linkage_matrix, 0.35, criterion=\"distance\"),\n                                 index=loci_ids)\n            for locus in self.loci:\n                locus.group = clusters[locus.seq_id]\n                self.loci_annotation.loc[locus.seq_id, \"group\"] = locus.group\n            order = dendrogram[\"leaves\"][::-1]\n            self.loci_annotation[\"initial_order\"] = self.loci_annotation[\"order\"]\n            for locus_index in range(number_of_loci):\n                locus = self.loci[locus_index]\n                self.loci_annotation.loc[locus.seq_id, \"order\"] = order.index(locus_index)\n            self.loci_annotation.sort_values(by=\"order\", inplace=True)\n            seq_id_to_order = self.loci_annotation[\"order\"].to_dict()\n            self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n\n            reordered_similarity_matrix = similarity_matrix.reindex(index=self.loci_annotation.index,\n                                                                    columns=self.loci_annotation.index)\n            if not os.path.exists(self.prms.args[\"output_dir\"]):\n                os.mkdir(self.prms.args[\"output_dir\"])\n            file_path = os.path.join(self.prms.args[\"output_dir\"], \"proteome_similarity_matrix.tsv\")\n            reordered_similarity_matrix.to_csv(file_path, sep=\"\\t\")\n            num_of_loci_groups = len(set(self.loci_annotation[\"group\"].to_list()))\n            if self.prms.args[\"verbose\"]:\n                if num_of_loci_groups == 1:\n                    print(f\"\ud83e\udee7 Loci order and {num_of_loci_groups} cluster was defined with proteome similarity based \"\n                          f\"hierarchical clustering\", file=sys.stdout)\n                elif num_of_loci_groups &gt; 1:\n                    print(f\"\ud83e\udee7 Loci order and {num_of_loci_groups} clusters were defined with proteome similarity based \"\n                          f\"hierarchical clustering\", file=sys.stdout)\n                print(f\"\ud83d\udc8c Proteome similarity matrix of loci was saved to {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to cluster loci sequences.\") from error\n\n    def find_variable_feature_groups(self, mmseqs_results: pd.DataFrame) -&gt; None:\n        \"\"\"Define feature group type attributes (variable or shell/core) based on their conservation in corresponding\n            loci group feature.\n\n        It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n            groups by other method you can also build pandas dataframe based on that with index corresponding to\n            feature id and column \"cluster\" corresponding to the group.\n\n        Arguments:\n              mmseqs_results (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n                represent all loci CDS features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_clusters_sizes = self.loci_annotation[\"group\"].value_counts()\n            loci_clusters_cutoffs = np.round(self.prms.args[\"CDS_is_variable_cutoff\"] * loci_clusters_sizes).astype(int)\n            loci_clusters_cutoffs[loci_clusters_cutoffs == 0] = 1\n            cluster_types = collections.defaultdict(dict)\n            for cluster in set(mmseqs_results[\"cluster\"].to_list()):\n                cluster_proteins = mmseqs_results[mmseqs_results[\"cluster\"] == cluster].index\n                cluster_loci = [locus for locus in self.loci if\n                                any(feature.feature_id in cluster_proteins for feature in locus.features)]\n                cluster_loci_groups = [locus.group for locus in cluster_loci]\n                for cluster_locus_group in cluster_loci_groups:\n                    current_group_cluster_loci = [locus.seq_id for locus in cluster_loci if\n                                                  locus.group == cluster_locus_group]\n                    current_group_cluster_size = len(set(current_group_cluster_loci))\n                    if loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                            current_group_cluster_size &lt;= loci_clusters_cutoffs[cluster_locus_group]:\n                        cluster_types[cluster_locus_group][cluster] = \"variable\"\n                    else:\n                        cluster_types[cluster_locus_group][cluster] = \"shell/core\"\n            for locus in self.loci:\n                locus_group = locus.group\n                for feature in locus.features:\n                    if feature.group_type and self.prms.args[\"keep_predefined_groups\"]:\n                        continue\n                    feature.group_type = cluster_types[locus_group][feature.group]\n                    self.feature_annotation.loc[feature.feature_id, \"group_type\"] = feature.group_type\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n\n    def set_feature_colors_based_on_groups(self) -&gt; None:\n        \"\"\"Define features fill color based on corresponding feature group and group types.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            feature_groups = set([feature.group for locus in self.loci for feature in locus.features if feature.group])\n            if self.prms.args[\"feature_group_types_to_set_color\"] and \\\n                    \"all\" not in self.prms.args[\"feature_group_types_to_set_color\"]:\n                feature_groups = set([feature.group for locus in self.loci for feature in locus.features\n                                      if feature.group and feature.group_type in\n                                      self.prms.args[\"feature_group_types_to_set_color\"]])\n            number_of_unique_feature_groups = len(feature_groups)\n            if self.prms.args[\"groups_fill_color_palette_lib\"] == \"seaborn\":\n                colors_rgb = seaborn.color_palette(self.prms.args[\"groups_fill_color_seaborn_palette\"],\n                                                   number_of_unique_feature_groups,\n                                                   desat=self.prms.args[\"groups_fill_color_seaborn_desat\"])\n                random.shuffle(colors_rgb)\n            elif self.prms.args[\"groups_fill_color_palette_lib\"] == \"distinctipy\":\n                colors_rgb = distinctipy.get_colors(number_of_unique_feature_groups,\n                                                    exclude_colors=[(1, 1, 1), (0, 0, 0)],\n                                                    pastel_factor=self.prms.args[\"groups_fill_colors_pastel_factor\"])\n            colors = list(map(lambda x: matplotlib.colors.rgb2hex(x), colors_rgb))\n            colors_dict = {g: c for g, c in zip(list(feature_groups), colors)}\n            for locus in self.loci:\n                for feature in locus.features:\n                    if feature.group in feature_groups:\n                        if self.prms.args[\"keep_predefined_colors\"] and feature.vis_prms[\"fill_color\"] != \"default\":\n                            continue\n                        feature.vis_prms[\"fill_color\"] = colors_dict[feature.group]\n                        self.feature_annotation.loc[feature.feature_id, \"fill_color\"] = feature.vis_prms[\"fill_color\"]\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to set feature colors based on groups.\") from error\n\n    def set_category_colors(self, use_table: bool = True) -&gt; None:\n        \"\"\"Define colors for each category.\n\n        Arguments:\n            use_table (bool): Bool value whether table with predefined colors should be used or not.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            colors_dict = dict()\n            if use_table:\n                colors_dict.update(\n                    pd.read_table(self.prms.args[\"category_colors\"]).set_index(\"category\")[\"color\"].to_dict())\n\n            feature_categories = list(set([feature.category for locus in self.loci for feature in locus.features\n                                           if feature.category and feature.category]))\n            if not feature_categories:\n                print(\"\u2757 Warning: there are no feature categories to set colors\", file=sys.stdout)\n            colors_dict = {cat: col for cat, col in colors_dict.items() if cat in feature_categories}\n\n            feature_categories = [ff for ff in feature_categories if ff not in colors_dict.keys()]\n            number_of_unique_feature_functions = len(feature_categories)\n            colors_rgb = seaborn.color_palette(self.prms.args[\"category_color_seaborn_palette\"],\n                                               number_of_unique_feature_functions,\n                                               desat=self.prms.args[\"category_color_seaborn_desat\"])\n            random.shuffle(colors_rgb)\n            colors = list(map(lambda x: matplotlib.colors.rgb2hex(x), colors_rgb))\n            colors_dict.update({g: c for g, c in zip(list(feature_categories), colors)})\n            for locus in self.loci:\n                locus.category_colors = colors_dict\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to set category colors.\") from error\n\n    def reorient_loci(self) -&gt; None:\n        \"\"\"Auto re-orient loci (reset strands) of loci if they are not matched.\n\n        Function tries to maximise co-orientation of homologous features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_groups = set(self.loci_annotation[\"group\"].to_list())\n            count_of_changed_strands = 0\n            for loci_group in loci_groups:\n                loci = [locus for locus in self.loci if locus.group == loci_group]\n                for locus_index in range(1, len(loci)):\n                    p_locus = loci[locus_index - 1]\n                    c_locus = loci[locus_index]\n                    p_locus_strands = list(set([c[\"strand\"] for c in p_locus.coordinates]))\n                    c_locus_strands = list(set([c[\"strand\"] for c in c_locus.coordinates]))\n                    if len(p_locus_strands) == 1 and len(c_locus_strands) == 1:\n                        pr_locus_features_groups = set([f.group for f in p_locus.features])\n                        c_locus_features_groups = set([f.group for f in c_locus.features])\n                        overlapped_f_groups = pr_locus_features_groups &amp; c_locus_features_groups\n                        prl_strand, cl_strand = p_locus_strands[0], c_locus_strands[0]\n                        pr_locus_features_strands = {f.group: f.strand * prl_strand for f in p_locus.features if\n                                                     f.group in overlapped_f_groups}\n                        c_locus_features_strands = {f.group: f.strand * cl_strand for f in c_locus.features if\n                                                    f.group in overlapped_f_groups}\n                        codirection_score = 0\n                        for ovg in overlapped_f_groups:\n                            codirection_score += pr_locus_features_strands[ovg] * c_locus_features_strands[ovg]\n                        if codirection_score &lt; 0:\n                            count_of_changed_strands += 1\n                            annot_coordinates = []\n                            for cc in loci[locus_index].coordinates:\n                                cc[\"strand\"] *= -1\n                                annot_coordinates.append(f\"{cc['start']}:{cc['end']}:{cc['strand']}\")\n                            self.loci_annotation.loc[c_locus.seq_id, \"coordinates\"] = \",\".join(annot_coordinates)\n                    else:\n                        print(\"\u2757 Warning: loci reorientation cannot be applied for loci that have both strands in\"\n                              \" pre-defined coordinates for visualisation\")\n            if self.prms.args[\"verbose\"]:\n                if count_of_changed_strands == 0:\n                    print(f\"\ud83d\udd01 Orientation was not changed for any locus\", file=sys.stdout)\n                elif count_of_changed_strands == 1:\n                    print(f\"\ud83d\udd01 Orientation was changed for 1 locus\", file=sys.stdout)\n                elif count_of_changed_strands &gt; 1:\n                    print(f\"\ud83d\udd01 Orientation was changed for {count_of_changed_strands} loci\", file=sys.stdout)\n\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n\n    def get_loci_lengths_and_n_of_regions(self) -&gt; list[list[int]]:\n        \"\"\"Get loci lengths and number of regions.\n\n        Returns:\n            list: list each element of each contains locus size and number of breaks for visualisation track.\n\n        \"\"\"\n        try:\n            loci_sizes = []\n            for locus in self.loci:\n                number_of_gaps = len(locus.coordinates) - 1\n                if locus.circular:\n                    for i in range(number_of_gaps):\n                        if locus.coordinates[i][\"end\"] == locus.length and locus.coordinates[i + 1][\"start\"] == 1:\n                            number_of_gaps -= 1\n                loci_sizes.append([locus.size, number_of_gaps])\n            return loci_sizes\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to get loci lengths.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__init__","title":"<code>__init__(parameters=lovis4u.Manager.Parameters)</code>","text":"<p>Create a Loci object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>, default:                 <code>Parameters</code> )         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, parameters=lovis4u.Manager.Parameters):\n    \"\"\"Create a Loci object.\n\n    Arguments:\n        parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n    \"\"\"\n    self.loci = []\n    self.loci_annotation = pd.DataFrame(columns=[\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\",\n                                                 \"order\", \"group\"]).set_index(\"sequence_id\")\n    self.feature_annotation = pd.DataFrame(columns=[\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\",\n                                                    \"group\", \"group_type\", \"category\", \"fill_color\", \"stroke_color\",\n                                                    \"show_label\"]).set_index(\"feature_id\")\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__load_annotation_file","title":"<code>__load_annotation_file(file_path, annotation_columns, index_column)</code>","text":"<p>Private method to load an annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for an annotation file to be loaded.</p> </li> <li> <code>annotation_columns</code>             (<code>list</code>)         \u2013          <p>List of columns that should be considered.</p> </li> <li> <code>index_column</code>             (<code>str</code>)         \u2013          <p>Column name to be considered as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>pd.DataFrame: Preprocessed annotation file.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __load_annotation_file(self, file_path: str, annotation_columns: list, index_column: str) -&gt; pd.DataFrame:\n    \"\"\"Private method to load an annotation file.\n\n    Arguments:\n        file_path (str): File path for an annotation file to be loaded.\n        annotation_columns (list): List of columns that should be considered.\n        index_column (str): Column name to be considered as index.\n\n    Returns:\n          pd.DataFrame: Preprocessed annotation file.\n    \"\"\"\n    annotation_table = pd.read_table(file_path)\n    found_allowed_columns = [i for i in annotation_columns if i in annotation_table.columns]\n    not_found_allowed_columns = [i for i in annotation_columns if i not in annotation_table.columns]\n    annotation_table = annotation_table[found_allowed_columns].set_index(index_column)\n    annotation_table[not_found_allowed_columns] = None\n    return annotation_table\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__update_feature_annotation","title":"<code>__update_feature_annotation(feature_id, locus_id, coordinates, feature_type, category, name)</code>","text":"<p>Private method for updating feature annotation.</p> <p>Parameters:</p> <ul> <li> <code>feature_id</code>             (<code>str</code>)         \u2013          <p>Feature identifier.</p> </li> <li> <code>locus_id</code>             (<code>str</code>)         \u2013          <p>Sequence description.</p> </li> <li> <code>coordinates</code>             (<code>str</code>)         \u2013          <p>Feature coordinates.</p> </li> <li> <code>category</code>             (<code>str</code>)         \u2013          <p>Feature type.</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Feature name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __update_feature_annotation(self, feature_id: str, locus_id: str, coordinates: str, feature_type: str,\n                                category: str, name: str) -&gt; None:\n    \"\"\"Private method for updating feature annotation.\n\n    Arguments:\n        feature_id (str): Feature identifier.\n        locus_id (str): Sequence description.\n        coordinates (str): Feature coordinates.\n        category (str): Feature type.\n        name (str): Feature name.\n\n\n    Returns:\n        None\n\n    \"\"\"\n    if feature_id not in self.feature_annotation.index:\n        self.feature_annotation.loc[feature_id] = {col: None for col in self.feature_annotation.columns}\n\n    if self.feature_annotation.loc[feature_id][\"group_type\"] in self.prms.args[\"feature_group_types_to_show_label\"] \\\n            or \"all\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n        show_label = 1\n    else:\n        show_label = 0\n    stroke_color = \"default\"\n    if self.prms.args[\"set_feature_stroke_color_based_on_fill_color\"] and \\\n            self.feature_annotation.loc[feature_id][\"fill_color\"] and \\\n            self.feature_annotation.loc[feature_id][\"fill_color\"] != \"default\":\n        stroke_color = lovis4u.Methods.scale_lightness(self.feature_annotation.loc[feature_id][\"fill_color\"],\n                                                       self.prms.args[\"feature_stroke_color_relative_lightness\"])\n    default_values = dict(locus_id=locus_id, coordinates=coordinates, feature_type=feature_type,\n                          name=name, group=\"\", group_type=\"\", category=category, fill_color=\"default\",\n                          stroke_color=stroke_color,\n                          show_label=show_label)\n    self.feature_annotation.loc[feature_id] = self.feature_annotation.loc[feature_id].fillna(default_values)\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.__update_loci_annotation","title":"<code>__update_loci_annotation(record_id, record_description, record_length)</code>","text":"<p>Private method for updating loci annotation.</p> <p>Parameters:</p> <ul> <li> <code>record_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier.</p> </li> <li> <code>record_description</code>             (<code>str</code>)         \u2013          <p>Sequence description.</p> </li> <li> <code>record_length</code>             (<code>int</code>)         \u2013          <p>Sequence length.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __update_loci_annotation(self, record_id: str, record_description: str, record_length: int) -&gt; None:\n    \"\"\"Private method for updating loci annotation.\n\n    Arguments:\n        record_id (str): Sequence identifier.\n        record_description (str): Sequence description.\n        record_length (int): Sequence length.\n\n    Returns:\n        None\n\n    \"\"\"\n    if record_id not in self.loci_annotation.index:\n        self.loci_annotation.loc[record_id] = {col: None for col in self.loci_annotation.columns}\n\n    default_values = dict(length=record_length, coordinates=f\"1:{record_length}:1\",\n                          description=record_description, circular=1, order=len(self.loci), group=1)\n    self.loci_annotation.loc[record_id] = self.loci_annotation.loc[record_id].fillna(default_values)\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.cluster_sequences","title":"<code>cluster_sequences(dataframe)</code>","text":"<p>Define loci order and clusters with proteome similarity based hierarchical clustering.     This function changes the order of loci that are plotted and also updates corresponding to each loci group     attribute which defines homologues groups of proteomes.</p> <p>It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues     groups by other method you can also build pandas dataframe based on that with index corresponding to     feature id and column \"cluster\" corresponding to the group.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def cluster_sequences(self, dataframe: pd.DataFrame) -&gt; None:\n    \"\"\"Define loci order and clusters with proteome similarity based hierarchical clustering.\n        This function changes the order of loci that are plotted and also updates corresponding to each loci group\n        attribute which defines homologues groups of proteomes.\n\n    It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n        groups by other method you can also build pandas dataframe based on that with index corresponding to\n        feature id and column \"cluster\" corresponding to the group.\n\n    Arguments:\n          dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        proteins_loci_dict = collections.defaultdict(collections.deque)\n        loci_clusters_dict = dict()\n        number_of_loci = len(self.loci)\n        proteome_sizes = pd.Series(np.zeros(number_of_loci, dtype=int))\n        for locus_index in range(number_of_loci):\n            locus = self.loci[locus_index]\n            loci_clusters = [dataframe.loc[feature.feature_id, \"cluster\"] for feature in locus.features]\n            loci_clusters_dict[locus_index] = list(set(loci_clusters))\n            proteome_sizes.iloc[locus_index] = len(set(loci_clusters))\n            for l_cl in loci_clusters:\n                proteins_loci_dict[l_cl].append(locus_index)\n\n        loci_ids = [locus.seq_id for locus in self.loci]\n        similarity_matrix = pd.DataFrame(0.0, index=loci_ids, columns=loci_ids)\n        for locus_index in range(number_of_loci):\n            counts = pd.Series(np.zeros(number_of_loci, dtype=int))\n            for cluster in loci_clusters_dict[locus_index]:\n                js = proteins_loci_dict[cluster]\n                counts.iloc[js] += 1\n            locus_size = proteome_sizes[locus_index]\n            norm_factors = pd.Series(0.5 * (locus_size + proteome_sizes) / (locus_size * proteome_sizes),\n                                     index=counts.index)\n            weights = counts.mul(norm_factors)\n            similarity_matrix.iloc[locus_index] = weights\n        symmetric_distance_matrix = 1 - similarity_matrix\n        np.fill_diagonal(symmetric_distance_matrix.values, 0)\n        linkage_matrix = scipy.cluster.hierarchy.linkage(\n            scipy.spatial.distance.squareform(symmetric_distance_matrix),\n            method=\"average\")\n        dendrogram = scipy.cluster.hierarchy.dendrogram(linkage_matrix, no_plot=True)\n        clusters = pd.Series(scipy.cluster.hierarchy.fcluster(linkage_matrix, 0.35, criterion=\"distance\"),\n                             index=loci_ids)\n        for locus in self.loci:\n            locus.group = clusters[locus.seq_id]\n            self.loci_annotation.loc[locus.seq_id, \"group\"] = locus.group\n        order = dendrogram[\"leaves\"][::-1]\n        self.loci_annotation[\"initial_order\"] = self.loci_annotation[\"order\"]\n        for locus_index in range(number_of_loci):\n            locus = self.loci[locus_index]\n            self.loci_annotation.loc[locus.seq_id, \"order\"] = order.index(locus_index)\n        self.loci_annotation.sort_values(by=\"order\", inplace=True)\n        seq_id_to_order = self.loci_annotation[\"order\"].to_dict()\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n\n        reordered_similarity_matrix = similarity_matrix.reindex(index=self.loci_annotation.index,\n                                                                columns=self.loci_annotation.index)\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"proteome_similarity_matrix.tsv\")\n        reordered_similarity_matrix.to_csv(file_path, sep=\"\\t\")\n        num_of_loci_groups = len(set(self.loci_annotation[\"group\"].to_list()))\n        if self.prms.args[\"verbose\"]:\n            if num_of_loci_groups == 1:\n                print(f\"\ud83e\udee7 Loci order and {num_of_loci_groups} cluster was defined with proteome similarity based \"\n                      f\"hierarchical clustering\", file=sys.stdout)\n            elif num_of_loci_groups &gt; 1:\n                print(f\"\ud83e\udee7 Loci order and {num_of_loci_groups} clusters were defined with proteome similarity based \"\n                      f\"hierarchical clustering\", file=sys.stdout)\n            print(f\"\ud83d\udc8c Proteome similarity matrix of loci was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to cluster loci sequences.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.define_features_groups","title":"<code>define_features_groups(dataframe, group_column_name='cluster')</code>","text":"<p>Set features attribute \"group\" based on input dataframe.</p> <p>By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed     feature groups you can set them with feature table.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> <li> <code>group_column_name</code>             (<code>str</code>, default:                 <code>'cluster'</code> )         \u2013          <p>column name of the dataframe that represent corresponding group to each feature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def define_features_groups(self, dataframe: pd.DataFrame, group_column_name: str = \"cluster\") -&gt; None:\n    \"\"\"Set features attribute \"group\" based on input dataframe.\n\n    By default is designed to use mmseqs_cluster() function results as input. If you already have precomputed\n        feature groups you can set them with feature table.\n\n    Arguments:\n        dataframe (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n        group_column_name (str): column name of the dataframe that represent corresponding group to each feature.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for locus in self.loci:\n            for feature in locus.features:\n                if feature.group and self.prms.args[\"keep_predefined_groups\"]:\n                    continue\n                feature.group = dataframe.loc[feature.feature_id, group_column_name]\n                self.feature_annotation.loc[feature.feature_id, \"group\"] = feature.group\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define protein features groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.define_labels_to_be_shown","title":"<code>define_labels_to_be_shown()</code>","text":"<p>Set feature visaulisation attribute \"show_label\" based on feature groups.</p> <p>controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and     feature_group_types_to_show_label_on_first_occurrence parameters.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def define_labels_to_be_shown(self):\n    \"\"\"Set feature visaulisation attribute \"show_label\" based on feature groups.\n\n    controlled by feature_labels_to_ignore, feature_group_types_to_show_label, and\n        feature_group_types_to_show_label_on_first_occurrence parameters.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        added_first_occurrence_labels = []\n        for locus in self.loci:\n            for feature in locus.features:\n                if self.prms.args[\"show_all_feature_labels\"]:\n                    feature.vis_prms[\"show_label\"] = 1\n                    continue\n                if feature.vis_prms[\"label\"] not in self.prms.args[\"feature_labels_to_ignore\"]:\n                    if \"any\" in self.prms.args[\"feature_group_types_to_show_label\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                    elif feature.group_type in self.prms.args[\"feature_group_types_to_show_label\"]:\n                        feature.vis_prms[\"show_label\"] = 1\n                    elif feature.group_type in \\\n                            self.prms.args[\"feature_group_types_to_show_label_on_first_occurrence\"]:\n                        if feature.group not in added_first_occurrence_labels:\n                            feature.vis_prms[\"show_label\"] = 1\n                            added_first_occurrence_labels.append(feature.group)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable define feature labels to be shown.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.find_variable_feature_groups","title":"<code>find_variable_feature_groups(mmseqs_results)</code>","text":"<p>Define feature group type attributes (variable or shell/core) based on their conservation in corresponding     loci group feature.</p> <p>It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues     groups by other method you can also build pandas dataframe based on that with index corresponding to     feature id and column \"cluster\" corresponding to the group.</p> <p>Parameters:</p> <ul> <li> <code>mmseqs_results</code>             (<code>DataFrame</code>)         \u2013          <p>dataframe with feature id - group pairs. Its index column should represent all loci CDS features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def find_variable_feature_groups(self, mmseqs_results: pd.DataFrame) -&gt; None:\n    \"\"\"Define feature group type attributes (variable or shell/core) based on their conservation in corresponding\n        loci group feature.\n\n    It's designed to use as input mmseqs_cluster() function results. However, if you have obtained homologues\n        groups by other method you can also build pandas dataframe based on that with index corresponding to\n        feature id and column \"cluster\" corresponding to the group.\n\n    Arguments:\n          mmseqs_results (pd.DataFrame): dataframe with feature id - group pairs. Its index column should\n            represent all loci CDS features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_clusters_sizes = self.loci_annotation[\"group\"].value_counts()\n        loci_clusters_cutoffs = np.round(self.prms.args[\"CDS_is_variable_cutoff\"] * loci_clusters_sizes).astype(int)\n        loci_clusters_cutoffs[loci_clusters_cutoffs == 0] = 1\n        cluster_types = collections.defaultdict(dict)\n        for cluster in set(mmseqs_results[\"cluster\"].to_list()):\n            cluster_proteins = mmseqs_results[mmseqs_results[\"cluster\"] == cluster].index\n            cluster_loci = [locus for locus in self.loci if\n                            any(feature.feature_id in cluster_proteins for feature in locus.features)]\n            cluster_loci_groups = [locus.group for locus in cluster_loci]\n            for cluster_locus_group in cluster_loci_groups:\n                current_group_cluster_loci = [locus.seq_id for locus in cluster_loci if\n                                              locus.group == cluster_locus_group]\n                current_group_cluster_size = len(set(current_group_cluster_loci))\n                if loci_clusters_sizes[cluster_locus_group] &gt; 1 and \\\n                        current_group_cluster_size &lt;= loci_clusters_cutoffs[cluster_locus_group]:\n                    cluster_types[cluster_locus_group][cluster] = \"variable\"\n                else:\n                    cluster_types[cluster_locus_group][cluster] = \"shell/core\"\n        for locus in self.loci:\n            locus_group = locus.group\n            for feature in locus.features:\n                if feature.group_type and self.prms.args[\"keep_predefined_groups\"]:\n                    continue\n                feature.group_type = cluster_types[locus_group][feature.group]\n                self.feature_annotation.loc[feature.feature_id, \"group_type\"] = feature.group_type\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.get_loci_lengths_and_n_of_regions","title":"<code>get_loci_lengths_and_n_of_regions()</code>","text":"<p>Get loci lengths and number of regions.</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list[list[int]]</code> )        \u2013          <p>list each element of each contains locus size and number of breaks for visualisation track.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def get_loci_lengths_and_n_of_regions(self) -&gt; list[list[int]]:\n    \"\"\"Get loci lengths and number of regions.\n\n    Returns:\n        list: list each element of each contains locus size and number of breaks for visualisation track.\n\n    \"\"\"\n    try:\n        loci_sizes = []\n        for locus in self.loci:\n            number_of_gaps = len(locus.coordinates) - 1\n            if locus.circular:\n                for i in range(number_of_gaps):\n                    if locus.coordinates[i][\"end\"] == locus.length and locus.coordinates[i + 1][\"start\"] == 1:\n                        number_of_gaps -= 1\n            loci_sizes.append([locus.size, number_of_gaps])\n        return loci_sizes\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to get loci lengths.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_features_annotation_file","title":"<code>load_features_annotation_file(file_path)</code>","text":"<p>Load features annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for a features annotation file to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_features_annotation_file(self, file_path: str) -&gt; None:\n    \"\"\"Load features annotation file.\n\n    Arguments:\n        file_path (str): File path for a features annotation file to be loaded.\n\n    Returns:\n        None\n\n    \"\"\"\n    annotation_columns = [\"feature_id\", \"locus_id\", \"coordinates\", \"feature_type\", \"name\", \"group\", \"group_type\",\n                          \"category\", \"fill_color\", \"stroke_color\", \"show_label\"]\n    self.feature_annotation = self.__load_annotation_file(file_path, annotation_columns, \"feature_id\")\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_loci_annotation_file","title":"<code>load_loci_annotation_file(file_path)</code>","text":"<p>Load loci annotation file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>File path for a loci annotation file to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_annotation_file(self, file_path: str) -&gt; None:\n    \"\"\"Load loci annotation file.\n\n    Arguments:\n        file_path (str): File path for a loci annotation file to be loaded.\n\n    Returns:\n        None\n\n    \"\"\"\n    annotation_columns = [\"sequence_id\", \"length\", \"coordinates\", \"circular\", \"description\", \"order\", \"group\"]\n    self.loci_annotation = self.__load_annotation_file(file_path, annotation_columns, \"sequence_id\")\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_loci_from_extended_gff","title":"<code>load_loci_from_extended_gff(input_folder)</code>","text":"<p>Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide     sequence. Such files are produced for example by pharokka annotation tool.</p> <p>All files with extension other than .gff (not case-sensitive) will be ignored.</p> <p>Parameters:</p> <ul> <li> <code>input_folder</code>             (<code>str</code>)         \u2013          <p>folder name with gff files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_from_extended_gff(self, input_folder: str) -&gt; None:\n    \"\"\"Load loci from the folder with gff files. Each GFF file also should contain corresponding nucleotide\n        sequence. Such files are produced for example by pharokka annotation tool.\n\n    All files with extension other than .gff (not case-sensitive) will be ignored.\n\n    Arguments:\n        input_folder: folder name with gff files.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not os.path.exists(input_folder):\n        raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n    try:\n        gff_files = [f for f in os.listdir(input_folder) if os.path.splitext(f)[-1].lower() == \".gff\"]\n        if not gff_files:\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain .gff(.GFF) files.\")\n        for gff_file in gff_files:\n            gff_file_path = os.path.join(input_folder, gff_file)\n            gff_records = list(BCBio.GFF.parse(gff_file_path, limit_info=dict(gff_type=[\"CDS\"])))\n            if len(gff_records) != 1:\n                raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} does not contain information for only\"\n                                                   f\" 1 sequence.\")\n            gff_record = gff_records[0]\n            try:\n                record_locus_sequence = gff_record.seq\n            except Bio.Seq.UndefinedSequenceError as error:\n                raise lovis4u.Manager.lovis4uError(f\"gff file doesn't contain corresponding sequences.\") from error\n            if self.prms.args[\"gff_description_source\"] in gff_record.annotations:\n                record_description = gff_record.annotations[self.prms.args[\"gff_description_source\"]][0]\n                if isinstance(record_description, tuple):\n                    record_description = \" \".join(record_description)\n            else:\n                record_description = \"\"\n\n            self.__update_loci_annotation(gff_record.id, record_description, len(record_locus_sequence))\n            locus_annotation_row = self.loci_annotation.loc[gff_record.id]\n            coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                           locus_annotation_row[\"coordinates\"].split(\",\")]\n            record_locus = Locus(seq_id=gff_record.id, coordinates=coordinates,\n                                 description=locus_annotation_row[\"description\"],\n                                 circular=locus_annotation_row[\"circular\"],\n                                 length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                 order=locus_annotation_row[\"order\"])\n            features_ids = [i.id for i in gff_record.features]\n            if len(features_ids) != len(set(features_ids)):\n                raise lovis4u.Manager.lovis4uError(f\"Gff file {gff_file} contains duplicated feature ids while\"\n                                                   f\" only unique are allowed.\")\n            for gff_feature in gff_record.features:\n                feature_id = gff_feature.id\n                transl_table = self.prms.args[\"default_transl_table\"]\n                if \"transl_table\" in gff_feature.qualifiers.keys():\n                    transl_table = int(gff_feature.qualifiers[\"transl_table\"][0])\n                name = \"\"\n                if self.prms.args[\"gff_CDS_name_source\"] in gff_feature.qualifiers:\n                    name = gff_feature.qualifiers[self.prms.args[\"gff_CDS_name_source\"]][0]\n                category = \"\"\n                if self.prms.args[\"gff_CDS_category_source\"] in gff_feature.qualifiers:\n                    category = \",\".join(gff_feature.qualifiers[self.prms.args[\"gff_CDS_category_source\"]])\n                for coordinate in record_locus.coordinates:\n                    start, end = coordinate[\"start\"], coordinate[\"end\"]\n                    if start &lt;= gff_feature.location.start + 1 &lt;= end or start &lt;= gff_feature.location.end &lt;= end:\n                        self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                         f\"{int(gff_feature.location.start) + 1}:\"\n                                                         f\"{int(gff_feature.location.end)}:{gff_feature.location.strand}\",\n                                                         \"CDS\", category, name)\n                        feature_annotation_row = self.feature_annotation.loc[feature_id]\n                        feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                          feature_id=feature_id, start=int(gff_feature.location.start) + 1,\n                                          end=int(gff_feature.location.end), strand=gff_feature.location.strand,\n                                          name=feature_annotation_row[\"name\"],\n                                          sequence=gff_feature.translate(record_locus_sequence, table=transl_table,\n                                                                         cds=False)[:-1],\n                                          group=feature_annotation_row[\"group\"],\n                                          group_type=feature_annotation_row[\"group_type\"], category=category,\n                                          vis_prms=dict(fill_color=feature_annotation_row[\"fill_color\"],\n                                                        stroke_color=feature_annotation_row[\"stroke_color\"],\n                                                        show_label=feature_annotation_row[\"show_label\"]),\n                                          parameters=self.prms)\n                        record_locus.features.append(feature)\n            self.loci.append(record_locus)\n        seq_id_to_order = self.loci_annotation[\"order\"].to_dict()\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n        if self.prms.args[\"verbose\"]:\n            if len(self.loci) == 1:\n                print(f\"\ud83d\udce5 {len(self.loci)} locus was loaded from extended gff files folder\", file=sys.stdout)\n            else:\n                print(f\"\ud83d\udce5 {len(self.loci)} loci were loaded from extended gff files folder\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gff folder.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.load_loci_from_gb","title":"<code>load_loci_from_gb(input_folder)</code>","text":"<p>Load loci from the folder with genbank files.</p> <p>All files with extension other than .gb (not case-sensitive) will be ignored.</p> <p>Parameters:</p> <ul> <li> <code>input_folder</code>             (<code>str</code>)         \u2013          <p>folder name with gb files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def load_loci_from_gb(self, input_folder: str) -&gt; None:\n    \"\"\"Load loci from the folder with genbank files.\n\n    All files with extension other than .gb (not case-sensitive) will be ignored.\n\n    Arguments:\n        input_folder: folder name with gb files.\n\n    Returns:\n        None\n\n    \"\"\"\n    if not os.path.exists(input_folder):\n        raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not exist.\")\n    try:\n        gb_files = [f for f in os.listdir(input_folder) if os.path.splitext(f)[-1].lower() == \".gb\"]\n        if not gb_files:\n            raise lovis4u.Manager.lovis4uError(f\"Folder {input_folder} does not contain .gb(.GB) files.\")\n        for gb_file in gb_files:\n            gb_file_path = os.path.join(input_folder, gb_file)\n            gb_records = list(Bio.SeqIO.parse(gb_file_path, \"genbank\"))\n            if len(gb_records) != 1:\n                raise lovis4u.Manager.lovis4uError(f\"gb file {gb_file} does not contain information for only\"\n                                                   f\" 1 sequence.\")\n            gb_record = gb_records[0]\n            record_locus_sequence = gb_record.seq\n            if self.prms.args[\"genbank_description_source\"] == \"description\":\n                record_description = gb_record.description\n            elif \"annotations:\" in self.prms.args[\"genbank_description_source\"]:\n                feature_description_key = self.prms.args[\"genbank_description_source\"].split(\":\")[1]\n                record_description = gb_record.annotations[feature_description_key]\n            else:\n                record_description = \"\"\n            self.__update_loci_annotation(gb_record.id, record_description, len(record_locus_sequence))\n            locus_annotation_row = self.loci_annotation.loc[gb_record.id]\n            coordinates = [dict(zip([\"start\", \"end\", \"strand\"], map(int, c.split(\":\")))) for c in\n                           locus_annotation_row[\"coordinates\"].split(\",\")]\n            record_locus = Locus(seq_id=gb_record.id, coordinates=coordinates,\n                                 description=locus_annotation_row[\"description\"],\n                                 circular=locus_annotation_row[\"circular\"],\n                                 length=locus_annotation_row[\"length\"], parameters=self.prms, features=[],\n                                 order=locus_annotation_row[\"order\"])\n\n            gb_CDSs = [i for i in gb_record.features if i.type == \"CDS\"]\n            first_CDS_record = gb_CDSs[0]\n            id_source = self.prms.args[\"genbank_id_source\"]\n            if self.prms.args[\"genbank_id_source\"] not in first_CDS_record.qualifiers:\n                for alternative_id_source in self.prms.args[\"genbank_id_alternative_source\"]:\n                    if alternative_id_source in first_CDS_record.qualifiers:\n                        id_source = alternative_id_source\n                        print(f\"\u2757 Warning: there is no &lt;{self.prms.args['genbank_id_source']}&gt; attribute \"\n                              f\"for CDS records in {gb_file}. Alternative &lt;{id_source}&gt; was used instead.\",\n                              file=sys.stdout)\n                        break\n                if id_source == self.prms.args[\"genbank_id_source\"]:\n                    raise lovis4u.Manager.lovis4uError(f\"There is no &lt;{self.prms.args['genbank_id_source']}&gt; \"\n                                                       f\"attribute for CDS record found in {gb_file}. We tried to\"\n                                                       f\" find any from the alternative list: \"\n                                                       f\"{','.join(self.prms.args['genbank_id_alternative_source'])}\"\n                                                       f\", but they also weren't found.\")  # add about cmd parameter\n            features_ids = [i.qualifiers[id_source][0] for i in gb_CDSs]\n            if len(features_ids) != len(set(features_ids)):\n                raise lovis4u.Manager.lovis4uError(f\"GB file {gb_record} contains duplicated feature ids while\"\n                                                   f\" only unique are allowed.\")\n            for gb_feature in gb_CDSs:\n                feature_id = gb_feature.qualifiers[id_source][0].replace(\"|\", \"_\")\n                transl_table = self.prms.args[\"default_transl_table\"]\n                if \"transl_table\" in gb_feature.qualifiers.keys():\n                    transl_table = int(gb_feature.qualifiers[\"transl_table\"][0])\n                name = \"\"\n                if self.prms.args[\"genbank_CDS_name_source\"] in gb_feature.qualifiers:\n                    name = gb_feature.qualifiers[self.prms.args[\"genbank_CDS_name_source\"]][0]\n                category = \"\"\n                if self.prms.args[\"genbank_CDS_category_source\"] in gb_feature.qualifiers:\n                    category = \",\".join(gb_feature.qualifiers[self.prms.args[\"genbank_CDS_category_source\"]])\n                for coordinate in record_locus.coordinates:\n                    start, end = coordinate[\"start\"], coordinate[\"end\"]\n                    if start &lt;= gb_feature.location.start + 1 &lt;= end or start &lt;= gb_feature.location.end &lt;= end:\n                        self.__update_feature_annotation(feature_id, record_locus.seq_id,\n                                                         f\"{int(gb_feature.location.start) + 1}:\"\n                                                         f\"{int(gb_feature.location.end)}:\"\n                                                         f\"{gb_feature.location.strand}\", \"CDS\", category, name)\n                        feature_annotation_row = self.feature_annotation.loc[feature_id]\n                        feature = Feature(feature_type=feature_annotation_row[\"feature_type\"],\n                                          feature_id=feature_id, start=int(gb_feature.location.start) + 1,\n                                          end=int(gb_feature.location.end),\n                                          strand=gb_feature.location.strand, name=feature_annotation_row[\"name\"],\n                                          sequence=gb_feature.translate(record_locus_sequence, table=transl_table,\n                                                                        cds=False)[:-1],\n                                          group=feature_annotation_row[\"group\"],\n                                          group_type=feature_annotation_row[\"group_type\"], category=category,\n                                          vis_prms=dict(fill_color=feature_annotation_row[\"fill_color\"],\n                                                        stroke_color=feature_annotation_row[\"stroke_color\"],\n                                                        show_label=feature_annotation_row[\"show_label\"]),\n                                          parameters=self.prms)\n\n                        record_locus.features.append(feature)\n            self.loci.append(record_locus)\n        seq_id_to_order = self.loci_annotation[\"order\"].to_dict()\n        self.loci.sort(key=lambda locus: seq_id_to_order[locus.seq_id])\n        if self.prms.args[\"verbose\"]:\n            if len(self.loci) == 1:\n                print(f\"\ud83d\udce5 {len(self.loci)} locus was loaded from genbank files folder\", file=sys.stdout)\n            else:\n                print(f\"\ud83d\udce5 {len(self.loci)} loci were loaded from genbank files folder\", file=sys.stdout)\n\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to load loci from gb folder.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.mmseqs_cluster","title":"<code>mmseqs_cluster()</code>","text":"<p>Cluster all proteins using mmseqs in order to define groups of homologues.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is defined by representative sequence id within a corresponding cluster.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def mmseqs_cluster(self) -&gt; pd.DataFrame:\n    \"\"\"Cluster all proteins using mmseqs in order to define groups of homologues.\n\n    Returns:\n        pd.DataFrame: parsed mmseqs table (pandas dataframe) with columns: cluster, protein_id; where cluster is\n            defined by representative sequence id within a corresponding cluster.\n\n    \"\"\"\n    if self.prms.args[\"verbose\"]:\n        print(f\"\ud83d\ude80 Running mmseqs for protein clustering...\", file=sys.stdout)\n    try:\n        feature_records = [feature.record for locus in self.loci for feature in locus.features]\n        temp_input = tempfile.NamedTemporaryFile()\n        Bio.SeqIO.write(feature_records, temp_input.name, \"fasta\")\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        mmseqs_output_folder = os.path.join(self.prms.args[\"output_dir\"], \"mmseqs\")\n        if os.path.exists(mmseqs_output_folder):\n            shutil.rmtree(mmseqs_output_folder)\n        os.mkdir(mmseqs_output_folder)\n        Bio.SeqIO.write(feature_records, os.path.join(mmseqs_output_folder, \"input_proteins.fa\"), \"fasta\")\n        mmseqs_output_folder_db = os.path.join(mmseqs_output_folder, \"DB\")\n        os.mkdir(mmseqs_output_folder_db)\n        mmseqs_stdout = open(os.path.join(mmseqs_output_folder, \"mmseqs_stdout.txt\"), \"w\")\n        mmseqs_stderr = open(os.path.join(mmseqs_output_folder, \"mmseqs_stderr.txt\"), \"w\")\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createdb\", temp_input.name,\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\")], stdout=mmseqs_stdout,\n                       stderr=mmseqs_stderr)\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"cluster\",\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"tmp\"),\n                        \"--cluster-mode\", str(self.prms.args[\"mmseqs_cluster_mode\"]),\n                        \"--cov-mode\", str(self.prms.args[\"mmseqs_cov_mode\"]),\n                        \"--min-seq-id\", str(self.prms.args[\"mmseqs_min_seq_id\"]),\n                        \"-c\", str(self.prms.args[\"mmseqs_c\"]),\n                        \"-s\", str(self.prms.args[\"mmseqs_s\"])], stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n        subprocess.run([self.prms.args[\"mmseqs_binary\"], \"createtsv\",\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"sequencesDB\"),\n                        os.path.join(mmseqs_output_folder_db, \"clusterDB\"),\n                        os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\")],\n                       stdout=mmseqs_stdout, stderr=mmseqs_stderr)\n        mmseqs_clustering_results = pd.read_table(os.path.join(mmseqs_output_folder, \"mmseqs_clustering.tsv\"),\n                                                  sep=\"\\t\", header=None, names=[\"cluster\", \"protein_id\"])\n        mmseqs_clustering_results = mmseqs_clustering_results.set_index(\"protein_id\")\n\n        num_of_unique_clusters = len(set(mmseqs_clustering_results[\"cluster\"].to_list()))\n        num_of_proteins = len(mmseqs_clustering_results.index)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u2705 {num_of_unique_clusters} clusters for {num_of_proteins} proteins were found with mmseqs\\n\"\n                  f\"\ud83d\udc8c mmseqs clustering results were saved to \"\n                  f\"{os.path.join(mmseqs_output_folder, 'mmseqs_clustering.tsv')}\", file=sys.stdout)\n        return mmseqs_clustering_results\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to run mmseqs clustering.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.reorient_loci","title":"<code>reorient_loci()</code>","text":"<p>Auto re-orient loci (reset strands) of loci if they are not matched.</p> <p>Function tries to maximise co-orientation of homologous features.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def reorient_loci(self) -&gt; None:\n    \"\"\"Auto re-orient loci (reset strands) of loci if they are not matched.\n\n    Function tries to maximise co-orientation of homologous features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_groups = set(self.loci_annotation[\"group\"].to_list())\n        count_of_changed_strands = 0\n        for loci_group in loci_groups:\n            loci = [locus for locus in self.loci if locus.group == loci_group]\n            for locus_index in range(1, len(loci)):\n                p_locus = loci[locus_index - 1]\n                c_locus = loci[locus_index]\n                p_locus_strands = list(set([c[\"strand\"] for c in p_locus.coordinates]))\n                c_locus_strands = list(set([c[\"strand\"] for c in c_locus.coordinates]))\n                if len(p_locus_strands) == 1 and len(c_locus_strands) == 1:\n                    pr_locus_features_groups = set([f.group for f in p_locus.features])\n                    c_locus_features_groups = set([f.group for f in c_locus.features])\n                    overlapped_f_groups = pr_locus_features_groups &amp; c_locus_features_groups\n                    prl_strand, cl_strand = p_locus_strands[0], c_locus_strands[0]\n                    pr_locus_features_strands = {f.group: f.strand * prl_strand for f in p_locus.features if\n                                                 f.group in overlapped_f_groups}\n                    c_locus_features_strands = {f.group: f.strand * cl_strand for f in c_locus.features if\n                                                f.group in overlapped_f_groups}\n                    codirection_score = 0\n                    for ovg in overlapped_f_groups:\n                        codirection_score += pr_locus_features_strands[ovg] * c_locus_features_strands[ovg]\n                    if codirection_score &lt; 0:\n                        count_of_changed_strands += 1\n                        annot_coordinates = []\n                        for cc in loci[locus_index].coordinates:\n                            cc[\"strand\"] *= -1\n                            annot_coordinates.append(f\"{cc['start']}:{cc['end']}:{cc['strand']}\")\n                        self.loci_annotation.loc[c_locus.seq_id, \"coordinates\"] = \",\".join(annot_coordinates)\n                else:\n                    print(\"\u2757 Warning: loci reorientation cannot be applied for loci that have both strands in\"\n                          \" pre-defined coordinates for visualisation\")\n        if self.prms.args[\"verbose\"]:\n            if count_of_changed_strands == 0:\n                print(f\"\ud83d\udd01 Orientation was not changed for any locus\", file=sys.stdout)\n            elif count_of_changed_strands == 1:\n                print(f\"\ud83d\udd01 Orientation was changed for 1 locus\", file=sys.stdout)\n            elif count_of_changed_strands &gt; 1:\n                print(f\"\ud83d\udd01 Orientation was changed for {count_of_changed_strands} loci\", file=sys.stdout)\n\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define variable feature groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.save_features_annotation_table","title":"<code>save_features_annotation_table()</code>","text":"<p>Save feature annotation table to the output folder.</p> <p>Output file name is features_annotation_table.tsv</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def save_features_annotation_table(self) -&gt; None:\n    \"\"\"Save feature annotation table to the output folder.\n\n    Output file name is features_annotation_table.tsv\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"features_annotation_table.tsv\")\n        self.feature_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"feature_id\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\ud83d\udc8c Feature annotation table was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to save feature annotation table.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.save_loci_annotation_table","title":"<code>save_loci_annotation_table()</code>","text":"<p>Save loci annotation table to the output folder.</p> <p>Output file name is loci_annotation_table.tsv</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def save_loci_annotation_table(self) -&gt; None:\n    \"\"\"Save loci annotation table to the output folder.\n\n    Output file name is loci_annotation_table.tsv\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.prms.args[\"output_dir\"]):\n            os.mkdir(self.prms.args[\"output_dir\"])\n        file_path = os.path.join(self.prms.args[\"output_dir\"], \"loci_annotation_table.tsv\")\n        self.loci_annotation.to_csv(file_path, sep=\"\\t\", index_label=\"sequence_id\")\n        if self.prms.args[\"verbose\"]:\n            print(f\"\ud83d\udc8c Loci annotation table was saved to {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to save loci annotation table.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.set_category_colors","title":"<code>set_category_colors(use_table=True)</code>","text":"<p>Define colors for each category.</p> <p>Parameters:</p> <ul> <li> <code>use_table</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Bool value whether table with predefined colors should be used or not.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def set_category_colors(self, use_table: bool = True) -&gt; None:\n    \"\"\"Define colors for each category.\n\n    Arguments:\n        use_table (bool): Bool value whether table with predefined colors should be used or not.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        colors_dict = dict()\n        if use_table:\n            colors_dict.update(\n                pd.read_table(self.prms.args[\"category_colors\"]).set_index(\"category\")[\"color\"].to_dict())\n\n        feature_categories = list(set([feature.category for locus in self.loci for feature in locus.features\n                                       if feature.category and feature.category]))\n        if not feature_categories:\n            print(\"\u2757 Warning: there are no feature categories to set colors\", file=sys.stdout)\n        colors_dict = {cat: col for cat, col in colors_dict.items() if cat in feature_categories}\n\n        feature_categories = [ff for ff in feature_categories if ff not in colors_dict.keys()]\n        number_of_unique_feature_functions = len(feature_categories)\n        colors_rgb = seaborn.color_palette(self.prms.args[\"category_color_seaborn_palette\"],\n                                           number_of_unique_feature_functions,\n                                           desat=self.prms.args[\"category_color_seaborn_desat\"])\n        random.shuffle(colors_rgb)\n        colors = list(map(lambda x: matplotlib.colors.rgb2hex(x), colors_rgb))\n        colors_dict.update({g: c for g, c in zip(list(feature_categories), colors)})\n        for locus in self.loci:\n            locus.category_colors = colors_dict\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to set category colors.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Loci.set_feature_colors_based_on_groups","title":"<code>set_feature_colors_based_on_groups()</code>","text":"<p>Define features fill color based on corresponding feature group and group types.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def set_feature_colors_based_on_groups(self) -&gt; None:\n    \"\"\"Define features fill color based on corresponding feature group and group types.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        feature_groups = set([feature.group for locus in self.loci for feature in locus.features if feature.group])\n        if self.prms.args[\"feature_group_types_to_set_color\"] and \\\n                \"all\" not in self.prms.args[\"feature_group_types_to_set_color\"]:\n            feature_groups = set([feature.group for locus in self.loci for feature in locus.features\n                                  if feature.group and feature.group_type in\n                                  self.prms.args[\"feature_group_types_to_set_color\"]])\n        number_of_unique_feature_groups = len(feature_groups)\n        if self.prms.args[\"groups_fill_color_palette_lib\"] == \"seaborn\":\n            colors_rgb = seaborn.color_palette(self.prms.args[\"groups_fill_color_seaborn_palette\"],\n                                               number_of_unique_feature_groups,\n                                               desat=self.prms.args[\"groups_fill_color_seaborn_desat\"])\n            random.shuffle(colors_rgb)\n        elif self.prms.args[\"groups_fill_color_palette_lib\"] == \"distinctipy\":\n            colors_rgb = distinctipy.get_colors(number_of_unique_feature_groups,\n                                                exclude_colors=[(1, 1, 1), (0, 0, 0)],\n                                                pastel_factor=self.prms.args[\"groups_fill_colors_pastel_factor\"])\n        colors = list(map(lambda x: matplotlib.colors.rgb2hex(x), colors_rgb))\n        colors_dict = {g: c for g, c in zip(list(feature_groups), colors)}\n        for locus in self.loci:\n            for feature in locus.features:\n                if feature.group in feature_groups:\n                    if self.prms.args[\"keep_predefined_colors\"] and feature.vis_prms[\"fill_color\"] != \"default\":\n                        continue\n                    feature.vis_prms[\"fill_color\"] = colors_dict[feature.group]\n                    self.feature_annotation.loc[feature.feature_id, \"fill_color\"] = feature.vis_prms[\"fill_color\"]\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to set feature colors based on groups.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Locus","title":"<code>Locus</code>","text":"<p>A Locus object represents a particular locus that will be one of the sequence tracks on final figure.</p> <p>Attributes:</p> <ul> <li> <code>seq_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier. Can be used to label locus.</p> </li> <li> <code>coordinates</code>             (<code>list</code>)         \u2013          <p>List of regions to be shown. Each region format: dict with keys: start, end, strand and corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>size</code>             (<code>int</code>)         \u2013          <p>total length of regions to be plotted.</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>Sequence description that can be used to label locus.</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>full length of the locus independent on region that should be plotted.</p> </li> <li> <code>circular</code>             (<code>bool</code>)         \u2013          <p>Bool value whether locus is circular or not. It defines whether you have gap or not passing 1 value on the final figure.</p> </li> <li> <code>features</code>             (<code>list</code>)         \u2013          <p>list of Feature objects that overlapped with coordinates.</p> </li> <li> <code>order</code>             (<code>int</code>)         \u2013          <p>index on ordered list of loci visualisation. Can be pre-defined or found based on loci hierarchical clustering with cluster_sequences category.</p> </li> <li> <code>group</code>             (<code>int | str</code>)         \u2013          <p>locus group that defines set of closely-related loci.</p> </li> <li> <code>category_colors</code>             (<code>dict</code>)         \u2013          <p>colors for locus' features categories.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>class Locus:\n    \"\"\"A Locus object represents a particular locus that will be one of the sequence tracks on final figure.\n\n    Attributes:\n        seq_id (str): Sequence identifier. Can be used to label locus.\n        coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n            corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n        size (int): total length of regions to be plotted.\n        description (str): Sequence description that can be used to label locus.\n        length (int): full length of the locus independent on region that should be plotted.\n        circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n            1 value on the final figure.\n        features (list): list of Feature objects that overlapped with coordinates.\n        order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n            hierarchical clustering with cluster_sequences category.\n        group (int | str): locus group that defines set of closely-related loci.\n        category_colors (dict): colors for locus' features categories.\n        prms (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, seq_id: str, coordinates: list, description: str, length: int, circular: bool,\n                 features: list, order: int, parameters: lovis4u.Manager.Parameters, group: typing.Union[int, str] = 1):\n        \"\"\"Create a Locus object.\n\n        Arguments:\n            seq_id (str): Sequence identifier. Can be used to label locus.\n            coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n                corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n            description (str): Sequence description that can be used to label locus.\n            length (int): full length of the locus independent on region that should be plotted.\n            circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n                1 value on the final figure.\n            features (list): list of Feature objects that overlapped with coordinates.\n            order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n            hierarchical clustering with cluster_sequences category.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n            group (int | str): locus group that defines set of closely-related loci [1].\n\n        \"\"\"\n        self.seq_id = seq_id\n        self.coordinates = coordinates\n        self.size = 0\n        taken_coordinates = []\n        for coordinate in coordinates:\n            self.size += abs(coordinate[\"end\"] - coordinate[\"start\"] + 1)\n            taken_coordinates += list(range(coordinate[\"start\"], coordinate[\"end\"] + 1))\n        if len(taken_coordinates) != len(set(taken_coordinates)):\n            raise lovis4u.Manager.lovis4uError(f\"Specified coordinates seems to be overlapped\"\n                                               f\" or not in 0-based format.\")\n        for coordinate in coordinates:\n            if coordinate[\"start\"] &lt; 1:\n                raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is in 0-based format\"\n                                                   f\" while input should be in 1-based.\")\n            if coordinate[\"end\"] &gt; length:\n                raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is out of sequence length\"\n                                                   f\" ({length} nt).\")\n\n        self.description = description\n        self.length = length\n        self.circular = circular\n        self.features = features\n        self.order = order\n        self.group = group\n        self.category_colors = dict()\n        self.prms = parameters\n</code></pre>"},{"location":"API/package_data_processing/#lovis4u.DataProcessing.Locus.__init__","title":"<code>__init__(seq_id, coordinates, description, length, circular, features, order, parameters, group=1)</code>","text":"<p>Create a Locus object.</p> <p>Parameters:</p> <ul> <li> <code>seq_id</code>             (<code>str</code>)         \u2013          <p>Sequence identifier. Can be used to label locus.</p> </li> <li> <code>coordinates</code>             (<code>list</code>)         \u2013          <p>List of regions to be shown. Each region format: dict with keys: start, end, strand and corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>Sequence description that can be used to label locus.</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>full length of the locus independent on region that should be plotted.</p> </li> <li> <code>circular</code>             (<code>bool</code>)         \u2013          <p>Bool value whether locus is circular or not. It defines whether you have gap or not passing 1 value on the final figure.</p> </li> <li> <code>features</code>             (<code>list</code>)         \u2013          <p>list of Feature objects that overlapped with coordinates.</p> </li> <li> <code>order</code>             (<code>int</code>)         \u2013          <p>index on ordered list of loci visualisation. Can be pre-defined or found based on loci</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> <li> <code>group</code>             (<code>int | str</code>, default:                 <code>1</code> )         \u2013          <p>locus group that defines set of closely-related loci [1].</p> </li> </ul> Source code in <code>lovis4u/DataProcessing.py</code> <pre><code>def __init__(self, seq_id: str, coordinates: list, description: str, length: int, circular: bool,\n             features: list, order: int, parameters: lovis4u.Manager.Parameters, group: typing.Union[int, str] = 1):\n    \"\"\"Create a Locus object.\n\n    Arguments:\n        seq_id (str): Sequence identifier. Can be used to label locus.\n        coordinates (list): List of regions to be shown. Each region format: dict with keys: start, end, strand and\n            corresponding 1-based start, end coordinates and strand (1: plus strand, -1: minus strand).\n        description (str): Sequence description that can be used to label locus.\n        length (int): full length of the locus independent on region that should be plotted.\n        circular (bool): Bool value whether locus is circular or not. It defines whether you have gap or not passing\n            1 value on the final figure.\n        features (list): list of Feature objects that overlapped with coordinates.\n        order (int): index on ordered list of loci visualisation. Can be pre-defined or found based on loci\n        hierarchical clustering with cluster_sequences category.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object that holds config and cmd arguments.\n        group (int | str): locus group that defines set of closely-related loci [1].\n\n    \"\"\"\n    self.seq_id = seq_id\n    self.coordinates = coordinates\n    self.size = 0\n    taken_coordinates = []\n    for coordinate in coordinates:\n        self.size += abs(coordinate[\"end\"] - coordinate[\"start\"] + 1)\n        taken_coordinates += list(range(coordinate[\"start\"], coordinate[\"end\"] + 1))\n    if len(taken_coordinates) != len(set(taken_coordinates)):\n        raise lovis4u.Manager.lovis4uError(f\"Specified coordinates seems to be overlapped\"\n                                           f\" or not in 0-based format.\")\n    for coordinate in coordinates:\n        if coordinate[\"start\"] &lt; 1:\n            raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is in 0-based format\"\n                                               f\" while input should be in 1-based.\")\n        if coordinate[\"end\"] &gt; length:\n            raise lovis4u.Manager.lovis4uError(f\"Coordinates for {seq_id}: {coordinate} is out of sequence length\"\n                                               f\" ({length} nt).\")\n\n    self.description = description\n    self.length = length\n    self.circular = circular\n    self.features = features\n    self.order = order\n    self.group = group\n    self.category_colors = dict()\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_drawing/","title":"lovis4u.Drawing","text":"<p>This module provides visualisation of loci annotation.</p>"},{"location":"API/package_drawing/#lovis4u.Drawing.ColorLegendVis","title":"<code>ColorLegendVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>ColorLegend track object that handles visualisation of legend to feature's category colors.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class ColorLegendVis(Track):\n    \"\"\"ColorLegend track object that handles visualisation of legend to feature's category colors.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a ColorLegend object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n        self.track_height = None\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a ColorLegend track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_upper = self.layout[\"current_y_coordinate\"]\n            canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n            canvas.setFont(self.prms.args[\"color_legend_font_face\"],\n                           self.track_data[\"color_legend_label_size\"])\n            for label_dict in self.track_data[\"labels\"]:\n                yl = y_upper + label_dict[\"relative_y\"]\n                yt = y_upper + label_dict[\"relative_y_text\"]\n                canvas.setFillColorRGB(*matplotlib.colors.hex2color(label_dict[\"color\"]),\n                                       self.prms.args[\"category_annotation_alpha\"])\n                canvas.rect(label_dict[\"label_x\"], yl, label_dict[\"label_width\"],\n                            self.track_data[\"line_height\"], fill=1, stroke=0)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"color_legend_label_color\", self.prms))\n                canvas.drawString(label_dict[\"label_x\"], yt, label_dict[\"label\"])\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a color legend track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ColorLegendVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a ColorLegend object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a ColorLegend object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n    self.track_height = None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ColorLegendVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a ColorLegend track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a ColorLegend track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_upper = self.layout[\"current_y_coordinate\"]\n        canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n        canvas.setFont(self.prms.args[\"color_legend_font_face\"],\n                       self.track_data[\"color_legend_label_size\"])\n        for label_dict in self.track_data[\"labels\"]:\n            yl = y_upper + label_dict[\"relative_y\"]\n            yt = y_upper + label_dict[\"relative_y_text\"]\n            canvas.setFillColorRGB(*matplotlib.colors.hex2color(label_dict[\"color\"]),\n                                   self.prms.args[\"category_annotation_alpha\"])\n            canvas.rect(label_dict[\"label_x\"], yl, label_dict[\"label_width\"],\n                        self.track_data[\"line_height\"], fill=1, stroke=0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"color_legend_label_color\", self.prms))\n            canvas.drawString(label_dict[\"label_x\"], yt, label_dict[\"label\"])\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a color legend track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.CrossTrack","title":"<code>CrossTrack</code>","text":"<p>Parent class for Cross-Tracks visualisation.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class CrossTrack:\n    \"\"\"Parent class for Cross-Tracks visualisation.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout, tracks, parameters):\n        \"\"\"Parent's constructor for creating a CrossTrack object.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            tracks (dict): List with track objects participated in CrossTrack.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.layout = layout\n        self.tracks = tracks\n        self.prms = parameters\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas):\n        \"\"\"Empy parent's method for cross track drawing.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.CrossTrack.__init__","title":"<code>__init__(layout, tracks, parameters)</code>","text":"<p>Parent's constructor for creating a CrossTrack object.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout, tracks, parameters):\n    \"\"\"Parent's constructor for creating a CrossTrack object.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.layout = layout\n    self.tracks = tracks\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.CrossTrack.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for cross track drawing.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas):\n    \"\"\"Empy parent's method for cross track drawing.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.HomologyTrack","title":"<code>HomologyTrack</code>","text":"<p>             Bases: <code>CrossTrack</code></p> <p>Track that handle visualisation of homology lines between homologous features on neighbours' loci.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class HomologyTrack(CrossTrack):\n    \"\"\"Track that handle visualisation of homology lines between homologous features on neighbours' loci.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout, tracks, parameters):\n        \"\"\"Create a HomologyTrack.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            tracks (dict): List with track objects participated in CrossTrack.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(layout, tracks, parameters)\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw HomologyTrack on canvas.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for track in self.tracks:\n                track.track_data[\"y_top\"] = self.layout[\"figure_height\"] - track.layout[\"inverse_y_coordinate\"]\n                track.track_data[\"feature_upper\"] = track.track_data[\"y_top\"] - \\\n                                                    (track.track_data[\"n_label_rows\"] * track.track_data[\n                                                        \"f_label_height\"] *\n                                                     (1 + track.prms.args[\"feature_label_gap\"]))\n            num_of_loci_tracks = len(self.tracks)\n            for ti in range(num_of_loci_tracks - 1):\n                current_track = self.tracks[ti]\n                current_track_features = current_track.track_data[\"features\"]\n                next_track = self.tracks[ti + 1]\n                next_track_features = next_track.track_data[\"features\"]\n                for ctf in current_track_features:\n                    ctf_group = ctf[\"group\"]\n                    next_track_same_group_features = [i for i in next_track_features if i[\"group\"] == ctf_group]\n                    for ntf in next_track_same_group_features:\n                        cty_u = current_track.track_data[\"feature_upper\"]\n                        cty_c = current_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * cm\n                        cty_b = current_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * cm\n                        nty_u = next_track.track_data[\"feature_upper\"]\n                        nty_c = next_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * cm\n                        nty_b = next_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * cm\n                        ct_arrow_len = min(\n                            self.prms.args[\"feature_height\"] * cm * self.prms.args[\"feature_arrow_length\"],\n                            (ctf[\"coordinates\"][\"end\"] - ctf[\"coordinates\"][\"start\"]))\n                        nt_arrow_len = min(\n                            self.prms.args[\"feature_height\"] * cm * self.prms.args[\"feature_arrow_length\"],\n                            (ntf[\"coordinates\"][\"end\"] - ntf[\"coordinates\"][\"start\"]))\n                        canvas.setLineCap(0)\n                        canvas.setLineJoin(1)\n                        canvas.setLineWidth(self.prms.args[\"homology_line_width\"])\n                        canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"homology_stroke_color\", self.prms))\n                        canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"homology_fill_color\", self.prms))\n                        p = canvas.beginPath()\n\n                        if ctf[\"coordinates\"][\"orient\"] == 1:\n                            cts, cte = ctf[\"coordinates\"][\"start\"], ctf[\"coordinates\"][\"end\"]\n                            p.moveTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                            if not ctf[\"coordinates\"][\"rout\"]:\n                                p.lineTo(ctf[\"coordinates\"][\"end\"] - ct_arrow_len, cty_b)\n                                p.lineTo(ctf[\"coordinates\"][\"end\"], cty_c)\n                            else:\n                                p.lineTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                        elif ctf[\"coordinates\"][\"orient\"] == -1:\n                            cts, cte = ctf[\"coordinates\"][\"end\"], ctf[\"coordinates\"][\"start\"]\n                            p.moveTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                            if not ctf[\"coordinates\"][\"lout\"]:\n                                p.lineTo(ctf[\"coordinates\"][\"start\"] + ct_arrow_len, cty_b)\n                                p.lineTo(ctf[\"coordinates\"][\"start\"], cty_c)\n                            else:\n                                p.lineTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                        if ntf[\"coordinates\"][\"orient\"] == 1:\n                            nts, nte = ntf[\"coordinates\"][\"end\"], ntf[\"coordinates\"][\"start\"]\n                            if not ntf[\"coordinates\"][\"rout\"]:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                                p.lineTo(ntf[\"coordinates\"][\"end\"] - nt_arrow_len, nty_u)\n                            else:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                            if nte &gt;= cts:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                        elif ntf[\"coordinates\"][\"orient\"] == -1:\n                            nts, nte = ntf[\"coordinates\"][\"start\"], ntf[\"coordinates\"][\"end\"]\n                            if not ntf[\"coordinates\"][\"lout\"]:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                                p.lineTo(ntf[\"coordinates\"][\"start\"] + nt_arrow_len, nty_u)\n                            else:\n                                p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                            if nte &lt;= cts:\n                                p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                        if (nte &lt;= cts and ctf[\"coordinates\"][\"orient\"] == 1) or (\n                                nte &gt;= cts and ctf[\"coordinates\"][\"orient\"] == -1):\n                            p.lineTo(cts, cty_c)\n                        p.lineTo(cts, cty_b)\n                        canvas.drawPath(p, stroke=1, fill=1)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw homology line track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.HomologyTrack.__init__","title":"<code>__init__(layout, tracks, parameters)</code>","text":"<p>Create a HomologyTrack.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>tracks</code>             (<code>dict</code>)         \u2013          <p>List with track objects participated in CrossTrack.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout, tracks, parameters):\n    \"\"\"Create a HomologyTrack.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        tracks (dict): List with track objects participated in CrossTrack.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(layout, tracks, parameters)\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.HomologyTrack.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw HomologyTrack on canvas.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw HomologyTrack on canvas.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for track in self.tracks:\n            track.track_data[\"y_top\"] = self.layout[\"figure_height\"] - track.layout[\"inverse_y_coordinate\"]\n            track.track_data[\"feature_upper\"] = track.track_data[\"y_top\"] - \\\n                                                (track.track_data[\"n_label_rows\"] * track.track_data[\n                                                    \"f_label_height\"] *\n                                                 (1 + track.prms.args[\"feature_label_gap\"]))\n        num_of_loci_tracks = len(self.tracks)\n        for ti in range(num_of_loci_tracks - 1):\n            current_track = self.tracks[ti]\n            current_track_features = current_track.track_data[\"features\"]\n            next_track = self.tracks[ti + 1]\n            next_track_features = next_track.track_data[\"features\"]\n            for ctf in current_track_features:\n                ctf_group = ctf[\"group\"]\n                next_track_same_group_features = [i for i in next_track_features if i[\"group\"] == ctf_group]\n                for ntf in next_track_same_group_features:\n                    cty_u = current_track.track_data[\"feature_upper\"]\n                    cty_c = current_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * cm\n                    cty_b = current_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * cm\n                    nty_u = next_track.track_data[\"feature_upper\"]\n                    nty_c = next_track.track_data[\"feature_upper\"] - 0.5 * self.prms.args[\"feature_height\"] * cm\n                    nty_b = next_track.track_data[\"feature_upper\"] - self.prms.args[\"feature_height\"] * cm\n                    ct_arrow_len = min(\n                        self.prms.args[\"feature_height\"] * cm * self.prms.args[\"feature_arrow_length\"],\n                        (ctf[\"coordinates\"][\"end\"] - ctf[\"coordinates\"][\"start\"]))\n                    nt_arrow_len = min(\n                        self.prms.args[\"feature_height\"] * cm * self.prms.args[\"feature_arrow_length\"],\n                        (ntf[\"coordinates\"][\"end\"] - ntf[\"coordinates\"][\"start\"]))\n                    canvas.setLineCap(0)\n                    canvas.setLineJoin(1)\n                    canvas.setLineWidth(self.prms.args[\"homology_line_width\"])\n                    canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"homology_stroke_color\", self.prms))\n                    canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"homology_fill_color\", self.prms))\n                    p = canvas.beginPath()\n\n                    if ctf[\"coordinates\"][\"orient\"] == 1:\n                        cts, cte = ctf[\"coordinates\"][\"start\"], ctf[\"coordinates\"][\"end\"]\n                        p.moveTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                        if not ctf[\"coordinates\"][\"rout\"]:\n                            p.lineTo(ctf[\"coordinates\"][\"end\"] - ct_arrow_len, cty_b)\n                            p.lineTo(ctf[\"coordinates\"][\"end\"], cty_c)\n                        else:\n                            p.lineTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                    elif ctf[\"coordinates\"][\"orient\"] == -1:\n                        cts, cte = ctf[\"coordinates\"][\"end\"], ctf[\"coordinates\"][\"start\"]\n                        p.moveTo(ctf[\"coordinates\"][\"end\"], cty_b)\n                        if not ctf[\"coordinates\"][\"lout\"]:\n                            p.lineTo(ctf[\"coordinates\"][\"start\"] + ct_arrow_len, cty_b)\n                            p.lineTo(ctf[\"coordinates\"][\"start\"], cty_c)\n                        else:\n                            p.lineTo(ctf[\"coordinates\"][\"start\"], cty_b)\n                    if ntf[\"coordinates\"][\"orient\"] == 1:\n                        nts, nte = ntf[\"coordinates\"][\"end\"], ntf[\"coordinates\"][\"start\"]\n                        if not ntf[\"coordinates\"][\"rout\"]:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                            p.lineTo(ntf[\"coordinates\"][\"end\"] - nt_arrow_len, nty_u)\n                        else:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                        p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                        if nte &gt;= cts:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                    elif ntf[\"coordinates\"][\"orient\"] == -1:\n                        nts, nte = ntf[\"coordinates\"][\"start\"], ntf[\"coordinates\"][\"end\"]\n                        if not ntf[\"coordinates\"][\"lout\"]:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_c)\n                            p.lineTo(ntf[\"coordinates\"][\"start\"] + nt_arrow_len, nty_u)\n                        else:\n                            p.lineTo(ntf[\"coordinates\"][\"start\"], nty_u)\n                        p.lineTo(ntf[\"coordinates\"][\"end\"], nty_u)\n                        if nte &lt;= cts:\n                            p.lineTo(ntf[\"coordinates\"][\"end\"], nty_c)\n                    if (nte &lt;= cts and ctf[\"coordinates\"][\"orient\"] == 1) or (\n                            nte &gt;= cts and ctf[\"coordinates\"][\"orient\"] == -1):\n                        p.lineTo(cts, cty_c)\n                    p.lineTo(cts, cty_b)\n                    canvas.drawPath(p, stroke=1, fill=1)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw homology line track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis","title":"<code>LocusVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>LocusVis track object that handles each locus visualisation.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class LocusVis(Track):\n    \"\"\"LocusVis track object that handles each locus visualisation.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a LocusVis object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a LocusVis track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            feature_height = self.prms.args[\"feature_height\"] * cm\n            y_feature_upper = self.layout[\"current_y_coordinate\"] - (self.track_data[\"n_label_rows\"] *\n                                                                     self.track_data[\"f_label_height\"] *\n                                                                     (1 + self.prms.args[\"feature_label_gap\"]))\n            y_feature_bottom = y_feature_upper - feature_height\n            y_feature_center = y_feature_upper - feature_height * 0.5\n\n            # Sequence label\n            canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"locus_label_color\", self.prms))\n            canvas.setFont(self.prms.args[\"locus_label_description_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            if self.prms.args[\"locus_label_style\"] == \"full\" and len(self.track_data[\"locus_label\"]) == 2:\n                label_bottom = y_feature_upper - self.prms.args[\"locus_label_height\"]\n                canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                       self.track_data[\"locus_label\"][1])\n                label_bottom = y_feature_bottom\n            else:\n                label_bottom = y_feature_bottom + (feature_height - self.prms.args[\"locus_label_height\"]) * 0.5\n            if self.prms.args[\"locus_label_style\"] != \"description\":\n                canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n            canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                   self.track_data[\"locus_label\"][0])\n\n            # Middle line\n            if self.prms.args[\"draw_middle_line\"]:\n                canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n                canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n                canvas.setLineCap(0)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n                p = canvas.beginPath()\n                for md_line_coordinates in self.track_data[\"middle_line_coordinates\"]:\n                    p.moveTo(md_line_coordinates[\"start\"], y_feature_center)\n                    p.lineTo(md_line_coordinates[\"end\"], y_feature_center)\n                canvas.drawPath(p, stroke=1, fill=0)\n\n            # Category annotation\n            if self.track_data[\"functions_coordinates\"]:\n                for feature_function, ff_region in self.track_data[\"functions_coordinates\"].items():\n                    feature_color = self.track_data[\"category_colors\"][feature_function]\n                    canvas.setFillColorRGB(*matplotlib.colors.hex2color(feature_color),\n                                           self.prms.args[\"category_annotation_alpha\"])\n                    canvas.setLineJoin(1)\n                    y_upper_sausage = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * cm\n                    y_bottom_sausage = y_upper_sausage - self.prms.args[\"category_annotation_line_width\"] * cm\n                    for ffr in ff_region:\n                        p = canvas.beginPath()\n                        p.moveTo(ffr[0], y_bottom_sausage)\n                        p.lineTo(ffr[0], y_upper_sausage)\n                        p.lineTo(ffr[1], y_upper_sausage)\n                        p.lineTo(ffr[1], y_bottom_sausage)\n                        p.lineTo(ffr[0], y_bottom_sausage)\n                        p.close()\n                        canvas.drawPath(p, stroke=0, fill=1)\n            # Features\n            canvas.setLineCap(0)\n            canvas.setLineJoin(1)\n            canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n            if self.track_data[\"clean_features_coordinates\"]:\n                for f_data in self.track_data[\"features\"]:\n                    f_data_copy = copy.deepcopy(f_data)\n                    f_data_copy[\"stroke_color\"] = None\n                    f_data_copy[\"fill_color\"] = (*matplotlib.colors.hex2color(self.prms.args[\"palette\"][\"white\"]), 1)\n                    self.__plot_cds_feature(canvas, f_data_copy, y_center=y_feature_center, height=feature_height)\n            for f_data in self.track_data[\"features\"]:\n                f_data[\"stroke_color\"] = *matplotlib.colors.hex2color(f_data[\"stroke_color\"]), self.prms.args[\n                    \"feature_stroke_color_alpha\"]\n                f_data[\"fill_color\"] = *matplotlib.colors.hex2color(f_data[\"fill_color\"]), self.prms.args[\n                    \"feature_fill_color_alpha\"]\n                self.__plot_cds_feature(canvas, f_data, y_center=y_feature_center, height=feature_height)\n                if f_data[\"label_width\"]:\n                    canvas.setFillColorRGB(*f_data[\"stroke_color\"])\n                    canvas.setFont(self.prms.args[\"feature_label_font_face\"],\n                                   self.track_data[\"f_label_font_size\"])\n                    fx_center = f_data[\"coordinates\"][\"center\"]\n                    canvas.drawString(f_data[\"label_position\"][0], f_data[\"label_y_bottom\"] + y_feature_upper,\n                                      f_data[\"label\"])\n                    canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n                    underline_color = f_data[\"stroke_color\"]\n                    canvas.setStrokeColorRGB(*underline_color)\n                    canvas.setLineCap(1)\n                    if f_data[\"label_row\"] &gt; 0:\n                        p = canvas.beginPath()\n                        for ls, le in f_data[\"label_line_coordinates\"]:\n                            p.moveTo(fx_center, ls + y_feature_upper)\n                            p.lineTo(fx_center, le + y_feature_upper)\n                        canvas.drawPath(p, stroke=1, fill=0)\n                    else:\n                        overlapping = min(f_data[\"coordinates\"][\"end\"], f_data[\"label_position\"][1]) - (\n                            max(f_data[\"coordinates\"][\"start\"], f_data[\"label_position\"][0]))\n                        if overlapping / (f_data[\"label_position\"][1] - f_data[\"label_position\"][0]) &lt; 0.5:\n                            l_start = max(f_data[\"coordinates\"][\"start\"], fx_center -\n                                          self.track_data[\"feature_label_gap\"])\n                            l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                            ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                            canvas.line(l_start, ly, l_end, ly)\n            # Axis ticks\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n                canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n                canvas.setLineCap(1)\n                canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n                canvas.setFont(self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                               self.track_data[\"x_axis_annotation\"][\"label_size\"])\n                axis_line_y_coordinate = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * cm\n                axis_tick_height = self.prms.args[\"x_axis_ticks_height\"] * cm\n                axis_tick_label_y_coordinate = axis_line_y_coordinate - self.prms.args[\"x_axis_ticks_height\"] * \\\n                                               1.3 * cm - self.prms.args[\"x_axis_ticks_labels_height\"] * cm\n                for ati in range(len(self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"])):\n                    tick_coordinate = self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"][ati]\n                    tick_label_position = self.track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"][ati]\n                    tick_label = self.track_data[\"x_axis_annotation\"][\"axis_tics_labels\"][ati]\n                    canvas.drawCentredString(tick_label_position, axis_tick_label_y_coordinate, tick_label)\n                    canvas.line(tick_coordinate, axis_line_y_coordinate, tick_coordinate,\n                                axis_line_y_coordinate - axis_tick_height)\n                for region in self.track_data[\"x_axis_annotation\"][\"axis_regions\"]:\n                    canvas.setLineCap(0)\n                    canvas.line(region[\"start\"], axis_line_y_coordinate, region[\"end\"], axis_line_y_coordinate)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a Locus track.\") from error\n\n    def __plot_cds_feature(self, canvas: reportlab.pdfgen.canvas.Canvas, feature_data: dict, y_center: float,\n                           height: float) -&gt; None:\n        \"\"\"Helper method to plot feature polygone\n\n        Returns:\n            None\n\n        \"\"\"\n        x_start = feature_data[\"coordinates\"][\"start\"]\n        x_end = feature_data[\"coordinates\"][\"end\"]\n        orientation = feature_data[\"coordinates\"][\"orient\"]\n        left_out = feature_data[\"coordinates\"][\"lout\"]\n        right_out = feature_data[\"coordinates\"][\"rout\"]\n        fill_color = feature_data[\"fill_color\"]\n        stroke_color = feature_data[\"stroke_color\"]\n        y_center = y_center\n        height = height\n\n        canvas.setLineCap(0)\n        canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n        arrow_length = min(height * self.prms.args[\"feature_arrow_length\"], (x_end - x_start))\n        p = canvas.beginPath()\n        if orientation == 1:\n            if right_out:\n                p.moveTo(x_end, y_center - height / 2)\n                p.lineTo(x_start, y_center - height / 2)\n                p.lineTo(x_start, y_center + height / 2)\n                p.lineTo(x_end, y_center + height / 2)\n            else:\n                p.moveTo(x_start, y_center + height / 2)\n                p.lineTo(x_end - arrow_length, y_center + height / 2)\n                p.lineTo(x_end, y_center)\n                p.lineTo(x_end - arrow_length, y_center - height / 2)\n                p.lineTo(x_start, y_center - height / 2)\n                if not left_out:\n                    p.lineTo(x_start, y_center + height / 2)\n        elif orientation == -1:\n            if left_out:\n                p.moveTo(x_start, y_center - height / 2)\n                p.lineTo(x_end, y_center - height / 2)\n                p.lineTo(x_end, y_center + height / 2)\n                p.lineTo(x_start, y_center + height / 2)\n            else:\n                p.moveTo(x_end, y_center + height / 2)\n                p.lineTo(x_start + arrow_length, y_center + height / 2)\n                p.lineTo(x_start, y_center)\n                p.lineTo(x_start + arrow_length, y_center - height / 2)\n                p.lineTo(x_end, y_center - height / 2)\n                if not right_out:\n                    p.lineTo(x_end, y_center + height / 2)\n        if left_out and right_out:\n            p.moveTo(x_start, y_center + height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n            p.moveTo(x_start, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n        if not left_out and not right_out:\n            p.close()\n        stroke, fill = 0, 0\n        if stroke_color:\n            canvas.setStrokeColorRGB(*stroke_color)\n            stroke = 1\n        if fill_color:\n            canvas.setFillColorRGB(*fill_color)\n            fill = 1\n        canvas.drawPath(p, stroke=stroke, fill=fill)\n        return None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a LocusVis object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a LocusVis object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis.__plot_cds_feature","title":"<code>__plot_cds_feature(canvas, feature_data, y_center, height)</code>","text":"<p>Helper method to plot feature polygone</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __plot_cds_feature(self, canvas: reportlab.pdfgen.canvas.Canvas, feature_data: dict, y_center: float,\n                       height: float) -&gt; None:\n    \"\"\"Helper method to plot feature polygone\n\n    Returns:\n        None\n\n    \"\"\"\n    x_start = feature_data[\"coordinates\"][\"start\"]\n    x_end = feature_data[\"coordinates\"][\"end\"]\n    orientation = feature_data[\"coordinates\"][\"orient\"]\n    left_out = feature_data[\"coordinates\"][\"lout\"]\n    right_out = feature_data[\"coordinates\"][\"rout\"]\n    fill_color = feature_data[\"fill_color\"]\n    stroke_color = feature_data[\"stroke_color\"]\n    y_center = y_center\n    height = height\n\n    canvas.setLineCap(0)\n    canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n    arrow_length = min(height * self.prms.args[\"feature_arrow_length\"], (x_end - x_start))\n    p = canvas.beginPath()\n    if orientation == 1:\n        if right_out:\n            p.moveTo(x_end, y_center - height / 2)\n            p.lineTo(x_start, y_center - height / 2)\n            p.lineTo(x_start, y_center + height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n        else:\n            p.moveTo(x_start, y_center + height / 2)\n            p.lineTo(x_end - arrow_length, y_center + height / 2)\n            p.lineTo(x_end, y_center)\n            p.lineTo(x_end - arrow_length, y_center - height / 2)\n            p.lineTo(x_start, y_center - height / 2)\n            if not left_out:\n                p.lineTo(x_start, y_center + height / 2)\n    elif orientation == -1:\n        if left_out:\n            p.moveTo(x_start, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n            p.lineTo(x_end, y_center + height / 2)\n            p.lineTo(x_start, y_center + height / 2)\n        else:\n            p.moveTo(x_end, y_center + height / 2)\n            p.lineTo(x_start + arrow_length, y_center + height / 2)\n            p.lineTo(x_start, y_center)\n            p.lineTo(x_start + arrow_length, y_center - height / 2)\n            p.lineTo(x_end, y_center - height / 2)\n            if not right_out:\n                p.lineTo(x_end, y_center + height / 2)\n    if left_out and right_out:\n        p.moveTo(x_start, y_center + height / 2)\n        p.lineTo(x_end, y_center + height / 2)\n        p.moveTo(x_start, y_center - height / 2)\n        p.lineTo(x_end, y_center - height / 2)\n    if not left_out and not right_out:\n        p.close()\n    stroke, fill = 0, 0\n    if stroke_color:\n        canvas.setStrokeColorRGB(*stroke_color)\n        stroke = 1\n    if fill_color:\n        canvas.setFillColorRGB(*fill_color)\n        fill = 1\n    canvas.drawPath(p, stroke=stroke, fill=fill)\n    return None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.LocusVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a LocusVis track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a LocusVis track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        feature_height = self.prms.args[\"feature_height\"] * cm\n        y_feature_upper = self.layout[\"current_y_coordinate\"] - (self.track_data[\"n_label_rows\"] *\n                                                                 self.track_data[\"f_label_height\"] *\n                                                                 (1 + self.prms.args[\"feature_label_gap\"]))\n        y_feature_bottom = y_feature_upper - feature_height\n        y_feature_center = y_feature_upper - feature_height * 0.5\n\n        # Sequence label\n        canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"locus_label_color\", self.prms))\n        canvas.setFont(self.prms.args[\"locus_label_description_font_face\"], self.prms.args[\"locus_label_font_size\"])\n        if self.prms.args[\"locus_label_style\"] == \"full\" and len(self.track_data[\"locus_label\"]) == 2:\n            label_bottom = y_feature_upper - self.prms.args[\"locus_label_height\"]\n            canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                                   self.track_data[\"locus_label\"][1])\n            label_bottom = y_feature_bottom\n        else:\n            label_bottom = y_feature_bottom + (feature_height - self.prms.args[\"locus_label_height\"]) * 0.5\n        if self.prms.args[\"locus_label_style\"] != \"description\":\n            canvas.setFont(self.prms.args[\"locus_label_id_font_face\"], self.prms.args[\"locus_label_font_size\"])\n        canvas.drawRightString(self.layout[\"locus_label_right_border\"], label_bottom,\n                               self.track_data[\"locus_label\"][0])\n\n        # Middle line\n        if self.prms.args[\"draw_middle_line\"]:\n            canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n            canvas.setLineCap(0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n            p = canvas.beginPath()\n            for md_line_coordinates in self.track_data[\"middle_line_coordinates\"]:\n                p.moveTo(md_line_coordinates[\"start\"], y_feature_center)\n                p.lineTo(md_line_coordinates[\"end\"], y_feature_center)\n            canvas.drawPath(p, stroke=1, fill=0)\n\n        # Category annotation\n        if self.track_data[\"functions_coordinates\"]:\n            for feature_function, ff_region in self.track_data[\"functions_coordinates\"].items():\n                feature_color = self.track_data[\"category_colors\"][feature_function]\n                canvas.setFillColorRGB(*matplotlib.colors.hex2color(feature_color),\n                                       self.prms.args[\"category_annotation_alpha\"])\n                canvas.setLineJoin(1)\n                y_upper_sausage = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * cm\n                y_bottom_sausage = y_upper_sausage - self.prms.args[\"category_annotation_line_width\"] * cm\n                for ffr in ff_region:\n                    p = canvas.beginPath()\n                    p.moveTo(ffr[0], y_bottom_sausage)\n                    p.lineTo(ffr[0], y_upper_sausage)\n                    p.lineTo(ffr[1], y_upper_sausage)\n                    p.lineTo(ffr[1], y_bottom_sausage)\n                    p.lineTo(ffr[0], y_bottom_sausage)\n                    p.close()\n                    canvas.drawPath(p, stroke=0, fill=1)\n        # Features\n        canvas.setLineCap(0)\n        canvas.setLineJoin(1)\n        canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n        if self.track_data[\"clean_features_coordinates\"]:\n            for f_data in self.track_data[\"features\"]:\n                f_data_copy = copy.deepcopy(f_data)\n                f_data_copy[\"stroke_color\"] = None\n                f_data_copy[\"fill_color\"] = (*matplotlib.colors.hex2color(self.prms.args[\"palette\"][\"white\"]), 1)\n                self.__plot_cds_feature(canvas, f_data_copy, y_center=y_feature_center, height=feature_height)\n        for f_data in self.track_data[\"features\"]:\n            f_data[\"stroke_color\"] = *matplotlib.colors.hex2color(f_data[\"stroke_color\"]), self.prms.args[\n                \"feature_stroke_color_alpha\"]\n            f_data[\"fill_color\"] = *matplotlib.colors.hex2color(f_data[\"fill_color\"]), self.prms.args[\n                \"feature_fill_color_alpha\"]\n            self.__plot_cds_feature(canvas, f_data, y_center=y_feature_center, height=feature_height)\n            if f_data[\"label_width\"]:\n                canvas.setFillColorRGB(*f_data[\"stroke_color\"])\n                canvas.setFont(self.prms.args[\"feature_label_font_face\"],\n                               self.track_data[\"f_label_font_size\"])\n                fx_center = f_data[\"coordinates\"][\"center\"]\n                canvas.drawString(f_data[\"label_position\"][0], f_data[\"label_y_bottom\"] + y_feature_upper,\n                                  f_data[\"label\"])\n                canvas.setLineWidth(self.prms.args[\"feature_stroke_width\"])\n                underline_color = f_data[\"stroke_color\"]\n                canvas.setStrokeColorRGB(*underline_color)\n                canvas.setLineCap(1)\n                if f_data[\"label_row\"] &gt; 0:\n                    p = canvas.beginPath()\n                    for ls, le in f_data[\"label_line_coordinates\"]:\n                        p.moveTo(fx_center, ls + y_feature_upper)\n                        p.lineTo(fx_center, le + y_feature_upper)\n                    canvas.drawPath(p, stroke=1, fill=0)\n                else:\n                    overlapping = min(f_data[\"coordinates\"][\"end\"], f_data[\"label_position\"][1]) - (\n                        max(f_data[\"coordinates\"][\"start\"], f_data[\"label_position\"][0]))\n                    if overlapping / (f_data[\"label_position\"][1] - f_data[\"label_position\"][0]) &lt; 0.5:\n                        l_start = max(f_data[\"coordinates\"][\"start\"], fx_center -\n                                      self.track_data[\"feature_label_gap\"])\n                        l_end = min(f_data[\"coordinates\"][\"end\"], fx_center + self.track_data[\"feature_label_gap\"])\n                        ly = y_feature_upper + f_data[\"label_y_bottom\"] - self.track_data[\"feature_label_gap\"] * 0.5\n                        canvas.line(l_start, ly, l_end, ly)\n        # Axis ticks\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            canvas.setLineWidth(self.prms.args[\"x_axis_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n            canvas.setLineCap(1)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"x_axis_line_color\", self.prms))\n            canvas.setFont(self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                           self.track_data[\"x_axis_annotation\"][\"label_size\"])\n            axis_line_y_coordinate = y_feature_bottom - self.prms.args[\"feature_bottom_gap\"] * cm\n            axis_tick_height = self.prms.args[\"x_axis_ticks_height\"] * cm\n            axis_tick_label_y_coordinate = axis_line_y_coordinate - self.prms.args[\"x_axis_ticks_height\"] * \\\n                                           1.3 * cm - self.prms.args[\"x_axis_ticks_labels_height\"] * cm\n            for ati in range(len(self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"])):\n                tick_coordinate = self.track_data[\"x_axis_annotation\"][\"axis_tics_position\"][ati]\n                tick_label_position = self.track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"][ati]\n                tick_label = self.track_data[\"x_axis_annotation\"][\"axis_tics_labels\"][ati]\n                canvas.drawCentredString(tick_label_position, axis_tick_label_y_coordinate, tick_label)\n                canvas.line(tick_coordinate, axis_line_y_coordinate, tick_coordinate,\n                            axis_line_y_coordinate - axis_tick_height)\n            for region in self.track_data[\"x_axis_annotation\"][\"axis_regions\"]:\n                canvas.setLineCap(0)\n                canvas.line(region[\"start\"], axis_line_y_coordinate, region[\"end\"], axis_line_y_coordinate)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a Locus track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ScaleVis","title":"<code>ScaleVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>ScaleVis track object that handles visualisation of scale bottom line.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class ScaleVis(Track):\n    \"\"\"ScaleVis track object that handles visualisation of scale bottom line.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters):\n        \"\"\"Create a LocusVis object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n        \"\"\"\n        super().__init__(layout, track_data, parameters)\n        self.track_height = None\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a ScaleVis track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            y_upper = self.layout[\"current_y_coordinate\"]\n            y_bottom = self.layout[\"current_y_coordinate\"] - self.track_data[\"track_height\"]\n            y_center = self.layout[\"current_y_coordinate\"] - 0.5 * self.track_data[\"track_height\"]\n\n            middle_line_x_position = np.mean(self.track_data[\"coordinates\"])\n\n            canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n            canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"scale_line_color\", self.prms))\n            canvas.setLineCap(0)\n            canvas.setLineJoin(1)\n            if self.track_data[\"style\"] == \"fancy\":\n                tick_height = self.prms.args[\"scale_line_label_height\"] * cm * 0.7\n\n                p = canvas.beginPath()\n                p.moveTo(self.track_data[\"coordinates\"][0], y_center - 0.5 * tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][0], y_center + 0.5 * tick_height)\n                p.moveTo(self.track_data[\"coordinates\"][0], y_center)\n                p.lineTo(middle_line_x_position - 0.5 * self.track_data[\"scale_line_label_width\"] -\n                         self.track_data[\"space_width\"], y_center)\n                p.moveTo(self.track_data[\"coordinates\"][1], y_center - 0.5 * tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_center + 0.5 * tick_height)\n                p.moveTo(self.track_data[\"coordinates\"][1], y_center)\n                p.lineTo(middle_line_x_position + 0.5 * self.track_data[\"scale_line_label_width\"] +\n                         self.track_data[\"space_width\"], y_center)\n            else:\n                tick_height = self.prms.args[\"scale_line_tics_height\"] * cm\n\n                p = canvas.beginPath()\n                p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height)\n                p.lineTo(self.track_data[\"coordinates\"][0], y_upper)\n                p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height * 0.5)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height * 0.5)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper)\n                p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height)\n            canvas.drawPath(p, stroke=1, fill=0)\n            canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"scale_line_color\", self.prms))\n            canvas.setFont(self.prms.args[\"scale_line_label_font_face\"],\n                           self.track_data[\"scale_label_font_size\"])\n            canvas.drawCentredString(middle_line_x_position, y_bottom, self.track_data[\"scale_label\"])\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to draw a scale track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ScaleVis.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Create a LocusVis object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters):\n    \"\"\"Create a LocusVis object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n\n    \"\"\"\n    super().__init__(layout, track_data, parameters)\n    self.track_height = None\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.ScaleVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a ScaleVis track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a ScaleVis track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        y_upper = self.layout[\"current_y_coordinate\"]\n        y_bottom = self.layout[\"current_y_coordinate\"] - self.track_data[\"track_height\"]\n        y_center = self.layout[\"current_y_coordinate\"] - 0.5 * self.track_data[\"track_height\"]\n\n        middle_line_x_position = np.mean(self.track_data[\"coordinates\"])\n\n        canvas.setLineWidth(self.prms.args[\"scale_line_width\"])\n        canvas.setStrokeColorRGB(*lovis4u.Methods.get_color_rgba(\"scale_line_color\", self.prms))\n        canvas.setLineCap(0)\n        canvas.setLineJoin(1)\n        if self.track_data[\"style\"] == \"fancy\":\n            tick_height = self.prms.args[\"scale_line_label_height\"] * cm * 0.7\n\n            p = canvas.beginPath()\n            p.moveTo(self.track_data[\"coordinates\"][0], y_center - 0.5 * tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][0], y_center + 0.5 * tick_height)\n            p.moveTo(self.track_data[\"coordinates\"][0], y_center)\n            p.lineTo(middle_line_x_position - 0.5 * self.track_data[\"scale_line_label_width\"] -\n                     self.track_data[\"space_width\"], y_center)\n            p.moveTo(self.track_data[\"coordinates\"][1], y_center - 0.5 * tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_center + 0.5 * tick_height)\n            p.moveTo(self.track_data[\"coordinates\"][1], y_center)\n            p.lineTo(middle_line_x_position + 0.5 * self.track_data[\"scale_line_label_width\"] +\n                     self.track_data[\"space_width\"], y_center)\n        else:\n            tick_height = self.prms.args[\"scale_line_tics_height\"] * cm\n\n            p = canvas.beginPath()\n            p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height)\n            p.lineTo(self.track_data[\"coordinates\"][0], y_upper)\n            p.moveTo(self.track_data[\"coordinates\"][0], y_upper - tick_height * 0.5)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height * 0.5)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper)\n            p.lineTo(self.track_data[\"coordinates\"][1], y_upper - tick_height)\n        canvas.drawPath(p, stroke=1, fill=0)\n        canvas.setFillColorRGB(*lovis4u.Methods.get_color_rgba(\"scale_line_color\", self.prms))\n        canvas.setFont(self.prms.args[\"scale_line_label_font_face\"],\n                       self.track_data[\"scale_label_font_size\"])\n        canvas.drawCentredString(middle_line_x_position, y_bottom, self.track_data[\"scale_label\"])\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to draw a scale track.\") from error\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.Track","title":"<code>Track</code>","text":"<p>Parent class for visualisation Tracks.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>class Track:\n    \"\"\"Parent class for visualisation Tracks.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        prms (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, layout: dict, track_data: dict, parameters: lovis4u.Manager.Parameters):\n        \"\"\"Parent's constructor for creating a Track object.\n\n        Arguments:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            track_data (dict): a dictionary with prepared track specific data.\n            parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.layout = layout\n        self.track_data = track_data\n        self.prms = parameters\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Empy parent's method for track drawing.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.Track.__init__","title":"<code>__init__(layout, track_data, parameters)</code>","text":"<p>Parent's constructor for creating a Track object.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with prepared track specific data.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def __init__(self, layout: dict, track_data: dict, parameters: lovis4u.Manager.Parameters):\n    \"\"\"Parent's constructor for creating a Track object.\n\n    Arguments:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): a dictionary with prepared track specific data.\n        parameters (lovis4u.Manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.layout = layout\n    self.track_data = track_data\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_drawing/#lovis4u.Drawing.Track.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for track drawing.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a canvas object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Drawing.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Empy parent's method for track drawing.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a canvas object.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/","title":"lovis4u.Manager","text":"<p>This module provides managing classes and methods for the tool.</p>"},{"location":"API/package_manager/#lovis4u.Manager.Canvas","title":"<code>Canvas</code>","text":"<p>An Image object holds canvas;.</p> <p>Attributes:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>canvas object of the reportlab library.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Canvas:\n    \"\"\"An Image object holds canvas;.\n\n    Attributes:\n        canvas (reportlab.pdfgen.canvas.Canvas): canvas object of the reportlab library.\n\n    \"\"\"\n\n    def __init__(self, filename: str, width: float, height: float):\n        \"\"\"Create a Canvas object.\n\n        Arguments:\n            filename (str): path and name of the output pdf.\n            width (float): width of the canvas.\n            height (float): height of the pdf.\n\n        \"\"\"\n        self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n        self.canvas.setTitle(\"lovis4u output\")\n        self.canvas.setSubject(\"\ud83c\udfa8\")\n        self.canvas.setCreator(\"lovis4u | The Atkinson Lab 4U\")\n\n    def save(self) -&gt; None:\n        \"\"\"Save canvas as a pdf file.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.canvas.save()\n        return None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Canvas.__init__","title":"<code>__init__(filename, width, height)</code>","text":"<p>Create a Canvas object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>path and name of the output pdf.</p> </li> <li> <code>width</code>             (<code>float</code>)         \u2013          <p>width of the canvas.</p> </li> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>height of the pdf.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, filename: str, width: float, height: float):\n    \"\"\"Create a Canvas object.\n\n    Arguments:\n        filename (str): path and name of the output pdf.\n        width (float): width of the canvas.\n        height (float): height of the pdf.\n\n    \"\"\"\n    self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n    self.canvas.setTitle(\"lovis4u output\")\n    self.canvas.setSubject(\"\ud83c\udfa8\")\n    self.canvas.setCreator(\"lovis4u | The Atkinson Lab 4U\")\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Canvas.save","title":"<code>save()</code>","text":"<p>Save canvas as a pdf file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save canvas as a pdf file.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.canvas.save()\n    return None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager","title":"<code>CanvasManager</code>","text":"<p>Canvas manager object responsible for preprocessing data for visualisation and interaction between visualisation     and raw data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Defines size and coordinate system of a canvas.</p> </li> <li> <code>tracks</code>             (<code>list</code>)         \u2013          <p>List containing Track objects each of them represents visualisation unit (e.g. particular locus).</p> </li> <li> <code>cross_tracks</code>             (<code>list</code>)         \u2013          <p>List containing CrossTrack objects each of them represents visualisation unit that interacts with multiple regular Track objects.</p> </li> </ul> <pre><code>prms (Parameters): Parameters' class object that holds config and cmd arguments.\n</code></pre> Source code in <code>lovis4u/Manager.py</code> <pre><code>class CanvasManager:\n    \"\"\"Canvas manager object responsible for preprocessing data for visualisation and interaction between visualisation\n        and raw data.\n\n    Attributes:\n         layout (dict): Defines size and coordinate system of a canvas.\n         tracks (list): List containing Track objects each of them represents visualisation unit (e.g. particular locus).\n         cross_tracks (list): List containing CrossTrack objects each of them represents visualisation unit that\n            interacts with multiple regular Track objects.\n        prms (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a CanvasManager object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.layout = dict()\n        self.tracks = []\n        self.cross_tracks = []\n        self.prms = parameters\n\n    def define_layout(self, loci) -&gt; None:\n        \"\"\"Define canvas' layout based on input loci.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            annotated_descriptions = [i.description for i in loci.loci if i.description]\n            if not annotated_descriptions:\n                print(\"\u2757 Warning message: the annotation lacks description. Locus label style is \"\n                      \"changed to 'id'\")\n                self.prms.args[\"locus_label_style\"] = \"id\"\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                label_height = self.prms.args[\"feature_height\"] * cm * 0.4\n            else:\n                label_height = min(1, self.prms.args[\"locus_label_size\"]) * self.prms.args[\"feature_height\"] * cm\n            self.prms.args[\"locus_label_height\"] = label_height\n            self.prms.args[\"locus_label_font_size\"] = \\\n                lovis4u.Methods.str_height_to_size(label_height, self.prms.args[\"locus_label_id_font_face\"])\n\n            max_id_string_width = max([pdfmetrics.stringWidth(i.seq_id, self.prms.args[\"locus_label_id_font_face\"],\n                                                              self.prms.args[\"locus_label_font_size\"]) for i in\n                                       loci.loci])\n            if self.prms.args[\"locus_label_style\"] != \"id\":\n                max_descr_string_width = \\\n                    max([pdfmetrics.stringWidth(i, self.prms.args[\"locus_label_description_font_face\"],\n                                                self.prms.args[\"locus_label_font_size\"])\n                         for i in annotated_descriptions])\n\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                max_label_string_width = max(max_id_string_width, max_descr_string_width)\n            elif self.prms.args[\"locus_label_style\"] == \"id\":\n                max_label_string_width = max_id_string_width\n            elif self.prms.args[\"locus_label_style\"] == \"description\":\n                max_label_string_width = max_descr_string_width\n            loci_lengths = loci.get_loci_lengths_and_n_of_regions()\n\n            self.layout[\"total_nt_width\"] = max(i[0] for i in loci_lengths)\n\n            if self.prms.args[\"figure_width\"]:\n                full_figure_width = self.prms.args[\"figure_width\"] * cm\n                figure_width_for_loci = full_figure_width - max_label_string_width - 2 * self.prms.args[\"margin\"] * cm \\\n                                        - self.prms.args[\"gap_after_locus_label\"] * cm\n                self.prms.args[\"mm_per_nt\"] = figure_width_for_loci / self.layout[\"total_nt_width\"]\n\n            if self.prms.args[\"mm_per_nt\"] == \"auto\":\n                self.prms.args[\"mm_per_nt\"] = max(0.019 - self.layout[\"total_nt_width\"] * 4.2e-07, 0.0022)\n            self.layout[\"width_per_nt\"] = self.prms.args[\"mm_per_nt\"] * mm\n            self.layout[\"x_gap_between_regions\"] = self.prms.args[\"gap_between_regions\"] * cm\n            each_loci_region_width = [\n                (i[0] * self.layout[\"width_per_nt\"]) + (i[1] * self.layout[\"x_gap_between_regions\"])\n                for i in loci_lengths]\n            max_loci_region_length = max(each_loci_region_width)\n            self.layout[\"locus_label_left_border\"] = self.prms.args[\"margin\"] * cm\n            self.layout[\"locus_label_right_border\"] = self.layout[\"locus_label_left_border\"] + max_label_string_width\n            self.layout[\"loci_tracks_left_border\"] = self.layout[\"locus_label_right_border\"] + \\\n                                                     self.prms.args[\"gap_after_locus_label\"] * cm\n            self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + max_loci_region_length\n            self.layout[\"figure_width\"] = self.layout[\"loci_tracks_right_border\"] + self.prms.args[\"margin\"] * cm\n            self.layout[\"figure_height\"] = self.prms.args[\"margin\"] * cm\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to define layout from loci data.\") from error\n\n    def add_loci_tracks(self, loci) -&gt; None:\n        \"\"\"Add loci tracks to your canvas.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for locus in loci.loci:\n                locus_loader = LocusLoader(self.prms)\n                locus_loader.prepare_track_specific_data(locus, self.layout.copy())\n                locus_track_height = locus_loader.calculate_track_height()\n                self.layout[\"figure_height\"] += locus_track_height + self.prms.args[\"gap\"] * cm\n                locus_track = locus_loader.create_track()\n                self.tracks.append(locus_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u2705 {len(loci.loci)} loci tracks were added to the canvas\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add loci tracks to the canvas.\") from error\n\n    def add_categories_color_legend_track(self, loci) -&gt; None:\n        \"\"\"Add categories color legend tracks to your canvas.\n\n        Arguments:\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            color_legend_loader = CategoriesColorLegendLoader(self.prms)\n            color_legend_loader.prepare_track_specific_data(self.layout.copy(), loci)\n            color_legend_track_height = color_legend_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += color_legend_track_height + self.prms.args[\"gap\"] * cm\n            color_legend_track = color_legend_loader.create_track()\n            if isinstance(color_legend_track, lovis4u.Drawing.ColorLegendVis):\n                self.tracks.append(color_legend_track)\n                if self.prms.args[\"verbose\"]:\n                    print(f\"\u2705 Categories color legend track was added to the canvas\", file=sys.stdout)\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add categories color legend track to the canvas.\") from error\n\n    def add_scale_line_track(self) -&gt; None:\n        \"\"\"Add scale line tracks to your canvas.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            scale_loader = ScaleLoader(self.prms)\n            scale_loader.prepare_track_specific_data(self.layout.copy())\n            scale_track_height = scale_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += scale_track_height + self.prms.args[\"gap\"] * cm\n            scale_track = scale_loader.create_track()\n            self.tracks.append(scale_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u2705 Scale line track was added to the canvas\", file=sys.stdout)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n\n    def add_homology_track(self) -&gt; None:\n        \"\"\"Add homology track to your canvas.\n\n        You should add this track after you added loci tracks.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            loci_tracks = [i for i in self.tracks.copy() if isinstance(i, lovis4u.Drawing.LocusVis)]\n            if not loci_tracks:\n                raise lovis4u.Manager.lovis4uError(\"Unable to create homology track if no loci track was added.\")\n            for lt in loci_tracks:\n                lt.track_data[\"clean_features_coordinates\"] = True\n            self.cross_tracks.append(lovis4u.Drawing.HomologyTrack(self.layout, loci_tracks, self.prms))\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u2705 Homology track was added to the canvas\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n\n    def plot(self, filename: str) -&gt; None:\n        \"\"\"Plot all added tracks and save the plot as pdf.\n\n        Arguments:\n            filename (str): filename for the output pdf.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            file_path = os.path.join(self.prms.args[\"output_dir\"], filename)\n            self.layout[\"figure_height\"] += (self.prms.args[\"margin\"] - self.prms.args[\"gap\"]) * cm\n            plot = Canvas(file_path, self.layout[\"figure_width\"], self.layout[\"figure_height\"])\n\n            for cross_track in self.cross_tracks:\n                cross_track.draw(plot.canvas)\n\n            current_y_coordinate = self.layout[\"figure_height\"] - self.prms.args[\"margin\"] * cm\n            for track in self.tracks:\n                track.layout[\"current_y_coordinate\"] = current_y_coordinate\n                track.layout[\"figure_height\"] = self.layout[\"figure_height\"]\n                track.draw(plot.canvas)\n                current_y_coordinate -= track.track_data[\"track_height\"] + self.prms.args[\"gap\"] * cm\n            plot.save()\n            if self.prms.args[\"verbose\"]:\n                print(f\"\ud83c\udfa8 lovis4u plot was saved as: {file_path}\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to plot the canvas and save the figure.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a CanvasManager object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a CanvasManager object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.layout = dict()\n    self.tracks = []\n    self.cross_tracks = []\n    self.prms = parameters\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_categories_color_legend_track","title":"<code>add_categories_color_legend_track(loci)</code>","text":"<p>Add categories color legend tracks to your canvas.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_categories_color_legend_track(self, loci) -&gt; None:\n    \"\"\"Add categories color legend tracks to your canvas.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        color_legend_loader = CategoriesColorLegendLoader(self.prms)\n        color_legend_loader.prepare_track_specific_data(self.layout.copy(), loci)\n        color_legend_track_height = color_legend_loader.calculate_track_height()\n        self.layout[\"figure_height\"] += color_legend_track_height + self.prms.args[\"gap\"] * cm\n        color_legend_track = color_legend_loader.create_track()\n        if isinstance(color_legend_track, lovis4u.Drawing.ColorLegendVis):\n            self.tracks.append(color_legend_track)\n            if self.prms.args[\"verbose\"]:\n                print(f\"\u2705 Categories color legend track was added to the canvas\", file=sys.stdout)\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add categories color legend track to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_homology_track","title":"<code>add_homology_track()</code>","text":"<p>Add homology track to your canvas.</p> <p>You should add this track after you added loci tracks.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_homology_track(self) -&gt; None:\n    \"\"\"Add homology track to your canvas.\n\n    You should add this track after you added loci tracks.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        loci_tracks = [i for i in self.tracks.copy() if isinstance(i, lovis4u.Drawing.LocusVis)]\n        if not loci_tracks:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create homology track if no loci track was added.\")\n        for lt in loci_tracks:\n            lt.track_data[\"clean_features_coordinates\"] = True\n        self.cross_tracks.append(lovis4u.Drawing.HomologyTrack(self.layout, loci_tracks, self.prms))\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u2705 Homology track was added to the canvas\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_loci_tracks","title":"<code>add_loci_tracks(loci)</code>","text":"<p>Add loci tracks to your canvas.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_loci_tracks(self, loci) -&gt; None:\n    \"\"\"Add loci tracks to your canvas.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for locus in loci.loci:\n            locus_loader = LocusLoader(self.prms)\n            locus_loader.prepare_track_specific_data(locus, self.layout.copy())\n            locus_track_height = locus_loader.calculate_track_height()\n            self.layout[\"figure_height\"] += locus_track_height + self.prms.args[\"gap\"] * cm\n            locus_track = locus_loader.create_track()\n            self.tracks.append(locus_track)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u2705 {len(loci.loci)} loci tracks were added to the canvas\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add loci tracks to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.add_scale_line_track","title":"<code>add_scale_line_track()</code>","text":"<p>Add scale line tracks to your canvas.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def add_scale_line_track(self) -&gt; None:\n    \"\"\"Add scale line tracks to your canvas.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        scale_loader = ScaleLoader(self.prms)\n        scale_loader.prepare_track_specific_data(self.layout.copy())\n        scale_track_height = scale_loader.calculate_track_height()\n        self.layout[\"figure_height\"] += scale_track_height + self.prms.args[\"gap\"] * cm\n        scale_track = scale_loader.create_track()\n        self.tracks.append(scale_track)\n        if self.prms.args[\"verbose\"]:\n            print(f\"\u2705 Scale line track was added to the canvas\", file=sys.stdout)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to add scale line track to the canvas.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.define_layout","title":"<code>define_layout(loci)</code>","text":"<p>Define canvas' layout based on input loci.</p> <p>Parameters:</p> <ul> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def define_layout(self, loci) -&gt; None:\n    \"\"\"Define canvas' layout based on input loci.\n\n    Arguments:\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        annotated_descriptions = [i.description for i in loci.loci if i.description]\n        if not annotated_descriptions:\n            print(\"\u2757 Warning message: the annotation lacks description. Locus label style is \"\n                  \"changed to 'id'\")\n            self.prms.args[\"locus_label_style\"] = \"id\"\n        if self.prms.args[\"locus_label_style\"] == \"full\":\n            label_height = self.prms.args[\"feature_height\"] * cm * 0.4\n        else:\n            label_height = min(1, self.prms.args[\"locus_label_size\"]) * self.prms.args[\"feature_height\"] * cm\n        self.prms.args[\"locus_label_height\"] = label_height\n        self.prms.args[\"locus_label_font_size\"] = \\\n            lovis4u.Methods.str_height_to_size(label_height, self.prms.args[\"locus_label_id_font_face\"])\n\n        max_id_string_width = max([pdfmetrics.stringWidth(i.seq_id, self.prms.args[\"locus_label_id_font_face\"],\n                                                          self.prms.args[\"locus_label_font_size\"]) for i in\n                                   loci.loci])\n        if self.prms.args[\"locus_label_style\"] != \"id\":\n            max_descr_string_width = \\\n                max([pdfmetrics.stringWidth(i, self.prms.args[\"locus_label_description_font_face\"],\n                                            self.prms.args[\"locus_label_font_size\"])\n                     for i in annotated_descriptions])\n\n        if self.prms.args[\"locus_label_style\"] == \"full\":\n            max_label_string_width = max(max_id_string_width, max_descr_string_width)\n        elif self.prms.args[\"locus_label_style\"] == \"id\":\n            max_label_string_width = max_id_string_width\n        elif self.prms.args[\"locus_label_style\"] == \"description\":\n            max_label_string_width = max_descr_string_width\n        loci_lengths = loci.get_loci_lengths_and_n_of_regions()\n\n        self.layout[\"total_nt_width\"] = max(i[0] for i in loci_lengths)\n\n        if self.prms.args[\"figure_width\"]:\n            full_figure_width = self.prms.args[\"figure_width\"] * cm\n            figure_width_for_loci = full_figure_width - max_label_string_width - 2 * self.prms.args[\"margin\"] * cm \\\n                                    - self.prms.args[\"gap_after_locus_label\"] * cm\n            self.prms.args[\"mm_per_nt\"] = figure_width_for_loci / self.layout[\"total_nt_width\"]\n\n        if self.prms.args[\"mm_per_nt\"] == \"auto\":\n            self.prms.args[\"mm_per_nt\"] = max(0.019 - self.layout[\"total_nt_width\"] * 4.2e-07, 0.0022)\n        self.layout[\"width_per_nt\"] = self.prms.args[\"mm_per_nt\"] * mm\n        self.layout[\"x_gap_between_regions\"] = self.prms.args[\"gap_between_regions\"] * cm\n        each_loci_region_width = [\n            (i[0] * self.layout[\"width_per_nt\"]) + (i[1] * self.layout[\"x_gap_between_regions\"])\n            for i in loci_lengths]\n        max_loci_region_length = max(each_loci_region_width)\n        self.layout[\"locus_label_left_border\"] = self.prms.args[\"margin\"] * cm\n        self.layout[\"locus_label_right_border\"] = self.layout[\"locus_label_left_border\"] + max_label_string_width\n        self.layout[\"loci_tracks_left_border\"] = self.layout[\"locus_label_right_border\"] + \\\n                                                 self.prms.args[\"gap_after_locus_label\"] * cm\n        self.layout[\"loci_tracks_right_border\"] = self.layout[\"loci_tracks_left_border\"] + max_loci_region_length\n        self.layout[\"figure_width\"] = self.layout[\"loci_tracks_right_border\"] + self.prms.args[\"margin\"] * cm\n        self.layout[\"figure_height\"] = self.prms.args[\"margin\"] * cm\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to define layout from loci data.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CanvasManager.plot","title":"<code>plot(filename)</code>","text":"<p>Plot all added tracks and save the plot as pdf.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>filename for the output pdf.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def plot(self, filename: str) -&gt; None:\n    \"\"\"Plot all added tracks and save the plot as pdf.\n\n    Arguments:\n        filename (str): filename for the output pdf.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        file_path = os.path.join(self.prms.args[\"output_dir\"], filename)\n        self.layout[\"figure_height\"] += (self.prms.args[\"margin\"] - self.prms.args[\"gap\"]) * cm\n        plot = Canvas(file_path, self.layout[\"figure_width\"], self.layout[\"figure_height\"])\n\n        for cross_track in self.cross_tracks:\n            cross_track.draw(plot.canvas)\n\n        current_y_coordinate = self.layout[\"figure_height\"] - self.prms.args[\"margin\"] * cm\n        for track in self.tracks:\n            track.layout[\"current_y_coordinate\"] = current_y_coordinate\n            track.layout[\"figure_height\"] = self.layout[\"figure_height\"]\n            track.draw(plot.canvas)\n            current_y_coordinate -= track.track_data[\"track_height\"] + self.prms.args[\"gap\"] * cm\n        plot.save()\n        if self.prms.args[\"verbose\"]:\n            print(f\"\ud83c\udfa8 lovis4u plot was saved as: {file_path}\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to plot the canvas and save the figure.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader","title":"<code>CategoriesColorLegendLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A CategoriesColorLegendLoader object prepares data for a categories color legend track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class CategoriesColorLegendLoader(Loader):\n    \"\"\"A CategoriesColorLegendLoader object prepares data for a categories color legend track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a CategoriesColorLegendLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, layout: dict, loci) -&gt; None:\n        \"\"\"Prepare ScaleLoader specific data.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n            loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            self.track_data = dict()\n            label_height = self.prms.args[\"color_legend_label_size\"] * cm\n            line_height = self.prms.args[\"color_legend_line_height\"] * cm\n            line_gap = 0.4 * label_height\n            self.track_data[\"line_height\"] = line_height\n            self.track_data[\"color_legend_label_size\"] = lovis4u.Methods.str_height_to_size(\n                label_height, self.prms.args[\"color_legend_font_face\"])\n            left_border = self.layout[\"loci_tracks_left_border\"]\n            right_border = self.layout[\"loci_tracks_right_border\"]\n            x_gap = pdfmetrics.stringWidth(\" \" * 5, self.prms.args[\"color_legend_font_face\"],\n                                           self.track_data[\"color_legend_label_size\"])\n            y_gap = 0.5 * label_height\n            color_dict = dict()\n            for locus in loci.loci:\n                color_dict.update(locus.category_colors)\n            self.track_data[\"labels\"] = []\n            current_x = left_border\n            n_of_rows = 0\n            current_y = - (label_height + line_gap + line_height)\n            for label, color in color_dict.items():\n                label_dict = dict()\n                label_width = pdfmetrics.stringWidth(label, self.prms.args[\"color_legend_font_face\"],\n                                                     self.track_data[\"color_legend_label_size\"])\n                label_end = current_x + label_width\n                if label_end &gt; right_border:\n                    current_x = left_border\n                    current_y -= (label_height + line_gap + line_height + y_gap)\n                    n_of_rows += 1\n                label_dict[\"label_x\"] = current_x\n                label_dict[\"label_width\"] = label_width\n                label_dict[\"relative_y\"] = current_y\n                label_dict[\"relative_y_text\"] = current_y + line_gap + line_height\n                label_dict[\"color\"] = color\n                label_dict[\"label\"] = label\n                self.track_data[\"labels\"].append(label_dict)\n                current_x = label_dict[\"label_x\"] + label_width + x_gap\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare categories color legend track specific data.\") \\\n                from error\n\n    def calculate_track_height(self):\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            if self.track_data[\"labels\"]:\n                min_relative_y = min([i[\"relative_y\"] for i in self.track_data[\"labels\"]])\n                track_height = abs(min_relative_y)\n            else:\n                track_height = 0\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a categories color legend track height.\") \\\n                from error\n\n    def create_track(self):\n        \"\"\"Initialise a ColorLegendVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis | None: visualisation track.\n\n        \"\"\"\n        try:\n            if self.track_data[\"labels\"]:\n                return lovis4u.Drawing.ColorLegendVis(self.layout, self.track_data, self.prms)\n            else:\n                print(\"\u2757 Warning message: Category colors legend track cannot be created since there is no \"\n                      \"categories.\", file=sys.stdout)\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a categories color legend track track object.\") \\\n                from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a CategoriesColorLegendLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a CategoriesColorLegendLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code>        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self):\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        if self.track_data[\"labels\"]:\n            min_relative_y = min([i[\"relative_y\"] for i in self.track_data[\"labels\"]])\n            track_height = abs(min_relative_y)\n        else:\n            track_height = 0\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a categories color legend track height.\") \\\n            from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a ColorLegendVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis | None: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a ColorLegendVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis | None: visualisation track.\n\n    \"\"\"\n    try:\n        if self.track_data[\"labels\"]:\n            return lovis4u.Drawing.ColorLegendVis(self.layout, self.track_data, self.prms)\n        else:\n            print(\"\u2757 Warning message: Category colors legend track cannot be created since there is no \"\n                  \"categories.\", file=sys.stdout)\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a categories color legend track track object.\") \\\n            from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.CategoriesColorLegendLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(layout, loci)</code>","text":"<p>Prepare ScaleLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>loci</code>             (<code>Loci</code>)         \u2013          <p>Loci object with information about sequences and features.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, layout: dict, loci) -&gt; None:\n    \"\"\"Prepare ScaleLoader specific data.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        loci (lovis4u.DataProcessing.Loci): Loci object with information about sequences and features.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        self.track_data = dict()\n        label_height = self.prms.args[\"color_legend_label_size\"] * cm\n        line_height = self.prms.args[\"color_legend_line_height\"] * cm\n        line_gap = 0.4 * label_height\n        self.track_data[\"line_height\"] = line_height\n        self.track_data[\"color_legend_label_size\"] = lovis4u.Methods.str_height_to_size(\n            label_height, self.prms.args[\"color_legend_font_face\"])\n        left_border = self.layout[\"loci_tracks_left_border\"]\n        right_border = self.layout[\"loci_tracks_right_border\"]\n        x_gap = pdfmetrics.stringWidth(\" \" * 5, self.prms.args[\"color_legend_font_face\"],\n                                       self.track_data[\"color_legend_label_size\"])\n        y_gap = 0.5 * label_height\n        color_dict = dict()\n        for locus in loci.loci:\n            color_dict.update(locus.category_colors)\n        self.track_data[\"labels\"] = []\n        current_x = left_border\n        n_of_rows = 0\n        current_y = - (label_height + line_gap + line_height)\n        for label, color in color_dict.items():\n            label_dict = dict()\n            label_width = pdfmetrics.stringWidth(label, self.prms.args[\"color_legend_font_face\"],\n                                                 self.track_data[\"color_legend_label_size\"])\n            label_end = current_x + label_width\n            if label_end &gt; right_border:\n                current_x = left_border\n                current_y -= (label_height + line_gap + line_height + y_gap)\n                n_of_rows += 1\n            label_dict[\"label_x\"] = current_x\n            label_dict[\"label_width\"] = label_width\n            label_dict[\"relative_y\"] = current_y\n            label_dict[\"relative_y_text\"] = current_y + line_gap + line_height\n            label_dict[\"color\"] = color\n            label_dict[\"label\"] = label\n            self.track_data[\"labels\"].append(label_dict)\n            current_x = label_dict[\"label_x\"] + label_width + x_gap\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare categories color legend track specific data.\") \\\n            from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader","title":"<code>Loader</code>","text":"<p>Parent class for tracks loaders.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Loader:\n    \"\"\"Parent class for tracks loaders.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters: Parameters):\n        \"\"\"Parent's constructor for creating a Loader class object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        self.prms = parameters\n        self.layout = None\n        self.track_data = None\n\n    def prepare_track_specific_data(self) -&gt; None:\n        \"\"\"Empty parent's method for data preparation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def calculate_track_height(self) -&gt; None:\n        \"\"\"Empty parent's method for track height calculation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def create_track(self) -&gt; None:\n        \"\"\"Empty parent's method for track initialisation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Parent's constructor for creating a Loader class object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters: Parameters):\n    \"\"\"Parent's constructor for creating a Loader class object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    self.prms = parameters\n    self.layout = None\n    self.track_data = None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Empty parent's method for track height calculation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self) -&gt; None:\n    \"\"\"Empty parent's method for track height calculation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.create_track","title":"<code>create_track()</code>","text":"<p>Empty parent's method for track initialisation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self) -&gt; None:\n    \"\"\"Empty parent's method for track initialisation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Loader.prepare_track_specific_data","title":"<code>prepare_track_specific_data()</code>","text":"<p>Empty parent's method for data preparation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self) -&gt; None:\n    \"\"\"Empty parent's method for data preparation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader","title":"<code>LocusLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A LocusLoader object prepares data for a Locus track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class LocusLoader(Loader):\n    \"\"\"A LocusLoader object prepares data for a Locus track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a LocusLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, locus, layout: dict) -&gt; None:\n        \"\"\"Prepare LocusLoader specific data.\n\n        Attributes:\n            locus (lovis4u.DataProcessing.Locus): corresponding locus object.\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            layout[\"inverse_y_coordinate\"] = layout[\"figure_height\"]\n            track_data = dict()\n            self.track_data = track_data\n            if self.prms.args[\"locus_label_style\"] == \"full\":\n                track_data[\"locus_label\"] = [locus.seq_id]\n                if locus.description:\n                    track_data[\"locus_label\"].append(locus.description)\n            elif self.prms.args[\"locus_label_style\"] == \"id\":\n                track_data[\"locus_label\"] = [locus.seq_id]\n            elif self.prms.args[\"locus_label_style\"] == \"description\":\n                track_data[\"locus_label\"] = [locus.description]\n\n            flh = self.prms.args[\"feature_label_size\"] * self.prms.args[\"feature_height\"] * cm\n            track_data[\"f_label_height\"] = flh\n            track_data[\"f_label_font_size\"] = lovis4u.Methods.str_height_to_size(\n                flh, self.prms.args[\"feature_label_font_face\"])\n            track_data[\"feature_label_gap\"] = self.prms.args[\"feature_label_gap\"] * track_data[\"f_label_height\"]\n\n            # Managing features positions and parameters\n            track_data[\"clean_features_coordinates\"] = False\n            track_data[\"features\"] = []\n            features_taken_nt_coordinates = []\n            for feature in locus.features:\n                features_taken_nt_coordinates.append([feature.start, feature.end])\n                if feature.vis_prms[\"fill_color\"] == \"default\":\n                    feature.vis_prms[\"fill_color\"] = lovis4u.Methods.get_color(\"feature_default_fill_color\", self.prms)\n                if self.prms.args[\"set_feature_stroke_color_based_on_fill_color\"] and \\\n                        feature.vis_prms[\"stroke_color\"] == \"default\":\n                    scale_l = self.prms.args[\"feature_stroke_color_relative_lightness\"]\n                    feature.vis_prms[\"stroke_color\"] = lovis4u.Methods.scale_lightness(feature.vis_prms[\"fill_color\"],\n                                                                                       scale_l)\n                elif not self.prms.args[\"set_feature_stroke_color_based_on_fill_color\"] and \\\n                        feature.vis_prms[\"stroke_color\"] == \"default\":\n                    feature.vis_prms[\"stroke_color\"] = lovis4u.Methods.get_color(\"feature_default_stroke_color\",\n                                                                                 self.prms)\n                f_label_width = 0\n                if feature.vis_prms[\"show_label\"] and feature.vis_prms[\"label\"]:\n                    f_label_width = pdfmetrics.stringWidth(feature.vis_prms[\"label\"],\n                                                           self.prms.args[\"feature_label_font_face\"],\n                                                           track_data[\"f_label_font_size\"])\n                feature_vis_data = feature.vis_prms\n                feature_vis_data[\"coordinates\"] = lovis4u.Methods.feature_nt_to_x_transform(feature.start, feature.end,\n                                                                                            feature.strand, locus,\n                                                                                            layout)\n                feature_vis_data[\"label_width\"] = f_label_width\n                feature_vis_data[\"feature_width\"] = feature_vis_data[\"coordinates\"][\"end\"] - \\\n                                                    feature_vis_data[\"coordinates\"][\"start\"]\n                feature_vis_data[\"group\"] = feature.group\n                track_data[\"features\"].append(feature_vis_data)\n            # Managing category visualisation\n            feature_cateregories = set([feature.category for feature in locus.features if feature.category])\n            track_data[\"functions_coordinates\"] = None\n            if feature_cateregories and locus.category_colors:\n                track_data[\"category_colors\"] = locus.category_colors\n                track_data[\"functions_coordinates\"] = dict()\n                for ff in feature_cateregories:\n                    ff_features = [feature for feature in locus.features if feature.category == ff]\n                    ff_coordinates = [[f.vis_prms[\"coordinates\"][\"start\"], f.vis_prms[\"coordinates\"][\"end\"]] for f in\n                                      ff_features]\n                    track_data[\"functions_coordinates\"][ff] = ff_coordinates\n            # Managing feature labels' positions:\n            taken_label_coordinates = collections.defaultdict(list)\n            if sum([fvd[\"show_label\"] for fvd in track_data[\"features\"]]) &gt; 0:\n                space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"feature_label_font_face\"],\n                                                     track_data[\"f_label_font_size\"])\n                sorted_features = sorted(track_data[\"features\"], key=lambda x: x[\"feature_width\"] - x[\"label_width\"],\n                                         reverse=True)\n                for fvd in [fvd for fvd in sorted_features if fvd[\"label_width\"]]:\n                    feature_center = fvd[\"coordinates\"][\"center\"]\n                    width_diff = fvd[\"label_width\"] - fvd[\"feature_width\"]\n                    left_position = [fvd[\"coordinates\"][\"start\"] - width_diff, fvd[\"coordinates\"][\"end\"]]\n                    centered_position = [feature_center - fvd[\"label_width\"] / 2,\n                                         feature_center + fvd[\"label_width\"] / 2]\n                    right_position = [fvd[\"coordinates\"][\"start\"], fvd[\"coordinates\"][\"end\"] + width_diff]\n                    for pos in [left_position, centered_position, right_position]:\n                        overlap = 0\n                        if pos[0] &lt; layout[\"loci_tracks_left_border\"]:\n                            overlap = layout[\"loci_tracks_left_border\"] - pos[0]\n                        if pos[1] &gt; layout[\"loci_tracks_right_border\"]:\n                            overlap = layout[\"loci_tracks_right_border\"] - pos[1]\n                        if overlap:\n                            pos[0] += overlap\n                            pos[1] += overlap\n                    label_position = centered_position\n                    if width_diff &gt; 0:\n                        left_pos_overlap = [of for of in track_data[\"features\"] if\n                                            (of != fvd and left_position[0] &lt; of[\"coordinates\"][\"end\"] &lt;\n                                             fvd[\"coordinates\"][\"end\"] and of[\"show_label\"])]\n                        right_pos_overlap = [of for of in track_data[\"features\"] if\n                                             (of != fvd and right_position[1] &gt; of[\"coordinates\"][\"start\"] &gt;\n                                              fvd[\"coordinates\"][\"start\"] and of[\"show_label\"])]\n                        if left_pos_overlap and not right_pos_overlap:\n                            min_n_distance = min([fvd[\"coordinates\"][\"start\"] - nf[\"coordinates\"][\"end\"]\n                                                  for nf in left_pos_overlap])\n                            if min_n_distance &lt; space_width:\n                                right_position[0] += space_width + min(0, min_n_distance)\n                                right_position[1] += space_width + min(0, min_n_distance)\n                            label_position = right_position\n                        elif not left_pos_overlap and right_pos_overlap:\n                            min_n_distance = min([nf[\"coordinates\"][\"start\"] - fvd[\"coordinates\"][\"end\"]\n                                                  for nf in right_pos_overlap])\n                            label_position = left_position\n                            if min_n_distance &lt; space_width and left_position[0] != layout[\"loci_tracks_left_border\"]:\n                                left_position[0] -= space_width\n                                left_position[1] -= space_width\n                            else:\n                                label_position = centered_position\n                        else:\n                            label_position = centered_position\n                    fvd[\"label_position\"] = label_position\n                    for label_row in range(0, len(track_data[\"features\"])):\n                        overlapped = False\n                        for taken_coordinate in taken_label_coordinates[label_row]:\n                            if taken_coordinate[0] &lt;= label_position[0] &lt;= taken_coordinate[1] or \\\n                                    taken_coordinate[0] &lt;= label_position[1] &lt;= taken_coordinate[1] or \\\n                                    label_position[0] &lt;= taken_coordinate[0] &lt;= label_position[1] or \\\n                                    label_position[0] &lt;= taken_coordinate[1] &lt;= label_position[1]:\n                                overlapped = True\n                        if not overlapped:\n                            fvd[\"label_row\"] = label_row\n                            taken_label_coordinates[label_row].append(label_position)\n                            break\n                    fvd[\"label_y_bottom\"] = track_data[\"feature_label_gap\"] + \\\n                                            (fvd[\"label_row\"] * track_data[\"f_label_height\"]) + \\\n                                            (fvd[\"label_row\"] * track_data[\"feature_label_gap\"])\n                for fvd in track_data[\"features\"]:\n                    if fvd[\"label_width\"]:\n                        if fvd[\"label_row\"] &gt; 0:\n                            taken_middle_rows = [i for i in range(fvd[\"label_row\"] - 1, -1, -1) if\n                                                 any(taken_coordinate[0] &lt;= fvd[\"coordinates\"][\"center\"] &lt;=\n                                                     taken_coordinate[1]\n                                                     for taken_coordinate in taken_label_coordinates[i])]\n                            label_line_upper = fvd[\"label_y_bottom\"] - track_data[\"feature_label_gap\"] / 2\n                            label_line_bottom = track_data[\"feature_label_gap\"] / 2\n                            label_line_coordinates = []\n                            ll_start = label_line_bottom\n                            for tmr in sorted(taken_middle_rows):\n                                tmr_start = 0.5 * track_data[\"feature_label_gap\"] + \\\n                                            (tmr * track_data[\"f_label_height\"]) + \\\n                                            (tmr * track_data[\"feature_label_gap\"])\n                                tmr_end = tmr_start + track_data[\"f_label_height\"] + \\\n                                          0.5 * track_data[\"feature_label_gap\"]\n                                label_line_coordinates.append([ll_start, tmr_start])\n                                ll_start = tmr_end\n                            label_line_coordinates.append([ll_start, label_line_upper])\n                            fvd[\"label_line_coordinates\"] = label_line_coordinates\n            track_data[\"n_label_rows\"] = sum([1 for k, v in taken_label_coordinates.items() if v])\n            # Managing middle line indicating locus borders\n            if self.prms.args[\"draw_middle_line\"]:\n                regions_for_middle_line = [[c[\"start\"], c[\"end\"]] for c in locus.coordinates]\n                for ftc in features_taken_nt_coordinates:\n                    ftcs, ftse = ftc\n                    for added_region in regions_for_middle_line:\n                        new_regions = []\n                        to_remove = False\n                        if added_region[0] &lt;= ftcs &lt;= added_region[1]:\n                            to_remove = True\n                            if ftcs &gt; added_region[0]:\n                                new_regions.append([added_region[0], ftcs - 1])\n                        if added_region[0] &lt;= ftse &lt;= added_region[1]:\n                            to_remove = True\n                            if ftse &lt; added_region[1]:\n                                new_regions.append([ftse + 1, added_region[1]])\n                        if to_remove:\n                            regions_for_middle_line.remove(added_region)\n                        regions_for_middle_line += new_regions\n                middle_line_coordinates = [lovis4u.Methods.region_nt_to_x_transform(rml[0], rml[1], locus, layout)\n                                           for rml in regions_for_middle_line]\n                track_data[\"middle_line_coordinates\"] = middle_line_coordinates\n            track_data[\"proteome_size\"] = len(locus.features)  # to change if we get other features\n            # Managing individual x axis\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                track_data[\"x_axis_annotation\"] = dict()\n                axis_tics_label_size = \\\n                    lovis4u.Methods.str_height_to_size(self.prms.args[\"x_axis_ticks_labels_height\"] * cm,\n                                                       self.prms.args[\"x_axis_ticks_labels_font_face\"])\n                track_data[\"x_axis_annotation\"][\"label_size\"] = axis_tics_label_size\n                axis_regions = []\n                axis_tics_coordinates = []\n                for coordinate in locus.coordinates:\n                    axis_regions.append(lovis4u.Methods.region_nt_to_x_transform(coordinate[\"start\"], coordinate[\"end\"],\n                                                                                 locus, layout))\n                    current_tics_coordinates = [coordinate[\"start\"], coordinate[\"end\"]]\n                    if coordinate[\"strand\"] == -1:\n                        current_tics_coordinates = current_tics_coordinates[::-1]\n                    axis_tics_coordinates += current_tics_coordinates\n                axis_tics_labels = list(map(str, axis_tics_coordinates))\n                axis_tics_label_width = list(map(lambda x:\n                                                 pdfmetrics.stringWidth(x,\n                                                                        self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                                        axis_tics_label_size), axis_tics_labels))\n                axis_tics_position = list(map(lambda x: lovis4u.Methods.nt_to_x_transform(x, locus, layout, \"center\"),\n                                              axis_tics_coordinates))\n                space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                     axis_tics_label_size)\n                tics_labels_coordinates = axis_tics_position.copy()\n                for t_i in range(len(axis_tics_coordinates)):\n                    label_width = axis_tics_label_width[t_i]\n                    tick_position = axis_tics_position[t_i]\n                    if t_i == 0:\n                        tics_labels_coordinates[t_i] += label_width * 0.5\n                    elif t_i != len(axis_tics_coordinates) - 1:\n                        center_label_coordinates = [tick_position - 0.5 * label_width,\n                                                    tick_position + 0.5 * label_width]\n                        if center_label_coordinates[0] - space_width &lt;= axis_tics_position[t_i - 1]:\n                            tics_labels_coordinates[t_i] += label_width * 0.5\n                            if axis_tics_position[t_i] - axis_tics_position[t_i - 1] &lt; space_width:\n                                tics_labels_coordinates[t_i] += space_width\n                        if center_label_coordinates[1] + space_width &gt;= axis_tics_position[t_i + 1]:\n                            tics_labels_coordinates[t_i] -= label_width * 0.5\n                            if axis_tics_position[t_i + 1] - axis_tics_position[t_i] &lt; space_width:\n                                tics_labels_coordinates[t_i] -= space_width\n                    if tics_labels_coordinates[t_i] + label_width * 0.5 &gt; layout[\"loci_tracks_right_border\"]:\n                        tics_labels_coordinates[t_i] -= ((tics_labels_coordinates[t_i] + label_width * 0.5) -\n                                                         layout[\"loci_tracks_right_border\"])\n                track_data[\"x_axis_annotation\"][\"axis_regions\"] = axis_regions\n                track_data[\"x_axis_annotation\"][\"axis_tics_position\"] = axis_tics_position\n                track_data[\"x_axis_annotation\"][\"axis_tics_labels\"] = axis_tics_labels\n                track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"] = tics_labels_coordinates\n                return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare Locus specific data.\") from error\n\n    def calculate_track_height(self) -&gt; float:\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            track_height = self.prms.args[\"feature_height\"] * cm + \\\n                           (self.track_data[\"n_label_rows\"] * self.track_data[\"f_label_height\"] * \\\n                            (1 + self.prms.args[\"feature_label_gap\"]))\n            if self.prms.args[\"draw_individual_x_axis\"]:\n                track_height += (self.prms.args[\"feature_bottom_gap\"] + self.prms.args[\"x_axis_ticks_height\"] * 1.3 + \\\n                                 self.prms.args[\"x_axis_ticks_labels_height\"]) * cm\n            elif not self.prms.args[\"draw_individual_x_axis\"] and self.track_data[\"functions_coordinates\"]:\n                track_height += (self.prms.args[\"feature_bottom_gap\"] + \\\n                                 self.prms.args[\"category_annotation_line_width\"]) * cm\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a locus track height.\") from error\n\n    def create_track(self):\n        \"\"\"Initialise a LocusVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis: visualisation track.\n\n        \"\"\"\n        try:\n            return lovis4u.Drawing.LocusVis(self.layout, self.track_data, self.prms)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a locus track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a LocusLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a LocusLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self) -&gt; float:\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        track_height = self.prms.args[\"feature_height\"] * cm + \\\n                       (self.track_data[\"n_label_rows\"] * self.track_data[\"f_label_height\"] * \\\n                        (1 + self.prms.args[\"feature_label_gap\"]))\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            track_height += (self.prms.args[\"feature_bottom_gap\"] + self.prms.args[\"x_axis_ticks_height\"] * 1.3 + \\\n                             self.prms.args[\"x_axis_ticks_labels_height\"]) * cm\n        elif not self.prms.args[\"draw_individual_x_axis\"] and self.track_data[\"functions_coordinates\"]:\n            track_height += (self.prms.args[\"feature_bottom_gap\"] + \\\n                             self.prms.args[\"category_annotation_line_width\"]) * cm\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a locus track height.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a LocusVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a LocusVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis: visualisation track.\n\n    \"\"\"\n    try:\n        return lovis4u.Drawing.LocusVis(self.layout, self.track_data, self.prms)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a locus track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.LocusLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(locus, layout)</code>","text":"<p>Prepare LocusLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, locus, layout: dict) -&gt; None:\n    \"\"\"Prepare LocusLoader specific data.\n\n    Attributes:\n        locus (lovis4u.DataProcessing.Locus): corresponding locus object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        layout[\"inverse_y_coordinate\"] = layout[\"figure_height\"]\n        track_data = dict()\n        self.track_data = track_data\n        if self.prms.args[\"locus_label_style\"] == \"full\":\n            track_data[\"locus_label\"] = [locus.seq_id]\n            if locus.description:\n                track_data[\"locus_label\"].append(locus.description)\n        elif self.prms.args[\"locus_label_style\"] == \"id\":\n            track_data[\"locus_label\"] = [locus.seq_id]\n        elif self.prms.args[\"locus_label_style\"] == \"description\":\n            track_data[\"locus_label\"] = [locus.description]\n\n        flh = self.prms.args[\"feature_label_size\"] * self.prms.args[\"feature_height\"] * cm\n        track_data[\"f_label_height\"] = flh\n        track_data[\"f_label_font_size\"] = lovis4u.Methods.str_height_to_size(\n            flh, self.prms.args[\"feature_label_font_face\"])\n        track_data[\"feature_label_gap\"] = self.prms.args[\"feature_label_gap\"] * track_data[\"f_label_height\"]\n\n        # Managing features positions and parameters\n        track_data[\"clean_features_coordinates\"] = False\n        track_data[\"features\"] = []\n        features_taken_nt_coordinates = []\n        for feature in locus.features:\n            features_taken_nt_coordinates.append([feature.start, feature.end])\n            if feature.vis_prms[\"fill_color\"] == \"default\":\n                feature.vis_prms[\"fill_color\"] = lovis4u.Methods.get_color(\"feature_default_fill_color\", self.prms)\n            if self.prms.args[\"set_feature_stroke_color_based_on_fill_color\"] and \\\n                    feature.vis_prms[\"stroke_color\"] == \"default\":\n                scale_l = self.prms.args[\"feature_stroke_color_relative_lightness\"]\n                feature.vis_prms[\"stroke_color\"] = lovis4u.Methods.scale_lightness(feature.vis_prms[\"fill_color\"],\n                                                                                   scale_l)\n            elif not self.prms.args[\"set_feature_stroke_color_based_on_fill_color\"] and \\\n                    feature.vis_prms[\"stroke_color\"] == \"default\":\n                feature.vis_prms[\"stroke_color\"] = lovis4u.Methods.get_color(\"feature_default_stroke_color\",\n                                                                             self.prms)\n            f_label_width = 0\n            if feature.vis_prms[\"show_label\"] and feature.vis_prms[\"label\"]:\n                f_label_width = pdfmetrics.stringWidth(feature.vis_prms[\"label\"],\n                                                       self.prms.args[\"feature_label_font_face\"],\n                                                       track_data[\"f_label_font_size\"])\n            feature_vis_data = feature.vis_prms\n            feature_vis_data[\"coordinates\"] = lovis4u.Methods.feature_nt_to_x_transform(feature.start, feature.end,\n                                                                                        feature.strand, locus,\n                                                                                        layout)\n            feature_vis_data[\"label_width\"] = f_label_width\n            feature_vis_data[\"feature_width\"] = feature_vis_data[\"coordinates\"][\"end\"] - \\\n                                                feature_vis_data[\"coordinates\"][\"start\"]\n            feature_vis_data[\"group\"] = feature.group\n            track_data[\"features\"].append(feature_vis_data)\n        # Managing category visualisation\n        feature_cateregories = set([feature.category for feature in locus.features if feature.category])\n        track_data[\"functions_coordinates\"] = None\n        if feature_cateregories and locus.category_colors:\n            track_data[\"category_colors\"] = locus.category_colors\n            track_data[\"functions_coordinates\"] = dict()\n            for ff in feature_cateregories:\n                ff_features = [feature for feature in locus.features if feature.category == ff]\n                ff_coordinates = [[f.vis_prms[\"coordinates\"][\"start\"], f.vis_prms[\"coordinates\"][\"end\"]] for f in\n                                  ff_features]\n                track_data[\"functions_coordinates\"][ff] = ff_coordinates\n        # Managing feature labels' positions:\n        taken_label_coordinates = collections.defaultdict(list)\n        if sum([fvd[\"show_label\"] for fvd in track_data[\"features\"]]) &gt; 0:\n            space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"feature_label_font_face\"],\n                                                 track_data[\"f_label_font_size\"])\n            sorted_features = sorted(track_data[\"features\"], key=lambda x: x[\"feature_width\"] - x[\"label_width\"],\n                                     reverse=True)\n            for fvd in [fvd for fvd in sorted_features if fvd[\"label_width\"]]:\n                feature_center = fvd[\"coordinates\"][\"center\"]\n                width_diff = fvd[\"label_width\"] - fvd[\"feature_width\"]\n                left_position = [fvd[\"coordinates\"][\"start\"] - width_diff, fvd[\"coordinates\"][\"end\"]]\n                centered_position = [feature_center - fvd[\"label_width\"] / 2,\n                                     feature_center + fvd[\"label_width\"] / 2]\n                right_position = [fvd[\"coordinates\"][\"start\"], fvd[\"coordinates\"][\"end\"] + width_diff]\n                for pos in [left_position, centered_position, right_position]:\n                    overlap = 0\n                    if pos[0] &lt; layout[\"loci_tracks_left_border\"]:\n                        overlap = layout[\"loci_tracks_left_border\"] - pos[0]\n                    if pos[1] &gt; layout[\"loci_tracks_right_border\"]:\n                        overlap = layout[\"loci_tracks_right_border\"] - pos[1]\n                    if overlap:\n                        pos[0] += overlap\n                        pos[1] += overlap\n                label_position = centered_position\n                if width_diff &gt; 0:\n                    left_pos_overlap = [of for of in track_data[\"features\"] if\n                                        (of != fvd and left_position[0] &lt; of[\"coordinates\"][\"end\"] &lt;\n                                         fvd[\"coordinates\"][\"end\"] and of[\"show_label\"])]\n                    right_pos_overlap = [of for of in track_data[\"features\"] if\n                                         (of != fvd and right_position[1] &gt; of[\"coordinates\"][\"start\"] &gt;\n                                          fvd[\"coordinates\"][\"start\"] and of[\"show_label\"])]\n                    if left_pos_overlap and not right_pos_overlap:\n                        min_n_distance = min([fvd[\"coordinates\"][\"start\"] - nf[\"coordinates\"][\"end\"]\n                                              for nf in left_pos_overlap])\n                        if min_n_distance &lt; space_width:\n                            right_position[0] += space_width + min(0, min_n_distance)\n                            right_position[1] += space_width + min(0, min_n_distance)\n                        label_position = right_position\n                    elif not left_pos_overlap and right_pos_overlap:\n                        min_n_distance = min([nf[\"coordinates\"][\"start\"] - fvd[\"coordinates\"][\"end\"]\n                                              for nf in right_pos_overlap])\n                        label_position = left_position\n                        if min_n_distance &lt; space_width and left_position[0] != layout[\"loci_tracks_left_border\"]:\n                            left_position[0] -= space_width\n                            left_position[1] -= space_width\n                        else:\n                            label_position = centered_position\n                    else:\n                        label_position = centered_position\n                fvd[\"label_position\"] = label_position\n                for label_row in range(0, len(track_data[\"features\"])):\n                    overlapped = False\n                    for taken_coordinate in taken_label_coordinates[label_row]:\n                        if taken_coordinate[0] &lt;= label_position[0] &lt;= taken_coordinate[1] or \\\n                                taken_coordinate[0] &lt;= label_position[1] &lt;= taken_coordinate[1] or \\\n                                label_position[0] &lt;= taken_coordinate[0] &lt;= label_position[1] or \\\n                                label_position[0] &lt;= taken_coordinate[1] &lt;= label_position[1]:\n                            overlapped = True\n                    if not overlapped:\n                        fvd[\"label_row\"] = label_row\n                        taken_label_coordinates[label_row].append(label_position)\n                        break\n                fvd[\"label_y_bottom\"] = track_data[\"feature_label_gap\"] + \\\n                                        (fvd[\"label_row\"] * track_data[\"f_label_height\"]) + \\\n                                        (fvd[\"label_row\"] * track_data[\"feature_label_gap\"])\n            for fvd in track_data[\"features\"]:\n                if fvd[\"label_width\"]:\n                    if fvd[\"label_row\"] &gt; 0:\n                        taken_middle_rows = [i for i in range(fvd[\"label_row\"] - 1, -1, -1) if\n                                             any(taken_coordinate[0] &lt;= fvd[\"coordinates\"][\"center\"] &lt;=\n                                                 taken_coordinate[1]\n                                                 for taken_coordinate in taken_label_coordinates[i])]\n                        label_line_upper = fvd[\"label_y_bottom\"] - track_data[\"feature_label_gap\"] / 2\n                        label_line_bottom = track_data[\"feature_label_gap\"] / 2\n                        label_line_coordinates = []\n                        ll_start = label_line_bottom\n                        for tmr in sorted(taken_middle_rows):\n                            tmr_start = 0.5 * track_data[\"feature_label_gap\"] + \\\n                                        (tmr * track_data[\"f_label_height\"]) + \\\n                                        (tmr * track_data[\"feature_label_gap\"])\n                            tmr_end = tmr_start + track_data[\"f_label_height\"] + \\\n                                      0.5 * track_data[\"feature_label_gap\"]\n                            label_line_coordinates.append([ll_start, tmr_start])\n                            ll_start = tmr_end\n                        label_line_coordinates.append([ll_start, label_line_upper])\n                        fvd[\"label_line_coordinates\"] = label_line_coordinates\n        track_data[\"n_label_rows\"] = sum([1 for k, v in taken_label_coordinates.items() if v])\n        # Managing middle line indicating locus borders\n        if self.prms.args[\"draw_middle_line\"]:\n            regions_for_middle_line = [[c[\"start\"], c[\"end\"]] for c in locus.coordinates]\n            for ftc in features_taken_nt_coordinates:\n                ftcs, ftse = ftc\n                for added_region in regions_for_middle_line:\n                    new_regions = []\n                    to_remove = False\n                    if added_region[0] &lt;= ftcs &lt;= added_region[1]:\n                        to_remove = True\n                        if ftcs &gt; added_region[0]:\n                            new_regions.append([added_region[0], ftcs - 1])\n                    if added_region[0] &lt;= ftse &lt;= added_region[1]:\n                        to_remove = True\n                        if ftse &lt; added_region[1]:\n                            new_regions.append([ftse + 1, added_region[1]])\n                    if to_remove:\n                        regions_for_middle_line.remove(added_region)\n                    regions_for_middle_line += new_regions\n            middle_line_coordinates = [lovis4u.Methods.region_nt_to_x_transform(rml[0], rml[1], locus, layout)\n                                       for rml in regions_for_middle_line]\n            track_data[\"middle_line_coordinates\"] = middle_line_coordinates\n        track_data[\"proteome_size\"] = len(locus.features)  # to change if we get other features\n        # Managing individual x axis\n        if self.prms.args[\"draw_individual_x_axis\"]:\n            track_data[\"x_axis_annotation\"] = dict()\n            axis_tics_label_size = \\\n                lovis4u.Methods.str_height_to_size(self.prms.args[\"x_axis_ticks_labels_height\"] * cm,\n                                                   self.prms.args[\"x_axis_ticks_labels_font_face\"])\n            track_data[\"x_axis_annotation\"][\"label_size\"] = axis_tics_label_size\n            axis_regions = []\n            axis_tics_coordinates = []\n            for coordinate in locus.coordinates:\n                axis_regions.append(lovis4u.Methods.region_nt_to_x_transform(coordinate[\"start\"], coordinate[\"end\"],\n                                                                             locus, layout))\n                current_tics_coordinates = [coordinate[\"start\"], coordinate[\"end\"]]\n                if coordinate[\"strand\"] == -1:\n                    current_tics_coordinates = current_tics_coordinates[::-1]\n                axis_tics_coordinates += current_tics_coordinates\n            axis_tics_labels = list(map(str, axis_tics_coordinates))\n            axis_tics_label_width = list(map(lambda x:\n                                             pdfmetrics.stringWidth(x,\n                                                                    self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                                    axis_tics_label_size), axis_tics_labels))\n            axis_tics_position = list(map(lambda x: lovis4u.Methods.nt_to_x_transform(x, locus, layout, \"center\"),\n                                          axis_tics_coordinates))\n            space_width = pdfmetrics.stringWidth(\" \", self.prms.args[\"x_axis_ticks_labels_font_face\"],\n                                                 axis_tics_label_size)\n            tics_labels_coordinates = axis_tics_position.copy()\n            for t_i in range(len(axis_tics_coordinates)):\n                label_width = axis_tics_label_width[t_i]\n                tick_position = axis_tics_position[t_i]\n                if t_i == 0:\n                    tics_labels_coordinates[t_i] += label_width * 0.5\n                elif t_i != len(axis_tics_coordinates) - 1:\n                    center_label_coordinates = [tick_position - 0.5 * label_width,\n                                                tick_position + 0.5 * label_width]\n                    if center_label_coordinates[0] - space_width &lt;= axis_tics_position[t_i - 1]:\n                        tics_labels_coordinates[t_i] += label_width * 0.5\n                        if axis_tics_position[t_i] - axis_tics_position[t_i - 1] &lt; space_width:\n                            tics_labels_coordinates[t_i] += space_width\n                    if center_label_coordinates[1] + space_width &gt;= axis_tics_position[t_i + 1]:\n                        tics_labels_coordinates[t_i] -= label_width * 0.5\n                        if axis_tics_position[t_i + 1] - axis_tics_position[t_i] &lt; space_width:\n                            tics_labels_coordinates[t_i] -= space_width\n                if tics_labels_coordinates[t_i] + label_width * 0.5 &gt; layout[\"loci_tracks_right_border\"]:\n                    tics_labels_coordinates[t_i] -= ((tics_labels_coordinates[t_i] + label_width * 0.5) -\n                                                     layout[\"loci_tracks_right_border\"])\n            track_data[\"x_axis_annotation\"][\"axis_regions\"] = axis_regions\n            track_data[\"x_axis_annotation\"][\"axis_tics_position\"] = axis_tics_position\n            track_data[\"x_axis_annotation\"][\"axis_tics_labels\"] = axis_tics_labels\n            track_data[\"x_axis_annotation\"][\"tics_labels_coordinates\"] = tics_labels_coordinates\n            return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare Locus specific data.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters","title":"<code>Parameters</code>","text":"<p>A Parameters object holds and parse command line's and config's arguments.</p> <p>A Parameters object have to be created in each script since it's used almost by each     class of the tool as a mandatory argument.</p> <p>Attributes:</p> <ul> <li> <code>args</code>             (<code>dict</code>)         \u2013          <p>dictionary that holds all arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class Parameters:\n    \"\"\"A Parameters object holds and parse command line's and config's arguments.\n\n    A Parameters object have to be created in each script since it's used almost by each\n        class of the tool as a mandatory argument.\n\n    Attributes:\n        args (dict): dictionary that holds all arguments.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Create a Parameters object.\n\n        \"\"\"\n        self.args = dict(debug=False, verbose=False)\n        self.cmd_arguments = dict()\n\n    def parse_cmd_arguments(self) -&gt; None:\n        \"\"\"Parse command-line args\n\n        Returns:\n            None\n\n        \"\"\"\n        parser = argparse.ArgumentParser(prog=\"lovis4u\", add_help=False,\n                                         usage=\"lovis4u [-gff gff_folder | -gb gb_folder] [optional args]\")\n        parser.add_argument(\"-data\", \"--data\", dest=\"lovis4u_data\", action=\"store_true\")\n        parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n        parser.add_argument(\"-mac\", \"--mac\", dest=\"mac\", action=\"store_true\", default=None)\n        mutually_exclusive_group = parser.add_mutually_exclusive_group()\n        mutually_exclusive_group.add_argument(\"-gff\", \"--gff\", dest=\"gff\", type=str, default=None)\n        mutually_exclusive_group.add_argument(\"-gb\", \"--gb\", dest=\"gb\", type=str, default=None)\n        parser.add_argument(\"-laf\", \"--loci-annotation-file\", dest=\"loci-annotation\", type=str, default=None)\n        parser.add_argument(\"-faf\", \"--features-annotation-file\", dest=\"features-annotation\", type=str, default=None)\n        parser.add_argument(\"-mmseqs-off\", \"--mmseqs-off\", dest=\"mmseqs\", action=\"store_false\")\n        parser.add_argument(\"-fv-off\", \"--find-variable-off\", dest=\"find-variable\", action=\"store_false\")\n        parser.add_argument(\"-cl-off\", \"--clust_loci-off\", dest=\"clust_loci\", action=\"store_false\")\n        parser.add_argument(\"-reorient_loci\", \"--reorient_loci\", dest=\"reorient_loci\", action=\"store_true\")\n        parser.add_argument(\"-lls\", \"--loci-label-style\", dest=\"locus_label_style\",\n                            choices=[\"id\", \"description\", \"full\"],\n                            default=None)\n        parser.add_argument(\"-sgc-off\", \"--set-group-color-off\", dest=\"set-group-color\", action=\"store_false\")\n        parser.add_argument(\"-sgcf\", \"--set-group-color-for\", dest=\"feature_group_types_to_set_color\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-scc\", \"--set-category-color\", dest=\"set-category-color\", action=\"store_true\")\n        parser.add_argument(\"-cct\", \"--category-color-table\", dest=\"category_colors\", type=str, default=None)\n        parser.add_argument(\"-safl\", \"--show-all-feature-labels\", dest=\"show_all_feature_labels\",\n                            action=\"store_true\")\n        parser.add_argument(\"-sflf\", \"--show-feature-label-for\", dest=\"feature_group_types_to_show_label\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-sfflf\", \"--show-first-feature-label-for\",\n                            dest=\"feature_group_types_to_show_label_on_first_occurrence\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-ifl\", \"--ignored-feature-labels\", dest=\"feature_labels_to_ignore\", nargs=\"*\",\n                            type=str, default=None)\n        parser.add_argument(\"-hl\", \"--homology-links\", dest=\"homology-track\", action=\"store_true\")\n        parser.add_argument(\"-slt\", \"--scale-line-track\", dest=\"scale-line-track\", action=\"store_true\")\n        parser.add_argument(\"-hix\", \"--hide-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_false\")\n        parser.add_argument(\"-dml\", \"--draw-middle-line\", dest=\"draw_middle_line\", action=\"store_true\")\n        parser.add_argument(\"-mm-per-nt\", \"--mm-per-nt\", dest=\"mm_per_nt\", type=float, default=None)\n        parser.add_argument(\"-fw\", \"--figure-width\", dest=\"figure_width\", type=float, default=None)\n        parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n        parser.add_argument(\"--pdf-name\", dest=\"pdf-name\", type=str, default=\"lovis4u.pdf\")\n        parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"standard\")\n        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.0.3\")\n        parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n        parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n        parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n        args = parser.parse_args()\n        args = vars(args)\n        if len(sys.argv[1:]) == 0:\n            args[\"help\"] = True\n        if args[\"lovis4u_data\"]:\n            lovis4u.Methods.copy_package_data()\n            sys.exit()\n        if args[\"linux\"]:\n            lovis4u.Methods.adjust_paths(\"linux\")\n            sys.exit()\n        if args[\"mac\"]:\n            lovis4u.Methods.adjust_paths(\"mac\")\n            sys.exit()\n        if args[\"help\"]:\n            help_message_path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"help.txt\")\n            with open(help_message_path, \"r\") as help_message:\n                print(help_message.read(), file=sys.stdout)\n                sys.exit()\n        if not args[\"gff\"] and not args[\"gb\"]:\n            raise lovis4u.Manager.lovis4uError(\"-gff or -gb parameter with folder path should be provided\")\n        args_to_keep = [\"loci-annotation\", \"features-annotation\", \"gb\", \"gff\", \"figure_width\"]\n        filtered_args = {k: v for k, v in args.items() if v is not None or k in args_to_keep}\n        self.cmd_arguments = filtered_args\n        return None\n\n    def load_config(self, path: str = \"standard\") -&gt; None:\n        \"\"\"Load configuration file.\n\n        Arguments\n            path (str): path to a config file or name (only standard available at this moment).\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if path == \"standard\":\n                path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"standard.cfg\")\n            config = configs.load(path).get_config()\n            internal_dir = os.path.dirname(__file__)\n            for key in config[\"root\"].keys():\n                if type(config[\"root\"][key]) is str and \"{internal}\" in config[\"root\"][key]:\n                    config[\"root\"][key] = config[\"root\"][key].replace(\"{internal}\",\n                                                                      os.path.join(internal_dir, \"lovis4u_data\"))\n            config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                                time.strftime(\"%Y_%m_%d-%H_%M\"))\n            keys_to_transform_to_list = [\"feature_group_types_to_set_color\", \"feature_group_types_to_show_label\",\n                                         \"genbank_id_alternative_source\", \"feature_labels_to_ignore\",\n                                         \"feature_group_types_to_show_label_on_first_occurrence\"]\n            for ktl in keys_to_transform_to_list:\n                if isinstance(config[\"root\"][ktl], str):\n                    if config[\"root\"][ktl] != \"None\":\n                        config[\"root\"][ktl] = [config[\"root\"][ktl]]\n                    else:\n                        config[\"root\"][ktl] = []\n            self.args.update(config[\"root\"])\n            self.load_palette()\n            self.load_fonts()\n            if self.cmd_arguments:\n                self.args.update(self.cmd_arguments)\n\n            if os.path.exists(self.args[\"output_dir\"]):\n                print(\"\u2757 Warning: the output folder already exists. Results will be rewritten (without removal other \"\n                      \"files in this folder)\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to parse the specified config file. Please check your config file \"\n                               \"or written name.\") from error\n\n    def load_palette(self) -&gt; None:\n        \"\"\"Load palette file.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            palette_path = self.args[f\"palette\"]\n            self.args[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to load palette.\") from error\n\n    def load_fonts(self) -&gt; None:\n        \"\"\"Load fonts.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            font_pattern = re.compile(r\"^font_(.*)$\")\n            font_subdict = {font_pattern.match(key).group(1): value for key, value in self.args.items() if\n                            font_pattern.match(key)}\n            for font_type, font_path in font_subdict.items():\n                pdfmetrics.registerFont(reportlab.pdfbase.ttfonts.TTFont(font_type, font_path))\n            return None\n        except Exception as error:\n            raise lovis4uError(\"Unable to load fonts.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.__init__","title":"<code>__init__()</code>","text":"<p>Create a Parameters object.</p> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self):\n    \"\"\"Create a Parameters object.\n\n    \"\"\"\n    self.args = dict(debug=False, verbose=False)\n    self.cmd_arguments = dict()\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.load_config","title":"<code>load_config(path='standard')</code>","text":"<p>Load configuration file.</p> <p>Arguments     path (str): path to a config file or name (only standard available at this moment).</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_config(self, path: str = \"standard\") -&gt; None:\n    \"\"\"Load configuration file.\n\n    Arguments\n        path (str): path to a config file or name (only standard available at this moment).\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if path == \"standard\":\n            path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"standard.cfg\")\n        config = configs.load(path).get_config()\n        internal_dir = os.path.dirname(__file__)\n        for key in config[\"root\"].keys():\n            if type(config[\"root\"][key]) is str and \"{internal}\" in config[\"root\"][key]:\n                config[\"root\"][key] = config[\"root\"][key].replace(\"{internal}\",\n                                                                  os.path.join(internal_dir, \"lovis4u_data\"))\n        config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                            time.strftime(\"%Y_%m_%d-%H_%M\"))\n        keys_to_transform_to_list = [\"feature_group_types_to_set_color\", \"feature_group_types_to_show_label\",\n                                     \"genbank_id_alternative_source\", \"feature_labels_to_ignore\",\n                                     \"feature_group_types_to_show_label_on_first_occurrence\"]\n        for ktl in keys_to_transform_to_list:\n            if isinstance(config[\"root\"][ktl], str):\n                if config[\"root\"][ktl] != \"None\":\n                    config[\"root\"][ktl] = [config[\"root\"][ktl]]\n                else:\n                    config[\"root\"][ktl] = []\n        self.args.update(config[\"root\"])\n        self.load_palette()\n        self.load_fonts()\n        if self.cmd_arguments:\n            self.args.update(self.cmd_arguments)\n\n        if os.path.exists(self.args[\"output_dir\"]):\n            print(\"\u2757 Warning: the output folder already exists. Results will be rewritten (without removal other \"\n                  \"files in this folder)\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to parse the specified config file. Please check your config file \"\n                           \"or written name.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.load_fonts","title":"<code>load_fonts()</code>","text":"<p>Load fonts.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_fonts(self) -&gt; None:\n    \"\"\"Load fonts.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        font_pattern = re.compile(r\"^font_(.*)$\")\n        font_subdict = {font_pattern.match(key).group(1): value for key, value in self.args.items() if\n                        font_pattern.match(key)}\n        for font_type, font_path in font_subdict.items():\n            pdfmetrics.registerFont(reportlab.pdfbase.ttfonts.TTFont(font_type, font_path))\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to load fonts.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.load_palette","title":"<code>load_palette()</code>","text":"<p>Load palette file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def load_palette(self) -&gt; None:\n    \"\"\"Load palette file.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        palette_path = self.args[f\"palette\"]\n        self.args[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n        return None\n    except Exception as error:\n        raise lovis4uError(\"Unable to load palette.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.Parameters.parse_cmd_arguments","title":"<code>parse_cmd_arguments()</code>","text":"<p>Parse command-line args</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def parse_cmd_arguments(self) -&gt; None:\n    \"\"\"Parse command-line args\n\n    Returns:\n        None\n\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"lovis4u\", add_help=False,\n                                     usage=\"lovis4u [-gff gff_folder | -gb gb_folder] [optional args]\")\n    parser.add_argument(\"-data\", \"--data\", dest=\"lovis4u_data\", action=\"store_true\")\n    parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n    parser.add_argument(\"-mac\", \"--mac\", dest=\"mac\", action=\"store_true\", default=None)\n    mutually_exclusive_group = parser.add_mutually_exclusive_group()\n    mutually_exclusive_group.add_argument(\"-gff\", \"--gff\", dest=\"gff\", type=str, default=None)\n    mutually_exclusive_group.add_argument(\"-gb\", \"--gb\", dest=\"gb\", type=str, default=None)\n    parser.add_argument(\"-laf\", \"--loci-annotation-file\", dest=\"loci-annotation\", type=str, default=None)\n    parser.add_argument(\"-faf\", \"--features-annotation-file\", dest=\"features-annotation\", type=str, default=None)\n    parser.add_argument(\"-mmseqs-off\", \"--mmseqs-off\", dest=\"mmseqs\", action=\"store_false\")\n    parser.add_argument(\"-fv-off\", \"--find-variable-off\", dest=\"find-variable\", action=\"store_false\")\n    parser.add_argument(\"-cl-off\", \"--clust_loci-off\", dest=\"clust_loci\", action=\"store_false\")\n    parser.add_argument(\"-reorient_loci\", \"--reorient_loci\", dest=\"reorient_loci\", action=\"store_true\")\n    parser.add_argument(\"-lls\", \"--loci-label-style\", dest=\"locus_label_style\",\n                        choices=[\"id\", \"description\", \"full\"],\n                        default=None)\n    parser.add_argument(\"-sgc-off\", \"--set-group-color-off\", dest=\"set-group-color\", action=\"store_false\")\n    parser.add_argument(\"-sgcf\", \"--set-group-color-for\", dest=\"feature_group_types_to_set_color\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-scc\", \"--set-category-color\", dest=\"set-category-color\", action=\"store_true\")\n    parser.add_argument(\"-cct\", \"--category-color-table\", dest=\"category_colors\", type=str, default=None)\n    parser.add_argument(\"-safl\", \"--show-all-feature-labels\", dest=\"show_all_feature_labels\",\n                        action=\"store_true\")\n    parser.add_argument(\"-sflf\", \"--show-feature-label-for\", dest=\"feature_group_types_to_show_label\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-sfflf\", \"--show-first-feature-label-for\",\n                        dest=\"feature_group_types_to_show_label_on_first_occurrence\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-ifl\", \"--ignored-feature-labels\", dest=\"feature_labels_to_ignore\", nargs=\"*\",\n                        type=str, default=None)\n    parser.add_argument(\"-hl\", \"--homology-links\", dest=\"homology-track\", action=\"store_true\")\n    parser.add_argument(\"-slt\", \"--scale-line-track\", dest=\"scale-line-track\", action=\"store_true\")\n    parser.add_argument(\"-hix\", \"--hide-x-axis\", dest=\"draw_individual_x_axis\", action=\"store_false\")\n    parser.add_argument(\"-dml\", \"--draw-middle-line\", dest=\"draw_middle_line\", action=\"store_true\")\n    parser.add_argument(\"-mm-per-nt\", \"--mm-per-nt\", dest=\"mm_per_nt\", type=float, default=None)\n    parser.add_argument(\"-fw\", \"--figure-width\", dest=\"figure_width\", type=float, default=None)\n    parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n    parser.add_argument(\"--pdf-name\", dest=\"pdf-name\", type=str, default=\"lovis4u.pdf\")\n    parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"standard\")\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.0.3\")\n    parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n    parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n    parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n    args = parser.parse_args()\n    args = vars(args)\n    if len(sys.argv[1:]) == 0:\n        args[\"help\"] = True\n    if args[\"lovis4u_data\"]:\n        lovis4u.Methods.copy_package_data()\n        sys.exit()\n    if args[\"linux\"]:\n        lovis4u.Methods.adjust_paths(\"linux\")\n        sys.exit()\n    if args[\"mac\"]:\n        lovis4u.Methods.adjust_paths(\"mac\")\n        sys.exit()\n    if args[\"help\"]:\n        help_message_path = os.path.join(os.path.dirname(__file__), \"lovis4u_data\", \"help.txt\")\n        with open(help_message_path, \"r\") as help_message:\n            print(help_message.read(), file=sys.stdout)\n            sys.exit()\n    if not args[\"gff\"] and not args[\"gb\"]:\n        raise lovis4u.Manager.lovis4uError(\"-gff or -gb parameter with folder path should be provided\")\n    args_to_keep = [\"loci-annotation\", \"features-annotation\", \"gb\", \"gff\", \"figure_width\"]\n    filtered_args = {k: v for k, v in args.items() if v is not None or k in args_to_keep}\n    self.cmd_arguments = filtered_args\n    return None\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader","title":"<code>ScaleLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A LocusLoader object prepares data for a Scale track Drawing object.</p> <p>Attributes:</p> <ul> <li> <code>prms</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> <li> <code>track_data</code>             (<code>dict</code>)         \u2013          <p>Track specific data that will be sent to the Drawing module.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>class ScaleLoader(Loader):\n    \"\"\"A LocusLoader object prepares data for a Scale track Drawing object.\n\n    Attributes:\n        prms (Parameters): Parameters' class object.\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n        track_data (dict): Track specific data that will be sent to the Drawing module.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a ScaleLoader object.\n\n        Arguments:\n            parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_track_specific_data(self, layout: dict) -&gt; None:\n        \"\"\"Prepare ScaleLoader specific data.\n\n        Attributes:\n            layout (dict): Layout built by CanvasManager's define_layout() method.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.layout = layout\n            total_nt_width = self.layout[\"total_nt_width\"]\n            raw_scale_line_nt_width = round(total_nt_width * self.prms.args[\"scale_line_relative_size\"])\n            raw_scale_line_nt_width_pow = int(math.log(raw_scale_line_nt_width, 10))\n            scale_line_nt_width = round(raw_scale_line_nt_width // math.pow(10, raw_scale_line_nt_width_pow) *\n                                        math.pow(10, raw_scale_line_nt_width_pow))\n            track_data = dict()\n            self.track_data = track_data\n            track_data[\"scale_line_nt_width\"] = scale_line_nt_width\n            track_data[\"coordinates\"] = [self.layout[\"loci_tracks_left_border\"],\n                                         self.layout[\"loci_tracks_left_border\"] +\n                                         layout[\"width_per_nt\"] * scale_line_nt_width]\n            track_data[\"scale_line_width\"] = track_data[\"coordinates\"][1] - track_data[\"coordinates\"][0]\n            track_data[\"scale_label\"] = f\"{scale_line_nt_width} nt\"\n            track_data[\"scale_label_font_size\"] = lovis4u.Methods.str_height_to_size(\n                self.prms.args[\"scale_line_label_height\"] * cm, self.prms.args[\"scale_line_label_font_face\"])\n            track_data[\"scale_line_label_width\"] = pdfmetrics.stringWidth(track_data[\"scale_label\"],\n                                                                          self.prms.args[\"scale_line_label_font_face\"],\n                                                                          track_data[\"scale_label_font_size\"])\n            if (track_data[\"scale_line_width\"] - track_data[\"scale_line_label_width\"]) / \\\n                    track_data[\"scale_line_width\"] &gt; 0.1:\n                track_data[\"style\"] = \"fancy\"\n                track_data[\"space_width\"] = pdfmetrics.stringWidth(\" \", self.prms.args[\"scale_line_label_font_face\"],\n                                                                   track_data[\"scale_label_font_size\"])\n            else:\n                track_data[\"style\"] = \"default\"\n            return None\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to prepare scale track specific data.\") from error\n\n    def calculate_track_height(self):\n        \"\"\"Calculate track height to define layout.\n\n        Returns:\n            float: track height.\n\n        \"\"\"\n        try:\n            if self.track_data[\"style\"] == \"fancy\":\n                track_height = self.prms.args[\"scale_line_label_height\"] * cm\n            else:\n                track_height = (1.2 * self.prms.args[\"scale_line_tics_height\"] +\n                                self.prms.args[\"scale_line_label_height\"]) * cm\n            self.track_data[\"track_height\"] = track_height\n            return track_height\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to calculate a scale track height.\") from error\n\n    def create_track(self):\n        \"\"\"Initialise a ScaleVis track object.\n\n        Returns:\n            lovis4u.Drawing.LocusVis: visualisation track.\n\n        \"\"\"\n        try:\n            return lovis4u.Drawing.ScaleVis(self.layout, self.track_data, self.prms)\n        except Exception as error:\n            raise lovis4u.Manager.lovis4uError(\"Unable to create a scale track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a ScaleLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object that holds config and cmd arguments.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a ScaleLoader object.\n\n    Arguments:\n        parameters (Parameters): Parameters' class object that holds config and cmd arguments.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.calculate_track_height","title":"<code>calculate_track_height()</code>","text":"<p>Calculate track height to define layout.</p> <p>Returns:</p> <ul> <li> <code>float</code>        \u2013          <p>track height.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def calculate_track_height(self):\n    \"\"\"Calculate track height to define layout.\n\n    Returns:\n        float: track height.\n\n    \"\"\"\n    try:\n        if self.track_data[\"style\"] == \"fancy\":\n            track_height = self.prms.args[\"scale_line_label_height\"] * cm\n        else:\n            track_height = (1.2 * self.prms.args[\"scale_line_tics_height\"] +\n                            self.prms.args[\"scale_line_label_height\"]) * cm\n        self.track_data[\"track_height\"] = track_height\n        return track_height\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to calculate a scale track height.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a ScaleVis track object.</p> <p>Returns:</p> <ul> <li>         \u2013          <p>lovis4u.Drawing.LocusVis: visualisation track.</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def create_track(self):\n    \"\"\"Initialise a ScaleVis track object.\n\n    Returns:\n        lovis4u.Drawing.LocusVis: visualisation track.\n\n    \"\"\"\n    try:\n        return lovis4u.Drawing.ScaleVis(self.layout, self.track_data, self.prms)\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to create a scale track object.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.ScaleLoader.prepare_track_specific_data","title":"<code>prepare_track_specific_data(layout)</code>","text":"<p>Prepare ScaleLoader specific data.</p> <p>Attributes:</p> <ul> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout built by CanvasManager's define_layout() method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Manager.py</code> <pre><code>def prepare_track_specific_data(self, layout: dict) -&gt; None:\n    \"\"\"Prepare ScaleLoader specific data.\n\n    Attributes:\n        layout (dict): Layout built by CanvasManager's define_layout() method.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.layout = layout\n        total_nt_width = self.layout[\"total_nt_width\"]\n        raw_scale_line_nt_width = round(total_nt_width * self.prms.args[\"scale_line_relative_size\"])\n        raw_scale_line_nt_width_pow = int(math.log(raw_scale_line_nt_width, 10))\n        scale_line_nt_width = round(raw_scale_line_nt_width // math.pow(10, raw_scale_line_nt_width_pow) *\n                                    math.pow(10, raw_scale_line_nt_width_pow))\n        track_data = dict()\n        self.track_data = track_data\n        track_data[\"scale_line_nt_width\"] = scale_line_nt_width\n        track_data[\"coordinates\"] = [self.layout[\"loci_tracks_left_border\"],\n                                     self.layout[\"loci_tracks_left_border\"] +\n                                     layout[\"width_per_nt\"] * scale_line_nt_width]\n        track_data[\"scale_line_width\"] = track_data[\"coordinates\"][1] - track_data[\"coordinates\"][0]\n        track_data[\"scale_label\"] = f\"{scale_line_nt_width} nt\"\n        track_data[\"scale_label_font_size\"] = lovis4u.Methods.str_height_to_size(\n            self.prms.args[\"scale_line_label_height\"] * cm, self.prms.args[\"scale_line_label_font_face\"])\n        track_data[\"scale_line_label_width\"] = pdfmetrics.stringWidth(track_data[\"scale_label\"],\n                                                                      self.prms.args[\"scale_line_label_font_face\"],\n                                                                      track_data[\"scale_label_font_size\"])\n        if (track_data[\"scale_line_width\"] - track_data[\"scale_line_label_width\"]) / \\\n                track_data[\"scale_line_width\"] &gt; 0.1:\n            track_data[\"style\"] = \"fancy\"\n            track_data[\"space_width\"] = pdfmetrics.stringWidth(\" \", self.prms.args[\"scale_line_label_font_face\"],\n                                                               track_data[\"scale_label_font_size\"])\n        else:\n            track_data[\"style\"] = \"default\"\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(\"Unable to prepare scale track specific data.\") from error\n</code></pre>"},{"location":"API/package_manager/#lovis4u.Manager.lovis4uError","title":"<code>lovis4uError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A class for exceptions parsing inherited from the Exception class.</p> Source code in <code>lovis4u/Manager.py</code> <pre><code>class lovis4uError(Exception):\n    \"\"\"A class for exceptions parsing inherited from the Exception class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_methods/","title":"lovis4u.Methods","text":"<p>This module provides some methods (e.g. colors tranformation, data copying) used by the tool.</p>"},{"location":"API/package_methods/#lovis4u.Methods.adjust_paths","title":"<code>adjust_paths(to)</code>","text":"<p>Change paths in the internal config files for linux or mac.</p> <p>Parameters:</p> <ul> <li> <code>to</code>             (<code>str</code>)         \u2013          <p>mac | linux</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def adjust_paths(to: str) -&gt; None:\n    \"\"\"Change paths in the internal config files for linux or mac.\n\n    Arguments:\n        to (str): mac | linux\n\n    Returns:\n        None\n\n    \"\"\"\n    internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n    config_files = [\"standard.cfg\"]\n    for config_file in config_files:\n        config_file_path = os.path.join(internal_dir, config_file)\n        with open(config_file_path, \"r+\") as config:\n            if to == \"linux\":\n                if not os.path.exists(os.path.join(internal_dir, \"bin/mmseqs_linux\")):\n                    os.system(f\"unzip -q -d {os.path.join(internal_dir, 'bin/')} \"\n                              f\"{os.path.join(internal_dir, 'bin/mmseqs_linux.zip')}\")\n                config_txt = re.sub(r\"mmseqs_mac/bin/mmseqs\", \"mmseqs_linux/bin/mmseqs\", config.read())\n            else:\n                config_txt = re.sub(r\"mmseqs_linux/bin/mmseqs\", \"mmseqs_mac/bin/mmseqs\", config.read())\n            config.seek(0)\n            config.truncate()\n            config.write(config_txt)\n    print(f\"\u2699\ufe0f  mmseqs path was adjusted to {to}\")\n    return None\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.copy_package_data","title":"<code>copy_package_data()</code>","text":"<p>Copy the lovis4u package data folder to your current dir.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def copy_package_data() -&gt; None:\n    \"\"\"Copy the lovis4u package data folder to your current dir.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        users_dir = os.path.join(os.getcwd(), \"lovis4u_data\")\n        internal_dir = os.path.join(os.path.dirname(__file__), \"lovis4u_data\")\n        if os.path.exists(users_dir):\n            raise lovis4u.Manager.lovis4uError(\"lovis4u_data folder already exists.\")\n        shutil.copytree(internal_dir, users_dir, ignore=shutil.ignore_patterns(\"help*\", \".*\"))\n        print(\"\ud83d\uddc3\ufe0f lovis4u_data folder was copied to the current working directory\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise lovis4u.Manager.lovis4uError(f\"Unable to copy lovis4u folder in your working dir.\") from error\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.feature_nt_to_x_transform","title":"<code>feature_nt_to_x_transform(nt_start, nt_end, feature_strand, locus, layout)</code>","text":"<p>Transform feature coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>feature_strand</code>             (<code>int</code>)         \u2013          <p>1 | -1 corresponding to plus or minus strand, respectively.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def feature_nt_to_x_transform(nt_start: int, nt_end: int, feature_strand: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform feature coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        feature_strand (int): 1 | -1 corresponding to plus or minus strand, respectively.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    left_out, right_out = False, False\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] or coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if nt_start &lt; coordinate[\"start\"]:\n                if coordinate[\"strand\"] == 1:\n                    left_out = True\n                else:\n                    right_out = True\n                nt_start = coordinate[\"start\"]\n            if nt_end &gt; coordinate[\"end\"]:\n                if coordinate[\"strand\"] == 1:\n                    right_out = True\n                else:\n                    left_out = True\n                nt_end = coordinate[\"end\"]\n            x_coordinates = region_nt_to_x_transform(nt_start, nt_end, locus, layout)\n            x_coordinates[\"center\"] = (x_coordinates[\"start\"] + x_coordinates[\"end\"]) / 2\n            x_coordinates[\"orient\"] = feature_strand * coordinate[\"strand\"]\n            x_coordinates[\"lout\"] = left_out\n            x_coordinates[\"rout\"] = right_out\n            break\n    return x_coordinates\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.get_color","title":"<code>get_color(name, parameters)</code>","text":"<p>Get HEX color by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a color.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>HEX color.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_color(name: str, parameters: dict) -&gt; str:\n    \"\"\"Get HEX color by its name\n\n    Arguments:\n        name (str): name of a color.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        str: HEX color.\n\n    \"\"\"\n    hex_c = parameters.args[\"palette\"][parameters.args[name]]\n    return hex_c\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.get_color_rgba","title":"<code>get_color_rgba(name, parameters)</code>","text":"<p>Get rgba color by its name</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a color.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (            <code>tuple</code> )        \u2013          <p>RGBA color</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def get_color_rgba(name: str, parameters: dict) -&gt; tuple:\n    \"\"\"Get rgba color by its name\n\n    Arguments:\n        name (str): name of a color.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        tuple: RGBA color\n\n    \"\"\"\n    return *matplotlib.colors.hex2color(get_color(name, parameters)), parameters.args[f\"{name}_alpha\"]\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.nt_to_x_transform","title":"<code>nt_to_x_transform(nt, locus, layout, mode)</code>","text":"<p>Transform nucleotide coordinate to x page coordinate.</p> <p>Parameters:</p> <ul> <li> <code>nt</code>             (<code>int</code>)         \u2013          <p>Nucleotide coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> <li> <code>mode</code>             (<code>str</code>)         \u2013          <p>Mode whether coordinate should be centered to the nt or on the side.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>Corresponding page coordinate.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def nt_to_x_transform(nt: int, locus, layout: dict, mode: str) -&gt; float:\n    \"\"\"Transform nucleotide coordinate to x page coordinate.\n\n    Arguments:\n        nt (int): Nucleotide coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n        mode (str): Mode whether coordinate should be centered to the nt or on the side.\n\n    Returns:\n        float: Corresponding page coordinate.\n\n    \"\"\"\n    passed_x = layout[\"loci_tracks_left_border\"]\n    for c_i in range(len(locus.coordinates)):\n        coordinate = locus.coordinates[c_i]\n        coordinate_region_width = (coordinate[\"end\"] - coordinate[\"start\"] + 1) * layout[\"width_per_nt\"]\n        if coordinate[\"start\"] &lt;= nt &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == 1:\n                relative_nt = nt - coordinate[\"start\"]\n            else:\n                relative_nt = coordinate[\"end\"] - nt\n            if mode == \"start\":\n                pass\n            elif mode == \"center\":\n                relative_nt += 0.5\n            elif mode == \"end\":\n                relative_nt += 1\n            relative_x = relative_nt * layout[\"width_per_nt\"]\n            global_x = passed_x + relative_x\n            break\n        passed_x += coordinate_region_width + layout[\"x_gap_between_regions\"]\n        if c_i &lt; len(locus.coordinates) - 1:\n            if locus.circular:\n                if coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == 1:\n                    if coordinate[\"end\"] == locus.length and locus.coordinates[c_i + 1][\"start\"] == 1:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n                elif coordinate[\"strand\"] == locus.coordinates[c_i + 1][\"strand\"] == -1:\n                    if coordinate[\"start\"] == 1 and locus.coordinates[c_i + 1][\"end\"] == locus.length:\n                        passed_x -= layout[\"x_gap_between_regions\"]\n    return global_x\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.region_nt_to_x_transform","title":"<code>region_nt_to_x_transform(nt_start, nt_end, locus, layout)</code>","text":"<p>Transform region coordinates to x page coordinates.</p> <p>Parameters:</p> <ul> <li> <code>nt_start</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide start coordinate.</p> </li> <li> <code>nt_end</code>             (<code>int</code>)         \u2013          <p>1-based nucleotide end coordinate.</p> </li> <li> <code>locus</code>             (<code>Locus</code>)         \u2013          <p>Corresponding locus object.</p> </li> <li> <code>layout</code>             (<code>dict</code>)         \u2013          <p>Layout of the canvas.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>Dictionary with corresponding start and end page coordinates.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def region_nt_to_x_transform(nt_start: int, nt_end: int, locus, layout: dict) -&gt; dict:\n    \"\"\"Transform region coordinates to x page coordinates.\n\n    Arguments:\n        nt_start (int): 1-based nucleotide start coordinate.\n        nt_end (int): 1-based nucleotide end coordinate.\n        locus (lovis4u.DataProcessing.Locus): Corresponding locus object.\n        layout (dict): Layout of the canvas.\n\n    Returns:\n        dict: Dictionary with corresponding start and end page coordinates.\n\n    \"\"\"\n    for coordinate in locus.coordinates:\n        if coordinate[\"start\"] &lt;= nt_start &lt;= coordinate[\"end\"] and coordinate[\"start\"] &lt;= nt_end &lt;= coordinate[\"end\"]:\n            if coordinate[\"strand\"] == -1:\n                nt_start, nt_end = nt_end, nt_start\n            x_start = nt_to_x_transform(nt_start, locus, layout, \"start\")\n            x_end = nt_to_x_transform(nt_end, locus, layout, \"end\")\n            break\n    return dict(start=x_start, end=x_end)\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.scale_lightness","title":"<code>scale_lightness(hex_c, scale_l)</code>","text":"<p>Helper function to get darker version of input color</p> <p>Parameters:</p> <ul> <li> <code>hex_c</code>             (<code>str</code>)         \u2013          <p>input HEX color</p> </li> <li> <code>scale_l</code>             (<code>float</code>)         \u2013          <p>scale of lightness</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>new HEX color</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def scale_lightness(hex_c: str, scale_l: float) -&gt; str:\n    \"\"\"Helper function to get darker version of input color\n\n    Arguments:\n        hex_c (str): input HEX color\n        scale_l (float): scale of lightness\n\n    Returns:\n        str: new HEX color\n\n    \"\"\"\n    rgb = matplotlib.colors.hex2color(hex_c)\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n    hex_c = matplotlib.colors.rgb2hex(colorsys.hls_to_rgb(h, min(1, l * scale_l), s=s))\n    return hex_c\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.str_height_to_size","title":"<code>str_height_to_size(height, font_type)</code>","text":"<p>Transform string height to the font size.</p> <p>Parameters:</p> <ul> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>available height of the string.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>font size defined by height.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def str_height_to_size(height: float, font_type: str) -&gt; float:\n    \"\"\"Transform string height to the font size.\n\n    Arguments:\n        height (float): available height of the string.\n        font_type (str): font type (see config file; at this moment only regular is available).\n\n    Returns:\n        float: font size defined by height.\n\n    \"\"\"\n\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    font_size = (1000 * 1.38 * height) / (face.ascent - face.descent)\n    return font_size\n</code></pre>"},{"location":"API/package_methods/#lovis4u.Methods.update_path_extension","title":"<code>update_path_extension(path, new_extension)</code>","text":"<p>Get path basename and replace its extension</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>path to a file</p> </li> <li> <code>new_extension</code>             (<code>str</code>)         \u2013          <p>new extension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>basename of a file with new extension.</p> </li> </ul> Source code in <code>lovis4u/Methods.py</code> <pre><code>def update_path_extension(path: str, new_extension: str) -&gt; str:\n    \"\"\"Get path basename and replace its extension\n\n    Arguments:\n        path (str): path to a file\n        new_extension (str): new extension\n\n    Returns:\n        str: basename of a file with new extension.\n\n    \"\"\"\n    updated_filename = f\"{os.path.splitext(os.path.basename(path))[0]}.{new_extension}\"\n    return updated_filename\n</code></pre>"},{"location":"API/usage_examples/","title":"Short example-drived guide to LoVis4u API.","text":"<p>LoVis4u has a simple API allowing it programmatic usage from within a python program. Below we descrive several Python snippets that mimic results of command-line calls.</p> <pre><code>import lovis4u\n</code></pre> <p>Under construction...</p>"},{"location":"ExampleDrivenGuide/cmd_guide/","title":"Example-driven guide","text":"<p>Here we show usage examples of lovis4u command-line interface. Through this guide we will show step-by-step how you can optimise your visualisation starting from default parameters.</p> <p>Before start: The necessary sample data as well as adjustable tool configuration files are provided by lovis4u at the post-install step:   <code>lovis4u --data</code> which copies lovis4u_data folder to your working directory. </p> <p>If you work on a Linux machine after installation you should run: <code>uorf4u --linux</code> This command replaces the tools paths (MMseqs2) in the pre-made config files from the MacOS version (default) to the Linux. If you run it for fun and want to change it back you can use <code>uorfu --mac</code>.</p> <p>For demonstration we will use pharokka generated gff files with sequences of 5 Enterobacteria phages. Gff files are stored at: lovis4u_data/guide/gff_files.  The main difference of pharokka generated gff files from regular gff3 (for ex. which you can download from the NCBI) is that in addition to annotation rows they contain corresponding to the annotation nucleotide sequence. </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#example-run-with-default-parameters","title":"Example run with default parameters","text":"<p>Let's start with running lovis4u without using any optional argument. The only mandatory argument is a folder path containing pharokka generated gff (<code>-gff</code>) files or genbank files (<code>-gb</code>).   </p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files\n</code></pre> <p>As results of running this command an output folder named lovis4u_{current_date} (e.g. lovis4u_2024_04_28-16_36) will be created. Name of the output folder can be changed with <code>-o &lt;output_folder_name&gt;</code>.</p> <p>Output folder structure:</p> <ul> <li>lovis4u.pdf - vector graphic output (file name can be changed with <code>--pdf-name &lt;filename&gt;</code> parameter)  </li> <li>loci_annotation_table.tsv - table containing annotation (sequence_id, length, coordinates, etc..) for each locus.  </li> <li>features_annotation_table.tsv - table containing annotation (feature_id, locus_id, coordinates, etc..) for each feature (e.g. CDS)  </li> <li>mmseqs (folder)  <ul> <li>DB - folder with mmseqs' databases.  </li> <li>mmmseqs_clustering.tsv - table with proteomes clustering results.  </li> <li>mmmseqs_(stdout/stderr).txt - mmseqs logs.  </li> <li>input_proteins.fa - fasta file with all annotated protein sequences (input to mmseqs).  </li> </ul> </li> <li>proteome_similarity_matrix.tsv - pairwise proteome similarity scores indicating fraction of shared proteins homologues.  </li> </ul> <p>Visualisation results: </p> <p>By default, lovis4u utilises the following data preprocessing steps:</p> <ol> <li>Full length of each locus are taken for analysis (this can be adjusted using loci annotation table, see below). </li> <li>All proteins annotated on input sequences are used as input for MMseqs2 clustering (can be deactivated with <code>--mmseqs-off</code> parameter). MMseqs2 arguments can be adjusted using config file. Proteins clustered together are considered as a set of homologues. Based on that the \"group\" attribute of each CDS is set. </li> <li>Taking into account information about set of homologues from the previous step, lovis4u applies similarity based hierarchical clustering of corresponding proteomes with which it finds optimal order for visualisation and set \"group\" attribute for each locus. The purpose is to group together only related proteomes (keeping average proteome set similarity &gt; ~80%). This step can be skipped with (<code>-cl-off</code> or <code>--clust_loci-off</code>) parameter.</li> <li>Defining feature attribute \"group_type\" which allows to apply visualisation parameter targeting particular set of feature groups (e.g. set color or show labels only for \"group_type\" = \"variable\"). By default it sets group_type \"variable\" for CDS features that found in less than 0.25 of loci within the loci group and \"shell/core\" for others. </li> <li>Setting feature color based on feature \"group\" attribute (can be deactivated with <code>-sgc-off</code> or <code>--set-group-color-off</code>). Be default it sets distinct colours only for features with group_type \"variable\". But, you can change it with <code>-sgcf</code> or <code>--set-group-color-for</code>. For example, if you want to set color only for features with group_type \"shel/core\", run <code>--set-group-color-for shell/core</code>. </li> <li>Defining labels to be shown. By default lovis4u shows all labels for \"variable\" features and only first occurrence for \"shell/core\" features. You can show all labels with <code>--show-all-feature-labels</code> or specify group types for which all labels will be shown with <code>-sflf</code> or <code>--show-feature-label-for</code>. Additionally, by default lovis4u ignores labels:  hypothetical protein, unknown protein. The list of ignored labels can be set with <code>-ifl, --ignored-feature-labels &lt;feature_label1 [feature_label2 ...]&gt;</code>. The list with this argument can be left empty to not filter out labels by their name.</li> </ol> <p>We also consider corresponding parameters as highly useful for basic runs:</p> <ul> <li><code>--reorient_loci</code> - Auto re-orient loci (set new strands) if they are not matched.  Function tries to maximise co-orientation of homologous features.</li> <li><code>-hl</code>, <code>--homology-links</code> - Draw homology link track.</li> <li><code>-o &lt;name&gt;</code> - Output dir name.  </li> </ul> <p>While loci in our test set are already correctly orientated, let's add -hl parameter to update the output.</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl -o lovis4u_output\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#using-loci-annotation-table","title":"Using loci annotation table","text":"<p>As it was already mentioned, full length of each locus is taken for visualisation by default. However, you can specify coordinates of multiple regions for each locus to be shown. This coordinates together with other information about each locus can be specified in loci annotation table and used as input with <code>-laf</code> or <code>--loci-annotation-file</code> parameter. </p> <p>Additionally, after each run lovis4u saves the loci_annotation_table.tsv with annotation parameters used in this particular run. If no table was specified by input then all annotation columns are set with default values.  </p> <p>Default table generated from previous runs:</p> sequence_id length coordinates circular description order group initial_order RefSeq_NC_005056.1 32684 1:32684:1 1 Escherichia phage Wphi 0 1 3 RefSeq_NC_049461.1 31834 1:31834:1 1 Bacteriophage R18C 1 1 1 RefSeq_NC_001895.1 33593 1:33593:1 1 Enterobacteria phage P2 2 1 0 RefSeq_NC_049457.1 33807 1:33807:1 1 Escherichia phage vB_EcoM-12474III 3 1 4 RefSeq_NC_028943.1 29237 1:29237:1 1 Escherichia phage pro483 4 1 2 <p>After default run we can take the output loci_annotation_table and edit information we want to change. Important to note that we can use as input a table only with subset of columns (only sequence_id column is essential), for other columns or empty cells, lovis4u will set default values.</p> <p>For example, let's use this table as input:</p> sequence_id coordinates order group RefSeq_NC_005056.1 18320:24320:1,31684:32684:1,1:9360:1 0 1 RefSeq_NC_049461.1 16745:22745:1,30834:31834:1,1:7016:1 1 1 RefSeq_NC_001895.1 18294:24294:1,32593:33593:1,1:8460:1 2 1 RefSeq_NC_049457.1 19308:25308:1,32807:33807:1,1:9474:1 3 1 RefSeq_NC_028943.1 14839:20839:1,28237:29237:1,1:6321:1 4 1 <p>Here we specified only the coordinates, order and group for each locus. Order and group are also specified and kept since it's logical to use clustering results defined on full locus length run and to turn off new attempt to cluster sequences with <code>-cl-off, --clust_loci-off</code> parameter.   </p> <p>Format for coordinates specification: comma-separated list of start:end:strand. Start and end are in 1-based format, strand: 1 for plus strand and -1 for minus.</p> <p>The table can be found in the guide folder: lovis4u_data/guide/loci_annotation_table_alt.tsv</p> <p>Now we can run:  <pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl -o lovis4u_output \\\n    --loci-annotation-file lovis4u_data/guide/loci_annotation_table_alt.tsv -cl-off\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#using-features-annotation-table","title":"Using features annotation table","text":"<p>Similar way of adjusting features visualisation parameters is implemented. After each run a features_annotation_table.tsv file is saved in your output folder. Below you can see header of default table created with default parameter run.</p> feature_id locus_id coordinates feature_type name group group_type category fill_color stroke_color show_label RefSeq_NC_001895.1_CDS_0001 RefSeq_NC_001895.1 64:2286:1 CDS nicking at origin of replication RefSeq_NC_005056.1_CDS_0001 shell/core \"DNA, RNA and nucleotide metabolism\" default default 0 RefSeq_NC_001895.1_CDS_0002 RefSeq_NC_001895.1 2283:2612:1 CDS hypothetical protein RefSeq_NC_005056.1_CDS_0002 shell/core unknown function default default 0 RefSeq_NC_001895.1_CDS_0003 RefSeq_NC_001895.1 2651:3412:-1 CDS hypothetical protein RefSeq_NC_001895.1_CDS_0003 variable unknown function #aa9b35 default 0 RefSeq_NC_001895.1_CDS_0004 RefSeq_NC_001895.1 3587:5347:-1 CDS hypothetical protein RefSeq_NC_001895.1_CDS_0004 variable unknown function #f4767a default 0 RefSeq_NC_001895.1_CDS_0005 RefSeq_NC_001895.1 5347:5517:-1 CDS hypothetical protein RefSeq_NC_001895.1_CDS_0005 variable unknown function #f47763 default 0 <p>And here we also can use in input with parameter <code>-faf</code> or <code>--features-annotation-file</code> a table that contains only subset of annotation columns. For example, you can specify only new label and color for a particular CDS.</p> feature_id name fill_color show_label RefSeq_NC_001895.1_CDS_0001 Updated Name :) #e54e86 1 <p>This table can be found in the guide folder: lovis4u_data/guide/features_annotation_table_alt.tsv</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files  -hl -o lovis4u_output \\\n    --loci-annotation-file lovis4u_data/guide/loci_annotation_table_alt.tsv -cl-off \\\n    --features-annotation-file lovis4u_data/guide/features_annotation_table_alt.tsv\n</code></pre> </p> <p>Here also important to note that if you don't use feature attribute \"group_type\" defined by full loci run, then it will be re-defined by mmseqs run on subset of proteins found only in specified regions (you can deactivate it with <code>--find-variable-off</code> and <code>--mmseqs-off</code>) . It can result in situation that ORF called in that case \"variable\" in reality are encoded by each proteome but outside of their shown coordinates. </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#other-features","title":"Other features","text":""},{"location":"ExampleDrivenGuide/cmd_guide/#category-color-and-annotation","title":"Category color and annotation","text":"<p>Using parameter <code>--set-category-color</code> you can use category annotation column for features. By default it was designed to parse PHROGs category annotation for proteins and retrieve information about category in \"function\" qualifiers in Genbank or GFF files (used qualifiers can be changed in config file). However, you can set up category for each CDS using described above features annotation table with \"category\" column. Additionally, you can set up color code for your categories using <code>--category-color-table</code>. For categories not found in a table a random color will be set. By default, lovis4u uses pre-made color table which location is lovis4u_data/category_colors.tsv. </p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-category-color\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#scale-line-instead-of-individual-x-axis","title":"Scale line instead of individual x-axis","text":"<p>Using parameter <code>--hide-x-axis</code> you can deactivate visualisation of individual x-axis for each locus track and instead of them with <code>-slt</code> or <code>--scale-line-track</code> you can draw a scale line track below.</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --hide-x-axis --scale-line-track\n</code></pre> </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#highlighting-conserved-genes-instead-of-variable","title":"Highlighting conserved genes instead of variable","text":"<p>For many analysis purposes (e.g. conserved neighbourhood visualisation) we need to colorise conserved gene clusters instead of variable. It can be easily switched in lovis4u using <code>--set-group-color-for</code> parameter. By default it's set as \"variable\" but using <code>--set-group-color-for shell/core</code> will change it to the opposite mode. Note that if you have other feature group set in your features annotation table and want to set auto-colorising for them as well you can specify them in space separated list with this argument (e.g. <code>--set-group-color-for shell/core your_group_1 your_group_2</code>.</p> <pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl --set-group-color-for shell/core \n</code></pre> <p> </p> <p>Note: By default colours for groups are randomly set for each group using seaborn husl palette. In config file you can change to more intense hsl palette or change the desaturation parameter.</p>"},{"location":"ExampleDrivenGuide/cmd_guide/#specifying-figure-width","title":"Specifying figure width","text":"<p>Lovis4u tries to set an optimal figure width taking into account nucleotide size of visualisation window. You can change it in two ways: 1) Using <code>--mm-per-nt &lt;float value&gt;</code> argument changing scale which defines given space for each nt cell on canvas. Default: 0.0022 - 0.02, depending on window size. 2) With <code>-fw, --figure-width &lt;float value [cm]&gt;</code> parameter which defines total output figure width. We demonstrate usage by plotting compact visualisation of full loci together with <code>--show-first-feature-label-for</code> argument with empty list deactivating showing first occurrence label for shell/core genes.</p> <p><pre><code>lovis4u -gff lovis4u_data/guide/gff_files -hl -o width_test --show-first-feature-label-for --figure-width 7\n</code></pre> </p>"},{"location":"Parameters/cmd_parameters/","title":"\u0421ommand-line parameters","text":""},{"location":"Parameters/cmd_parameters/#post-install-steps","title":"Post-install steps","text":"<code>--data</code> Creates the 'lovis4u_data' folder in the current working directory.  The folder contains adjustable configuration files used by lovis4u  (e.g. config, palettes...) <code>--linux</code> Replaces the mmseqs path in the pre-made config file from the MacOS  version [default] to the Linux version. <code>--mac</code> Replaces the mmseqs path in the pre-made config file from the Linux"},{"location":"Parameters/cmd_parameters/#mandatory-arguments","title":"Mandatory arguments","text":"<code>-gff &lt;folder&gt;</code> Path to a folder containing extended gff files.  Each gff file should contain corresponding nucleotide sequence.  (designed to handle pharokka produced annotation files). <p>OR</p> <code>-gb &lt;folder&gt;</code> Path to a folder containing genbank files."},{"location":"Parameters/cmd_parameters/#optional-arguments-data-processing","title":"Optional arguments | Data processing","text":"<code>-laf, --loci-annotation-file &lt;file path&gt;</code> Path to the loci annotation table.  (See documentation for details) <code>-faf, --features-annotation-file &lt;file path&gt;</code> Path to the features annotation table.  (See documentation for details) <code>-mmseqs-off, --mmseqs-off</code> Deactivate mmseqs clustering of proteomes of loci. <code>-fv-off, --find-variable-off</code> Deactivate annotation of variable or conserved protein clusters. <code>-cl-off, --clust_loci-off</code> Deactivate defining locus order and using similarity based hierarchical clustering of proteomes. <code>-reorient_loci, --reorient_loci</code> Auto re-orient loci (set new strands) if they are not matched.  (Function tries to maximise co-orientation of homologous features.)"},{"location":"Parameters/cmd_parameters/#optional-arguments-loci-visualisation","title":"Optional arguments | Loci visualisation","text":"<code>-sgc-off, --set-group-color-off</code> Deactivate auto-setting of feature fill and stroke colors.  (Pre-set colors specified in feature annotation table will be kept.) <code>-sgcf, --set-group-color-for &lt;feature_group1 [feature group2 ...]&gt;</code> Space-separated list of feature groups for which colors should be set.  [default: variable, labeled] <code>-scc, --set-category-color</code> Set category color for features and plot category color legend. <code>-cct, --category-color-table &lt;file path&gt;</code> Path to the table with color code for categories.  Default table can be found in lovis4u_data folder. <code>-lls, --loci-label-style &lt;id|description|full&gt;</code> Locus label style based on input sequence annotation. <code>-safl, --show-all-feature-labels</code> Display all feature labels. <code>-sflf, --show-feature-label-for  &lt;feature_group1 [feature group2 ...]&gt;</code> Space-separated list of feature groups for which label should be shown.  [default: variable, labeled] <code>-sfflf, --show-first-feature-label-for &lt;feature_group1 [feature group2 ...]&gt;</code> Space-separated list of feature group types for which label will be displayed   only for the first occurrence of feature homologues group.  [default: shell/core] <code>-ifl, --ignored-feature-labels &lt;feature_label1 [feature_label2 ...]&gt;</code> Space-separated list of feature names for which label won't be shown.  [default: hypothetical protein, unknown protein] <code>-hix, --hide-x-axis</code> Do not plot individual x-axis for each locus track. <code>-dml, --draw-middle-line</code> Draw middle line for each locus. <code>-mm-per-nt, --mm-per-nt &lt;float value&gt;</code> Scale which defines given space for each nt cell on canvas.  [default: auto (0.0022 - 0.02, depending on window size)] <code>-fw, --figure-width &lt;float value&gt;</code> Output figure width in cm."},{"location":"Parameters/cmd_parameters/#optional-arguments-additional-tracks","title":"Optional arguments | Additional tracks","text":"<code>-hl, --homology-links</code> Draw homology link track. <code>-slt, --scale-line-track</code> Draw scale line track."},{"location":"Parameters/cmd_parameters/#optional-arguments-others","title":"Optional arguments | others","text":"<code>-o &lt;name&gt;</code> Output dir name. It will be created if it does not exist.  [default: lovis4u_{current_date}; e.g. uorf4u_2022_07_25-20_41] <code>--pdf-name &lt;name&gt;</code> Name of the output pdf file (will be saved in the output folder).  [default: lovis4u.pdf] <code>-c &lt;standard|&lt;file.cfg&gt;</code> Path to a configuration file or name of a premade config file  [default: standard]"},{"location":"Parameters/cmd_parameters/#miscellaneous-arguments","title":"Miscellaneous arguments","text":"<code>-h, --help</code> Show this help message and exit. <code>-v, --version</code> Show program version. <code>--debug</code> Provide detailed stack trace for debugging purposes. <code>-q, --quiet</code> Don't show progress messages."},{"location":"Parameters/config_parameters/","title":"Configuration file parameters","text":"<p>lovis4u configuration file allows detailed customization of the tool's parameters.</p> <p>Note: You can copy the lovis4u_data folder that contains the config files to your wiking directory with <code>lovis4u --data</code> command and safely edit and use them without affecting 'internal' config. If you want to use a copied config file, use <code>-c path_to_config</code>.</p>"},{"location":"Parameters/config_parameters/#description-is-under-construction","title":"Description is under construction...","text":"<p>;[Data Processing] default_transl_table = 11 gff_description_source = description gff_CDS_name_source = product  gff_CDS_category_source = function genbank_id_source = protein_id genbank_id_alternative_source = ID,id,PROTEIN_ID genbank_description_source = annotations:organism genbank_CDS_name_source = product genbank_CDS_category_source = function CDS_is_variable_cutoff = 0.25 keep_predefined_groups = True keep_predefined_colors = True  </p> <p>;[mmseqs parameters] mmseqs_cluster_mode = 0 mmseqs_cov_mode = 0 mmseqs_min_seq_id = 0.35 mmseqs_c = 0.8   mmseqs_s = 6.5  </p> <p>;[Paths] palette = {internal}/palette.txt mmseqs_binary = {internal}/bin/mmseqs_mac/bin/mmseqs   category_colors = {internal}/category_colors.tsv font_italic = {internal}/fonts/Lato-Italic.ttf font_light = {internal}/fonts/Lato-Light.ttf font_light_italic = {internal}/fonts/Lato-LightItalic.ttf font_regular = {internal}/fonts/Lato-Regular.ttf font_bold = {internal}/fonts/Lato-Bold.ttf font_mono = {internal}/fonts/RobotoMono-Regular.ttf  </p> <p>;[Output] verbose = True debug = False output_dir = lovis4u_{current_date}  </p> <p>;[General figure parameters] margin = 0.1 gap = 0.1 mm_per_nt = auto figure_width = None  </p> <p>;[Locus track primary settings] locus_label_style = full locus_label_description_font_face = italic locus_label_id_font_face = regular draw_individual_x_axis = True draw_middle_line = False feature_default_fill_color = fancy_grey feature_default_stroke_color = grey set_feature_stroke_color_based_on_fill_color = True feature_stroke_color_relative_lightness = 0.4 feature_group_types_to_set_color = variable,labeled groups_fill_color_palette_lib = seaborn groups_fill_color_seaborn_palette = husl groups_fill_color_seaborn_desat = 0.95 feature_labels_to_ignore = hypothetical protein, unknown protein feature_group_types_to_show_label = variable,labeled feature_group_types_to_show_label_on_first_occurrence = shell/core show_all_feature_labels = False category_color_seaborn_palette = hls category_color_seaborn_desat = 0.9  </p> <p>;[Locus track advanced settings] feature_height = 0.3 feature_stroke_width = 0.3 feature_arrow_length = 0.6 feature_bottom_gap = 0.04 locus_label_size = 0.7 locus_label_color = black locus_label_color_alpha = 1 gap_after_locus_label = 0.1 x_axis_ticks_height = 0.07 x_axis_ticks_labels_height = 0.1 x_axis_ticks_labels_font_face = light x_axis_line_width = 0.3 x_axis_line_color = black x_axis_line_color_alpha = 1 category_annotation_alpha = 1 category_annotation_line_width = 0.07 groups_fill_colors_pastel_factor = 0.4 feature_stroke_color_alpha = 1 feature_fill_color_alpha = 0.7 groups_stroke_colors_alpha = 1 feature_label_size = 0.5 feature_label_gap = 0.5 feature_label_font_face = regular gap_between_regions = 0.5  </p> <p>;[Homology_track] homology_fill_color = lightgrey homology_fill_color_alpha = 1 homology_line_width = 0.1 homology_stroke_color = grey homology_stroke_color_alpha = 0  </p> <p>;[Scale line track] scale_line_relative_size = 0.3 scale_line_width = 0.3 scale_line_tics_height = 0.05 scale_line_color = black scale_line_color_alpha = 1 scale_line_label_height = 0.13 scale_line_label_font_face = regular  </p> <p>;[Category color legend] color_legend_label_size = 0.15 color_legend_line_height = 0.07 color_legend_font_face = regular color_legend_label_color = black color_legend_label_color_alpha = 1  </p>"},{"location":"VersionLog/versions/","title":"Version log","text":"<ul> <li>Ver 0.0.3 - 3 May 2024 - first public release. </li> </ul>"}]}